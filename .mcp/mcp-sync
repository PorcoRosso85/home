#!/usr/bin/env bash
set -euo pipefail

# MCP Unified Management Tool v2.0 - Production Ready
# Single source of truth for MCP server configurations

# Default configuration
MASTER_FILE="${HOME}/.mcp/servers.json"
PROFILE="${PROFILE:-full}"
TARGET="${TARGET:-all}"
CHECK_ENV="${CHECK_ENV:-on}"
EXPAND_ENV="${EXPAND_ENV:-off}"
DRY_RUN=0

# Target paths
declare -A TARGET_PATHS=(
    ["claude"]="./.claude/mcp.json"
    ["codex"]="${HOME}/.codex/config.toml"
    ["opencode"]="${HOME}/.config/opencode/opencode.json"
)

# Utility functions
error() {
    echo "ERROR: $*" >&2
    exit 1
}

log() {
    echo "INFO: $*" >&2
}

# Path expansion - convert ~ and $HOME to absolute paths
expand_path() {
    local path="$1"
    # Replace ~ with $HOME
    path="${path/#~/$HOME}"
    # Replace $HOME with actual home directory
    path="${path//\$HOME/$HOME}"
    echo "$path"
}

# Validate paths are absolute
validate_absolute_path() {
    local path="$1"
    [[ "$path" = /* ]] || error "Path must be absolute: $path"
}

# Environment variable validation
check_env_vars() {
    local master_file="$1"

    if [[ "$CHECK_ENV" != "on" ]]; then
        return 0
    fi

    log "Checking environment variables..."

    # Extract all ${env:VAR} patterns and check if they exist
    local env_vars
    env_vars=$(jq -r '
        .. |
        select(type == "string" and test("\\$\\{env:[A-Z_][A-Z0-9_]*\\}")) |
        capture("\\$\\{env:(?<var>[A-Z_][A-Z0-9_]*)\\}").var
    ' "$master_file" 2>/dev/null | sort -u)

    for var in $env_vars; do
        if [[ -z "${!var:-}" ]]; then
            error "Required environment variable not set: $var"
        fi
    done

    log "Environment variables validated"
}

# Schema validation with enhanced checks
validate_schema() {
    local file="$1"

    log "Validating schema for $file..."

    # Check if file exists and is valid JSON
    if [[ ! -f "$file" ]]; then
        error "Master file not found: $file"
    fi

    if ! jq empty "$file" 2>/dev/null; then
        error "Invalid JSON in $file"
    fi

    # Basic structure validation
    if ! jq -e '
        (.version | type == "string") and
        (.mcpServers | type == "object") and
        (.profiles | type == "object")
    ' "$file" >/dev/null; then
        error "Basic schema validation failed for $file"
    fi

    # Validate each server individually
    local server_names
    server_names=$(jq -r '.mcpServers | keys[]' "$file")

    for server_name in $server_names; do
        if ! jq -e --arg name "$server_name" '
            .mcpServers[$name] |
            (.type | . == "stdio" or . == "sse" or . == "http") and
            (.command | type == "string") and
            (.args | type == "array" and all(.[]; type == "string")) and
            (.env | type == "object") and
            (.env | if . == {} then true else to_entries | map(.value | test("^\\$\\{env:[A-Z_][A-Z0-9_]*\\}$")) | all end) and
            ((.tags // ["all"]) | type == "array" and all(. == "all" or . == "claude" or . == "codex" or . == "opencode"))
        ' "$file" >/dev/null; then
            error "Server validation failed for: $server_name"
        fi
    done

    # Validate profiles reference existing servers
    local profiles_invalid
    profiles_invalid=$(jq -r '
        . as $root |
        .profiles | to_entries[] |
        .value[] as $server |
        select(($root.mcpServers | has($server) | not)) |
        "Profile \(.key) references unknown server: \($server)"
    ' "$file" 2>/dev/null)

    if [[ -n "$profiles_invalid" ]]; then
        error "$profiles_invalid"
    fi

    log "Schema validation passed"
}

# Expand all paths in server configurations
expand_server_paths() {
    local servers_json="$1"

    echo "$servers_json" | jq '
        .mcpServers | to_entries | map(
            .value.args = (.value.args | map(
                if test("^[~$]") then
                    # This will be handled by bash expansion
                    .
                else
                    .
                end
            ))
        ) | from_entries
    '
}

# Filter servers by profile and tags
filter_servers() {
    local master_file="$1"
    local profile="$2"
    local target_tags="$3"

    # Get servers for profile
    local server_list
    server_list=$(jq -r ".profiles[\"$profile\"] // empty | .[]" "$master_file")

    if [[ -z "$server_list" ]]; then
        # If profile doesn't exist, use all servers
        server_list=$(jq -r '.mcpServers | keys[]' "$master_file")
    fi

    # Filter by tags for specific targets
    local filtered_servers="{}"
    for server in $server_list; do
        local server_tags
        server_tags=$(jq -r ".mcpServers[\"$server\"].tags // [\"all\"] | @csv" "$master_file" | tr -d '"')

        # Check if server should be included for this target
        local include_server=0
        IFS=',' read -ra tags_array <<< "$server_tags"
        for tag in "${tags_array[@]}"; do
            if [[ "$tag" == "all" ]] || [[ ",$target_tags," == *",$tag,"* ]]; then
                include_server=1
                break
            fi
        done

        if [[ $include_server -eq 1 ]]; then
            local server_config
            server_config=$(jq ".mcpServers[\"$server\"]" "$master_file")
            filtered_servers=$(echo "$filtered_servers" | jq ". + {\"$server\": $server_config}")
        fi
    done

    echo "$filtered_servers"
}

# Render for Claude Code CLI
render_claude() {
    local servers="$1"
    jq -S '{mcpServers: .}' <<< "$servers"
}

# Render for Codex CLI (TOML format)
render_codex() {
    local servers="$1"

    echo "# Generated by mcp-sync"
    echo ""

    # Get server names and sort them
    local server_names
    server_names=$(echo "$servers" | jq -r 'keys[]' | sort)

    for server_name in $server_names; do
        echo "[mcp_servers.$server_name]"

        # Get command
        local command
        command=$(echo "$servers" | jq -r ".\"$server_name\".command")
        echo "command = \"$command\""

        # Get args array
        local args_json
        args_json=$(echo "$servers" | jq -c ".\"$server_name\".args")
        local args_toml="["
        local first=true

        # Parse JSON array to TOML array
        local arg
        while IFS= read -r arg; do
            if [ "$first" = true ]; then
                first=false
            else
                args_toml+=", "
            fi
            # Escape quotes in the argument
            arg_escaped=${arg//\"/\\\"}
            args_toml+="\"$arg_escaped\""
        done < <(echo "$args_json" | jq -r '.[]')

        args_toml+="]"
        echo "args = $args_toml"

        # Get env if present and not empty
        local env_keys
        env_keys=$(echo "$servers" | jq -r ".\"$server_name\".env | keys[]" 2>/dev/null | sort)

        if [ -n "$env_keys" ]; then
            echo "[mcp_servers.$server_name.env]"
            for env_key in $env_keys; do
                local env_value
                env_value=$(echo "$servers" | jq -r ".\"$server_name\".env.\"$env_key\"")
                echo "$env_key = \"$env_value\""
            done
        fi

        echo ""
    done
}

# Render for OpenCode
render_opencode() {
    local servers="$1"
    jq -S '{mcpServers: .}' <<< "$servers"
}

# Safe atomic write with backup
write_safe() {
    local target="$1"
    local content="$2"

    # Create directory if it doesn't exist
    mkdir -p "$(dirname "$target")"

    # Create temporary file
    local temp_file
    temp_file=$(mktemp)
    echo "$content" > "$temp_file"

    # Check if content is different
    if cmp -s "$temp_file" "$target" 2>/dev/null; then
        log "No changes needed for $target"
        rm -f "$temp_file"
        return 0
    fi

    # Backup existing file if it exists
    if [[ -f "$target" ]]; then
        cp "$target" "$target.bak"
        log "Backed up $target to $target.bak"
    fi

    # Atomic move
    install -m 600 "$temp_file" "$target"
    rm -f "$temp_file"

    log "Updated $target"
}

# Show diff between files
show_diff() {
    local old_file="$1"
    local new_file="$2"

    if [[ -f "$old_file" ]]; then
        git --no-pager diff --no-index --color -- "$old_file" "$new_file" 2>/dev/null || true
    else
        echo "=== New file: $new_file ==="
        cat "$new_file"
    fi
}

# Deploy to specific target
deploy_target() {
    local target="$1"
    local servers="$2"

    local target_path="${TARGET_PATHS[$target]}"
    local rendered_content

    case "$target" in
        claude)
            rendered_content=$(render_claude "$servers")
            ;;
        codex)
            rendered_content=$(render_codex "$servers")
            ;;
        opencode)
            rendered_content=$(render_opencode "$servers")
            ;;
        *)
            error "Unknown target: $target"
            ;;
    esac

    # Expand paths in target_path
    target_path=$(expand_path "$target_path")

    if [[ $DRY_RUN -eq 1 ]]; then
        echo "=== DRY RUN: Changes for $target ($target_path) ==="
        local temp_file
        temp_file=$(mktemp)
        echo "$rendered_content" > "$temp_file"
        show_diff "$target_path" "$temp_file"
        rm -f "$temp_file"
        echo ""
    else
        write_safe "$target_path" "$rendered_content"
    fi
}

# Main execution
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --profile)
                PROFILE="$2"
                shift 2
                ;;
            --target)
                TARGET="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            --check-env)
                CHECK_ENV="$2"
                shift 2
                ;;
            --expand-env)
                EXPAND_ENV="$2"
                shift 2
                ;;
            -h|--help)
                cat <<EOF
MCP Unified Management Tool v2.0

USAGE:
    mcp-sync [OPTIONS]

OPTIONS:
    --profile PROFILE    Profile to use (default: full)
    --target TARGETS     Comma-separated targets (default: all)
                        Available: claude, codex, opencode, all
    --dry-run           Show changes without applying them
    --check-env on|off  Check environment variables (default: on)
    --expand-env on|off Expand environment variables (default: off)
    -h, --help          Show this help

EXAMPLES:
    mcp-sync                                    # Apply all servers to all targets
    mcp-sync --profile minimal                 # Apply minimal profile to all targets
    mcp-sync --target claude,codex             # Apply to specific targets
    mcp-sync --dry-run                         # Preview changes
    mcp-sync --profile minimal --target claude --dry-run
EOF
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    # Validate master file
    validate_schema "$MASTER_FILE"
    check_env_vars "$MASTER_FILE"

    # Process targets
    if [[ "$TARGET" == "all" ]]; then
        TARGET="claude,codex,opencode"
    fi

    IFS=',' read -ra TARGETS <<< "$TARGET"

    # Validate targets
    for target in "${TARGETS[@]}"; do
        if [[ ! "${TARGET_PATHS[$target]:-}" ]]; then
            error "Unknown target: $target"
        fi
    done

    if [[ $DRY_RUN -eq 1 ]]; then
        echo "=== DRY RUN MODE: No files will be modified ==="
        echo ""
    fi

    # Deploy to each target
    for target in "${TARGETS[@]}"; do
        log "Processing target: $target"

        # Filter servers for this target
        local filtered_servers
        filtered_servers=$(filter_servers "$MASTER_FILE" "$PROFILE" "$target")

        # Deploy
        deploy_target "$target" "$filtered_servers"
    done

    if [[ $DRY_RUN -eq 0 ]]; then
        log "Deployment completed successfully"
    else
        log "Dry run completed - no changes made"
    fi
}

# Run main function
main "$@"