## 計画初期

### 1. 要件

#### 1.1. 目的
*   型の依存関係をグラフ構造化し、型に沿った実装を可能にする情報を格納
*   格納された情報をクエリ可能にする

#### 1.2. 機能要件

##### 1.2.1. 型定義構文の網羅的なリストアップ
*   1.2.1.1. inductive
*   1.2.1.2. structure
*   1.2.1.3. class
*   1.2.1.4. その他 (alias, opaque, theorem, def など)

##### 1.2.2. 複数ファイルに跨る型定義の取り扱い
*   1.2.2.1. 単一leanファイル
*   1.2.2.2. 依存関係は考慮せず全てデータとして扱う
*   1.2.2.3. 型定義数: 1000以下を想定

##### 1.2.3. 型定義の依存関係の粒度
*   1.2.3.1. メンバーレベルの依存関係 (例: User型のnameフィールドがString型に依存)

##### 1.2.4. 依存関係の表現形式
*   1.2.4.1. グラフ構造 (ノードとエッジ)
*   1.2.4.2. データ形式: SQLite を検討

##### 1.2.5. クエリの種類
*   1.2.5.1. 特定の型が依存する型の一覧を取得
*   1.2.5.2. 特定の型に依存する型の一覧を取得
*   1.2.5.3. 型定義全体のグラフ構造を取得
*   1.2.5.4. 特定の型の詳細情報 (定義、依存関係など) を取得

##### 1.2.6. leanファイル (データファイル) の配置場所、命名規則
*   1.2.6.1. プロジェクトルートからの相対パスで指定
*   1.2.6.2. `./Data` 配下に配置

##### 1.2.7. データベースの種類
*   1.2.7.1. SQLite
*   1.2.7.2. 選定理由: ローカル動作限定の想定

##### 1.2.8. エラーハンドリング
*   1.2.8.1. エラー型定義を行う
*   1.2.8.2. エラーの種類をカテゴライズし一覧化
    *   1.2.8.2.1. 型定義構文が不正な場合 (IOError型？)
    *   1.2.8.2.2. 依存関係抽出失敗
    *   1.2.8.2.3. データベース格納失敗 (DatabaseError型？)
    *   1.2.8.2.4. クエリ実行時エラー (DatabaseError型？)

### 2. 設計

#### 2.1. 型定義ファイル (leanファイル) のパース処理
*   2.1.1. Leanのパーサー機能を活用
    * [ref/meta.yaml#introduction](https://leanprover-community.github.io/lean4-metaprogramming-book/#introduction)
    * [ref/meta.yaml#overview](https://leanprover-community.github.io/lean4-metaprogramming-book/main/02_overview.html)
    * [ref/meta.yaml#elaboration](https://leanprover-community.github.io/lean4-metaprogramming-book/main/07_elaboration.html)
    * [ref/meta.yaml#syntax](https://leanprover-community.github.io/lean4-metaprogramming-book/main/05_syntax.html)
    * [ref/meta.yaml#metam](https://leanprover-community.github.io/lean4-metaprogramming-book/main/04_metam.html)k
*   2.1.2. `CoreM`, `MetaM` を利用しLean環境から型定義一覧を取得
    *   2.1.2.1. `Environment` から `inductive`, `structure`, `class` などの型定義を抽出
    *   2.1.2.2. `alias`, `opaque`, `theorem`, `def` 構文のパース処理を追加
    *   2.1.2.3. 各構文から取得する情報を明記 (例: `theorem` は型情報のみ)
*   2.1.3. 各型定義の詳細情報取得
    *   2.1.3.1. 型名から `getConstInfo` で詳細情報 (`ConstantInfo`) を取得
        *   2.1.3.1.1. `ConstantInfo` には `type`, `value` などが含まれる

#### 2.2. 型情報の `Expr` 操作
*   2.2.1. `ConstantInfo` から取得した型情報を `Expr` として操作
*   2.2.2. `instantiateMVars`, `reduce`, `whnf` などで型を簡約化、情報抽出

#### 2.3. 依存関係解析
*   2.3.1. 型情報 (`type`, `value`) の `Expr` を解析し依存関係を抽出
*   2.3.2. `forallTelescope` などで関数の型を分解し、引数・返り値の型から依存関係を分析
*   2.3.3. メンバーレベルの依存関係を抽出

#### 2.4. 依存関係の構造化と出力
*   2.4.1. 依存関係の解析結果をグラフ構造で表現し出力
*   2.4.2. データ形式: SQLite を検討
*   2.4.3. ノードとエッジで表現 (ノード: 型定義、エッジ: 依存関係)

#### 2.5. データベーススキーマ設計
*   2.5.1. Structure テーブル (型定義情報を格納)
*   2.5.2. Dependency テーブル (依存関係をエッジとして表現)
    *   2.5.2.1. 有向グラフで表現
*   2.5.3. グラフデータ構造
    *   2.5.3.1. ノード: 型定義 (型名、定義ファイルパス、定義行数、詳細情報)
    *   2.5.3.2. エッジ: 依存関係 (依存元型 -> 依存先型、依存の種類)
    *   2.5.3.3. テーブルのカラム定義、データ型を明確化
    *   2.5.3.4. クエリ効率向上のためのインデックス設計を検討
    *   2.5.3.5. ノードとエッジの属性を具体的に記述 (TODO に移動)

#### 2.6. エラー処理設計
*   2.6.1. エラーの種類とエラー型、エラーメッセージ例、ログ出力例、処理方針をまとめた表を追加 (TODO に移動)
*   2.6.2. エラーの種類をカテゴライズしエラー型定義に反映
*   2.6.3. エラー発生時の処理フローを設計ドキュメントに図示またはテキストで記述 (TODO に移動)

#### 2.7. テスト設計
*   2.7.1. 単体テスト、結合テスト、E2Eテスト
*   2.7.2. テストケース作成 (正常系、異常系)

#### 2.8. ドキュメント作成
*   2.8.1. 設計ドキュメント (アーキテクチャ、データモデル、API仕様)
*   2.8.2. ユーザーマニュアル (インストール、使い方、クエリ例)

#### 2.9. ディレクトリ構成
*   2.9.1. 具体的な命名規則を追記 (例: 型カテゴリごとにディレクトリ分割)
*   2.9.2. 例: `./Data/Inductive/Nat.lean`, `./Data/Structure/List.lean`

#### 2.10. TODO
*   2.10.1. **Leanパーサー機能の活用方法**:
    *   2.10.1.1. 利用する Lean パーサーAPI の関数名を記述
    *   2.10.1.2. パース処理のコード例 (pseudo-code or Lean code snippet) を追加
*   2.10.2. **型情報のExpr操作の具体例**:
    *   2.10.2.1. `Expr` 操作関数の具体的なコード例や処理フローを追記
    *   2.10.2.2. `getConstInfo` で取得した `ConstantInfo` から `type` 情報を取得し、`whnf` で簡約化する例などを追加
    *   2.10.2.3. 依存関係解析処理における `instantiateMVars` や `reduce` の適用例を追加
*   2.10.3. 2.5.3.5. グラフデータ構造のノードとエッジの属性を詳細に記述
*   2.10.4. 2.6.1. エラーの種類とエラー型、エラーメッセージ例、ログ出力例、処理方針をまとめた表を追加
*   2.10.5. 2.6.3. エラー発生時の処理フローを設計ドキュメントに図示またはテキストで記述

### 3. 作業計画

#### 3.1. ドキュメント参照計画
*   3.1.1. ドキュメントのどこに必要な情報があるかを把握
*   3.1.2. 把握した情報と設計項目をリンク (例: {id: 1, design: 構文検証, doc: [１章, 2章, 4章]})

## 計画中期

### 4. 要件

#### 4.1. 非機能要件

##### 4.1.1. パフォーマンス要件
*   4.1.1.1. 型定義ファイル読み込み時間
*   4.1.1.2. 依存関係抽出時間
*   4.1.1.3. データベース格納時間
*   4.1.1.4. クエリ応答時間
*   4.1.1.5. 具体的な数値目標があれば明記

##### 4.1.2. スケーラビリティ要件
*   4.1.2.1. 型定義数増加時の性能劣化許容範囲
*   4.1.2.2. データ量増加時の性能劣化許容範囲

##### 4.1.3. セキュリティ要件
*   4.1.3.1. データへのアクセス制御
*   4.1.3.2. データベースへのアクセス制御

##### 4.1.4. メンテナンス性・保守性
*   4.1.4.1. コードの可読性、保守性
*   4.1.4.2. ドキュメントの整備
*   4.1.4.3. テストコードの充実

##### 4.1.5. 拡張性
*   4.1.5.1. 新しい型定義構文への対応
*   4.1.5.2. 新しいクエリ種類の追加
*   4.1.5.3. 他のツールとの連携 (例: 可視化ツール)

##### 4.1.6. UI/UX
*   4.1.6.1. クエリ実行方法 (コマンドラインインターフェース、API、GUI)
*   4.1.6.2. クエリ結果の表示形式
*   4.1.6.3. エラーメッセージの分かりやすさ

### 5. 設計

#### 5.1. パフォーマンス改善策
*   5.1.1. データベースのインデックス設計
*   5.1.2. クエリの最適化
*   5.1.3. キャッシュ機構の導入

#### 5.2. セキュリティ対策
*   5.2.1. データベースへのアクセス制御 (認証、認可)
*   5.2.2. 入力値の検証 (サニタイズ)
