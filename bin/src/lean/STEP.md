**ステップ1: 環境構築とプロジェクト準備 (期間: 1日〜3日)**

*   **目的**: 開発環境を整え、プロジェクトの骨組みを作成する。
*   **手順**:
    1.  **Lean開発環境のセットアップ**: Lean4がインストールされ、正常に動作することを確認します。VSCodeなどのエディタ拡張機能も導入し、開発効率を高めます。
    2.  **Lakeプロジェクトの初期化**: `lake new todo_inspector` などでプロジェクトの雛形を作成します。これにより、`lakefile.lean` など必要なファイルが自動生成されます。
    3.  **リポジトリの初期化**: Gitリポジトリを初期化し、`.gitignore` を設定、初期コミットを行います。
    4.  **ディレクトリ構成の検討**: `TODO.md` の「2.9. ディレクトリ構成」を参考に、初期のディレクトリ構成を決定します。例えば、`./Data`, `./Parser`, `./Database`, `./Test`, `./Doc` などの基本ディレクトリを作成します。
*   **ポイント**:
    *   **早期に実行可能な状態にする**:  環境構築を最初に行うことで、後の開発で問題が発生した場合に切り分けが容易になります。
    *   **バージョン管理**: バージョン管理システムを導入することで、コードの変更履歴を管理し、共同開発や手戻りを容易にします。
*   **成果物**:
    *   Lean開発環境
    *   Lakeプロジェクト
    *   Gitリポジトリ (初期コミット済)
    *   初期ディレクトリ構成

**ステップ2: データモデル設計とSQLite設定 (期間: 2日〜5日)**

*   **目的**: 型定義、依存関係、グラフ構造を表現するためのデータモデルを設計し、SQLiteデータベースの設定を行う。
*   **手順**:
    1.  **データモデルの設計**:
        *   `TODO.md` の「2.5. データベーススキーマ設計」を参考に、`Structure` テーブルと `Dependency` テーブルのスキーマを詳細に設計します。
        *   ノード (型定義) とエッジ (依存関係) の属性を具体的に定義します (TODO: 2.10.3)。
        *   データ型、カラム定義、インデックス設計を明確にします。
    2.  **SQLiteデータベースの初期設定**:
        *   SQLiteデータベースファイル (`./Data/type_dependency.db` など) を作成します。
        *   設計したスキーマに基づいて、`Structure` テーブルと `Dependency` テーブルをSQLiteデータベース上に作成します。
        *   必要に応じて、初期データを投入します (テストデータなど)。
    3.  **DB接続ロジックの実装**:
        *   LeanからSQLiteデータベースに接続するための基本的なロジックを実装します。
        *   DB接続のテストを行い、正常に接続できることを確認します。
*   **ポイント**:
    *   **データモデルの柔軟性**:  要件変更に柔軟に対応できるよう、データモデルは拡張性、保守性を考慮して設計します。
    *   **SQLite選定の検証**: ローカル動作限定という要件に基づきSQLiteを選定していますが、必要に応じて他のデータベースも検討します。
*   **成果物**:
    *   データモデル定義書 (ER図、DDLなど)
    *   SQLiteデータベースファイル (`.db` ファイル)
    *   LeanからのSQLite接続ロジック (初期実装)

**ステップ3:  型定義構文パースとデータ抽出 (期間: 3日〜7日)**

*   **目的**: Leanファイルの型定義構文をパースし、必要な情報をデータとして抽出する機能を実装する。
*   **手順**:
    1.  **パーサー機能の調査**:
        *   `TODO.md` の「2.1. 型定義ファイル (leanファイル) のパース処理」と「2.10.1. Leanパーサー機能の活用方法」を参考に、LeanのパーサーAPI (`CoreM`, `MetaM`, `Environment`, `getConstInfo` など) の利用方法を詳細に調査します。
        *   [Lean 4 メタプログラミング書籍](https://leanprover-community.github.io/lean4-metaprogramming-book/) の該当章を精読し、コード例を参考に実装方針を検討します。
    2.  **基本構文のパース実装**:
        *   `inductive`, `structure`, `class` などの基本構文に対応したパーサー関数を実装します。
        *   `Environment` から型定義一覧を取得する基本的な処理を実装します (TODO: 2.1.2.1)。
    3.  **詳細情報取得の実装**:
        *   型名から `getConstInfo` で詳細情報 (`ConstantInfo`) を取得する処理を実装します (TODO: 2.1.3.1)。
        *   `ConstantInfo` から `type` などの情報を抽出する処理を実装します (TODO: 2.10.2.2)。
    4.  **パース処理のテスト**:
        *   用意したLeanファイル (例: `./Data/Inductive/Nat.lean`, `./Data/Structure/List.lean`) を用いてパース処理をテストします。
        *   抽出された型定義情報が正しいか検証します。
*   **ポイント**:
    *   **段階的な構文対応**: まずは基本構文に絞り込み、徐々に `alias`, `opaque`, `theorem`, `def` など、対応構文を拡張していくアプローチで進めます (TODO: 2.1.2.2)。
    *   **エラーハンドリング**: パース処理におけるエラーハンドリング (TODO: 1.2.8.2.1) を実装し、不正な構文に対するRobust性を高めます。
*   **成果物**:
    *   基本構文パース関数 (初期実装)
    *   型定義情報抽出関数 (初期実装)
    *   パース処理テストコード
    *   パース処理エラーハンドリング (初期実装)

**ステップ4:  型情報のExpr操作と依存関係解析 (期間: 5日〜10日)**

*   **目的**: 抽出した型情報を `Expr` として操作し、型定義間の依存関係を解析する機能を実装する。
*   **手順**:
    1.  **Expr操作の実装**:
        *   `ConstantInfo` から取得した型情報を `Expr` として操作する処理を実装します (TODO: 2.2.1)。
        *   `instantiateMVars`, `reduce`, `whnf` などを用いて型を簡約化、情報抽出する処理を実装します (TODO: 2.2.2, 2.10.2.2, 2.10.2.3)。
        *   `Expr` 操作関数の具体的なコード例や処理フローをドキュメントに追記します (TODO: 2.10.2.1)。
    2.  **依存関係解析の実装**:
        *   型情報 (`type`, `value`) の `Expr` を解析し、型定義間の依存関係を抽出する処理を実装します (TODO: 2.3.1)。
        *   `forallTelescope` などで関数の型を分解し、引数・返り値の型から依存関係を分析する処理を実装します (TODO: 2.3.2)。
        *   メンバーレベルの依存関係 (例: フィールドの型) を抽出する処理を実装します (TODO: 2.3.3)。
    3.  **依存関係解析のテスト**:
        *   様々なLeanファイル (依存関係を含む) を用いて依存関係解析をテストします。
        *   抽出された依存関係が正しいか検証します。
    4.  **依存関係抽出失敗時のエラーハンドリング**: 依存関係抽出失敗時のエラーハンドリング (TODO: 1.2.8.2.2) を実装し、エラー発生時の処理フローを設計ドキュメントに図示またはテキ ストで記述します (TODO: 2.6.3, 2.10.5)。
*   **ポイント**:
    *   **Expr操作の理解**:  `Expr` の構造と操作 (簡約化、情報抽出) を十分に理解することが重要です。
    *   **依存関係の粒度**:  初期段階では、メンバーレベルの依存関係 (TODO: 1.2.3.1) に焦点を当て、複雑な依存関係 (例: 型クラス、型パラメータ) は後回しにするなど、段階的なアプローチも検討します。
*   **成果物**:
    *   Expr操作関数 (拡充)
    *   依存関係解析関数 (初期実装)
    *   依存関係解析テストコード
    *   依存関係抽出失敗時のエラーハンドリング (初期実装)

**ステップ5: 依存関係の構造化とDB格納 (期間: 3日〜7日)**

*   **目的**: 解析した依存関係をグラフ構造として表現し、SQLiteデータベースに格納する機能を実装する。
*   **手順**:
    1.  **グラフ構造化**:
        *   依存関係解析の結果を、ノード (型定義) とエッジ (依存関係) を持つグラフ構造として表現する処理を実装します (TODO: 2.4.1, 1.2.4.1)。
        *   グラフデータ構造のノードとエッジの属性を詳細に記述します (TODO: 2.5.3.5, 2.10.3)。
    2.  **DB格納処理の実装**:
        *   グラフ構造をSQLiteデータベースに格納する処理を実装します (TODO: 2.4.2, 2.5.2)。
        *   `Structure` テーブルと `Dependency` テーブルへのデータ格納処理を実装します。
    3.  **DB格納処理のテスト**:
        *   依存関係を構造化したデータをDBに格納する処理をテストします。
        *   DBに格納されたデータが正しいか検証します。
    4.  **データベース格納失敗時のエラーハンドリング**: データベース格納失敗時のエラーハンドリング (TODO: 1.2.8.2.3) を実装し、エラーの種類とエラー型、エラーメッセージ例、ログ出 力例、処理方針をまとめた表を追加します (TODO: 2.6.1, 2.10.4)。
*   **ポイント**:
    *   **グラフ構造の表現**:  グラフ構造を効率的に表現するデータ構造 (例: adjacency list, adjacency matrix) を検討します。
    *   **DB格納の効率性**:  大量の型定義と依存関係を効率的にDBに格納する方法 (例: batch insert) を検討します。
*   **成果物**:
    *   依存関係グラフ構造化処理
    *   グラフデータDB格納処理
    *   DB格納処理テストコード
    *   データベース格納失敗時のエラーハンドリング (初期実装)
    *   エラーの種類とエラー型一覧表 (初期版)

**ステップ6:  クエリ機能の実装とテスト (期間: 3日〜7日)**

*   **目的**: データベースに格納された型定義情報をクエリする機能を実装し、テストを行う。
*   **手順**:
    1.  **クエリAPIの実装**:
        *   `TODO.md` の「1.2.5. クエリの種類」を参考に、必要なクエリ (特定の型が依存する型の一覧、特定の型に依存する型の一覧、グラフ構造全体、特定の型の詳細情報) をSQLクエリとして実装します (TODO: 1.2.5)。
        *   クエリAPI (Lean関数) を実装し、SQLクエリを実行して結果を取得する処理を実装します。
    2.  **クエリ機能のテスト**:
        *   実装したクエリAPIを用いて、様々なクエリを実行し、結果を検証します。
        *   クエリの種類 (TODO: 1.2.5.1〜1.2.5.4) ごとにテストケースを作成し、網羅的にテストを行います (TODO: 2.7.2)。
    3.  **クエリ実行時エラーハンドリング**: クエリ実行時エラーハンドリング (TODO: 1.2.8.2.4) を実装します。
*   **ポイント**:
    *   **クエリ効率**:  クエリの種類 (TODO: 1.2.5) に最適化されたSQLクエリ (例: index活用) を設計します (TODO: 2.5.3.4, 5.1.1)。
    *   **クエリ結果の形式**: クエリ結果をLeanで扱いやすいデータ形式 (例: `List`, `Option`) に変換する処理を実装します。
*   **成果物**:
    *   クエリAPI (初期実装)
    *   クエリ機能テストコード
    *   クエリ実行時エラーハンドリング (初期実装)

**ステップ7:  ドキュメント作成とリファクタリング (期間: 2日〜5日)**

*   **目的**:  初期段階の実装内容をドキュメントにまとめ、コードのリファクタリングを行う。
*   **手順**:
    1.  **設計ドキュメント作成**:
        *   ここまでの設計と実装内容を設計ドキュメントに反映します (TODO: 2.8.1)。
        *   アーキテクチャ図、データモデル図、API仕様 (初期版) などを記述します。
        *   TODOリスト (TODO.md) を見直し、未完了項目や変更点を反映します (TODO: 2.6.1, 2.6.3, 2.9.1, 2.10.3, 2.10.4, 2.10.5)。
    2.  **コードリファクタリング**:
        *   コードの可読性、保守性を向上させるためのリファクタリングを行います (TODO: 4.1.4.1)。
        *   命名規則、コーディング規約などを適用し、コードを整理します (TODO: 2.9.1, 2.9.2)。
        *   重複コードの削減、処理の共通化などを検討します。
    3.  **単体テスト、結合テストの拡充**:
        *   ステップ3〜ステップ6で実装した機能の単体テスト、結合テストを拡充します (TODO: 2.7.1, 2.7.2)。
        *   テストカバレッジを高め、コードの品質を向上させます。
*   **ポイント**:
    *   **ドキュメントの継続的な更新**: ドキュメントは開発の進捗に合わせて継続的に更新し、常に最新の状態を保ちます (TODO: 4.1.4.2)。
    *   **コード品質の向上**:  リファクタリングを通じて、コードの品質を高め、長期的な開発・保守性を確保します (TODO: 4.1.4.1)。
*   **成果物**:
    *   設計ドキュメント (初期版)
    *   リファクタリングされたコード
    *   拡充されたテストコード

**全体スケジュール**: 上記のステップ1からステップ7までを合計すると、**16日〜37日** 程度の期間が目安となります。ただし、各ステップの期間はあくまで目安であり、個々のスキルや習熟度 、プロジェクトの複雑さによって変動する可能性があります。

**実装の順番**: 提案した手順は、あくまで初期段階の作業手順です。この初期手順完了後、TODOリストの「計画中期」以降の項目 (非機能要件、パフォーマンス改善、セキュリティ対策、UI/UX設 計など) を考慮しながら、より詳細な実装計画を立てていくと良いでしょう。
