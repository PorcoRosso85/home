import Lean
import Src.Logger
import Src.Refer

open Lean

-- 単一の型に対してテスト
-- WARNING BlogなどRefer.leanファイルに定義済み＝ビルド済みなので、このファイルにBlog依存関係を作成する場合削除し再ビルドすること
#eval show MetaM Unit from do
  let deps ← getInductiveTypeDeps `Greeting
  IO.println s!"Greeting: {deps}"
  let deps ← getInductiveTypeDeps `Blog
  IO.println s!"Blog: {deps}"


/-
いいえ、Blog.lean のように関数型により依存関係を示す目的だとした場合、structure や def では問題があります。inductive を使うのが適切であり、structure や
def は不適切です。

まず、Blog.lean の型定義は「関数型により依存関係を示す」ことを目的としていません。Blog.lean で inductive
を使って定義しているのは、ブログ記事というデータ構造です。Job, Where, Email, Greeting, About, Intro, Blog
は、ブログ記事を構成する要素を型として表現しており、それぞれの型が持つコンストラクタ (mk) は、その型のデータの作り方を定義しています。

これらの型定義は、ブログ記事の構造を型システム上にモデル化することが目的であり、型同士の依存関係を関数型で示すことが目的ではありません。

もし、「関数型により依存関係を示す」 という言葉を、

 • 型Aの定義が型Bを参照している
 • 型Aのコンストラクタが型Bの値を引数として取る

という意味で捉えているのであれば、それは inductive 型定義の基本的な性質であり、structure や def でも同様のことは可能です。しかし、structure や def で
Blog.lean のような型定義を行うことは、目的と手段が一致しておらず、多くの問題を引き起こします。

structure や def が Blog.lean の型定義に不適切な理由:

 1 代数的データ型 (ADT) の表現:
    • Blog.lean で定義したいのは、複数のバリアント (場合分け) を持つデータ構造、つまり代数的データ型 (ADT) です。例えば、Intro 型は Greeting と About
      を組み合わせて作られる「導入部」を表し、Blog 型は Intro を使って作られる「ブログ記事」を表します。
    • inductive は、まさに代数的データ型 (ADT)
      を定義するための構文です。複数のコンストラクタを定義でき、パターンマッチングによる処理分岐を自然にサポートします。
    • structure はレコード型を定義するためのものであり、複数のバリアントを持つデータ構造を表現するのには不向きです。def
      は型エイリアスやレコード型もどきを定義できますが、ADT を表現する機能はありません。
 2 パターンマッチングの必要性:
    • Blog.lean で定義した型は、将来的にパターンマッチングを使って処理されることが想定されます。例えば、ブログ記事をドキュメントに変換する処理では、Blog
      型や Intro 型の構造に応じて処理を分岐させる必要があります。
    • inductive はパターンマッチングを強力にサポートします。match 式を使うことで、データの構造に応じた処理を簡潔に記述できます。
    • structure はパターンマッチングを限定的にサポートしますが、inductive ほど柔軟ではありません。def はパターンマッチングを直接的にはサポートしません。
 3 再帰的なデータ構造:
    • Blog.lean の例では再帰的な型定義は含まれていませんが、一般的にブログ記事のような構造は、再帰的な要素 (例: コメント、カテゴリ、タグなど)
      を含む可能性があります。
    • inductive は再帰的な型定義を自然にサポートします。List 型や Tree 型のように、型定義の中で自分自身を参照する型を定義できます。
    • structure や def で再帰的なデータ構造を定義するのは困難です。
 4 意味的な明確さ:
    • inductive を使うことで、「これは代数的データ型を定義している」という意図がコードを読む人に明確に伝わります。
    • structure や def を使うと、データ構造を定義している意図が曖昧になり、コードの可読性や保守性が低下する可能性があります。

inductive が Blog.lean の型定義に適切な理由 (再強調):

 • 代数的データ型 (ADT) の定義に最適:  複数のバリアントを持つデータ構造を自然に表現できる。
 • パターンマッチングを強力にサポート:  データ構造に応じた処理分岐を簡潔に記述できる。
 • 再帰的なデータ構造をサポート:  複雑なデータ構造を型安全に表現できる。
 • コードの意図が明確になる:  「代数的データ型を定義している」という意図が伝わりやすい。

結論:

Blog.lean
の型定義は、データ構造を定義することが目的であり、「関数型により依存関係を示す」ことが目的ではありません。そして、データ構造を定義するためには、inductive
を使うのが適切であり、structure や def は不適切です。

structure や def は、それぞれレコード型や型エイリアスを定義するための構文であり、inductive の代替にはなりません。目的 (データ構造の定義 vs. レコード型 vs.
型エイリアス) に応じて、適切な型定義方法を選択することが重要です。
-/

/-
TODO
分岐をinductionで表せそう
すなわち
関数内の処理分岐を表現できそう

- | xxxError
- | xxxError
- | success
-/

