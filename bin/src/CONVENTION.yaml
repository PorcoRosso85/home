# ユニバーサルコーディング規約
# 対象言語: TypeScript, Python, Go, Rust, Zig

## 設計原則:
  - データと処理を分離
  - エラーを値として扱う
  - 依存性を明示的に注入
  - 最小構成を維持
  - 関数の合成可能性を重視
  - 副作用を境界に隔離

## 命名規則:
  files:
    all: camelCase（例: parseConfig.ts, parseConfig.py, parseConfig.go）
    exceptions: 
      - React components: PascalCase.tsx
      - Go: snake_case許容（go.modの慣習）
  
  identifiers:
    # 各言語の標準に従う
    typescript: { variables: camelCase, types: PascalCase, constants: UPPER_SNAKE_CASE }
    python: { variables: snake_case, classes: PascalCase, constants: UPPER_SNAKE_CASE }
    go: { exported: PascalCase, unexported: camelCase, constants: PascalCase }
    rust: { variables: snake_case, types: PascalCase, constants: UPPER_SNAKE_CASE }
    zig: { variables: snake_case, types: PascalCase, constants: UPPER_SNAKE_CASE }

## モジュール設計:
  core_rules:
    - ファイル名 = 主要機能名
    - 1ファイル1公開機能（単一責任性）
    - 内部機能は言語の慣習で隠蔽（_, internal, pubなし等）
    - 純粋関数を優先（同じ入力→同じ出力）
    - 高階関数で柔軟性を実現
  
  single_responsibility:
    - 1関数1目的: 「かつ」でつながる説明は分割
    - 変更理由は1つ: ビジネスロジックとI/Oを混在させない
    - 抽象度を統一: 詳細と概要を同じ関数に書かない
  
  flexibility:
    - 戦略パターン: 振る舞いを関数として注入
    - 部分適用: 設定済み関数を返す高階関数
    - 合成: 小さな関数から大きな機能を構築
  
  control_flow:
    - パターンマッチ優先（switch/match）
    - 共用体型の判別にはtypeフィールド使用
    - 複雑なif-elseチェーンは避ける
  
  structure: |
    telemetry/
    ├── captureStream.{ts,py,go,rs,zig}  # capture_stream/CaptureStream関数のみ公開
    ├── queryLogs.{ts,py,go,rs,zig}      # query_logs/QueryLogs関数のみ公開
    └── formatLog.{ts,py,go,rs,zig}      # format_log/FormatLog関数のみ公開

## エラー処理:
  principle: エラーを戻り値として扱う（例外を投げない）
  
  rules:
    - エラーメッセージは完全保持（省略禁止）
    - メッセージ加工はプレフィックス追加のみ
    - エラーハンドリングは呼び出し側の責務
  
  patterns:
    typescript: |
      type Result = { data: T } | { error: string }
    python: |
      Union[SuccessType, ErrorType]  # 共用体型
    go: |
      (result, error)  # 多値返却
    rust: |
      Result<T, E>  # 標準のResult型
    zig: |
      !T  # エラーユニオン

## データ構造:
  principles:
    - 不変性を優先（const, frozen, immutable）
    - 型で意図を表現
    - 振る舞いを持たないデータ構造
    - 型定義は各層のtypes.{ext}に集約
  
  allowed:
    - TypeScript: type優先（interface は外部向けのみ）
    - Python: TypedDict, dataclass（frozen=True）
    - Go: struct
    - Rust: struct, enum
    - Zig: struct, enum

## 計算の文脈（世界）:
  concept: |
    各関数は「どの世界で動作するか」を型で明示する
    
  worlds:
    - 純粋な世界: 副作用なし、同じ入力→同じ出力
    - 失敗する世界: エラーを含む戻り値
    - 非同期の世界: Promise/Future/async
    - 状態を持つ世界: 明示的な状態の受け渡し
    - 外部接続の世界: DB/API等の境界
    
  composition: |
    同じ世界の関数は自由に合成可能
    異なる世界を跨ぐときは明示的な変換

## 依存性管理:
  - 依存は関数の引数として注入
  - グローバル状態を避ける
  - 設定は明示的に渡す
  - デフォルト引数・デフォルト値は禁止
  - 設定は infrastructure/config に集約
  
  example_pattern: |
    # 高階関数パターン（全言語適用可能）
    createFunction(dependency) -> function
    
## 層構造（DDD）:
  layers:
    domain: ビジネスルール（何をするか）
    application: ユースケース（どう組み合わせるか）
    infrastructure: 技術詳細（どう実現するか）
  
  dependency_direction: infrastructure → application → domain

## 禁止事項:
  global:
    - 例外の投げ上げ（panic, throw, raise）
    - グローバル変数の書き換え
    - 暗黙的な型変換
    - TODO/FIXME（未実装コード）
    - ダミー実装・モック実装・フォールバック
    - 「仮実装」「後で実装」等のプレースホルダー
  
  language_specific:
    - TypeScript: any型、@ts-ignore
    - Python: type: ignore、スター付きimport
    - Go: panic（main関数除く）、init関数での複雑な処理
    - Rust: unwrap（本番コード）、unsafe（必要最小限）
    - Zig: unreachable（デバッグ以外）

## ドキュメント:
  required:
    - 公開関数: 概要、使用例、引数、戻り値
    - 複雑なロジック: 意図の説明
    - 使用例は実行可能なコード必須
  
  format:
    - TypeScript/JavaScript: JSDoc
    - Python: docstring（"""で囲む）
    - Go: ゴーコメント
    - Rust: ///ドキュメントコメント
    - Zig: ///ドキュメントコメント

## 関数の合成とパイプライン:
  principles:
    - 小さな関数を組み合わせて大きな機能を作る
    - 各段階でエラーチェック可能
    - データフローが明確
  
  pattern: |
    input → validate → transform → enrich → output
    各段階で失敗する可能性を型で表現

## テスト指針:
  requirements:
    - すべての公開関数にテスト必須
    - in-sourceテスト許可（if __name__ == "__main__"等）
  
  testability:
    - 純粋関数: 入出力のみテスト
    - 副作用: 境界でのみ最小限のスタブ使用可
    - エラー: 全ての失敗ケースを網羅
  
  principles:
    - 実装 > インメモリ実装 > スタブ（モック禁止）
    - 依存性注入でテスト容易性確保
    - プロパティベーステスト推奨
    - 本番コードにテスト用分岐禁止