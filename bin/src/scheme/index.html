<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>CSSズームによるネスト構造</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        .node {
            border: 1px solid #666; 
            margin: 5px; 
            padding: 10px; 
            background-color: #f4f4f4; 
            transition: all 0.3s ease;
            transform-origin: center center;
        }

        /* ズーム時の基本スタイル */

        /* 子要素の初期状態 */
        .node > .node {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* ズーム時に子要素を表示 */
    </style>
</head>
<body>
    <div id="graph-container"></div>

    <script>
        // ノードとエッジのデータ
        const nodes = [
            { id: 'root', name: 'ルート' },
            { id: 'child1', name: '子1' },
            { id: 'child2', name: '子2' },
            { id: 'grandchild1', name: '孫1' },
            { id: 'grandchild2', name: '孫2' },
            { id: 'grandchild3', name: '孫3' },
            { id: 'great-grandchild1', name: 'ひ孫1-1' },
            { id: 'great-grandchild2', name: '新しい子2-1' }
        ];

        const edges = [
            { from: 'root', to: 'child1' },
            { from: 'root', to: 'child2' },
            { from: 'child1', to: 'grandchild1' },
            { from: 'child1', to: 'grandchild2' },
            { from: 'child2', to: 'grandchild3' },
            { from: 'grandchild1', to: 'great-grandchild1' },
            { from: 'child2', to: 'great-grandchild2' }
        ];

        // ノードとエッジからネスト構造を生成
        function createNestedStructure(nodes, edges) {
            const nodeMap = new Map(nodes.map(node => [node.id, { ...node, children: [] }]));

            edges.forEach(edge => {
                const parentNode = nodeMap.get(edge.from);
                const childNode = nodeMap.get(edge.to);
                
                if (parentNode && childNode) {
                    parentNode.children.push(childNode);
                }
            });

            return nodeMap.get('root');
        }

        // 再帰的にノードを描画する関数
        function renderNode(node, depth = 0) {
            const nodeElement = document.createElement('div');
            nodeElement.classList.add('node');
            nodeElement.textContent = node.name;
            nodeElement.dataset.depth = depth;

            // 子要素があれば追加
            if (node.children && node.children.length > 0) {
                node.children.forEach(childNode => {
                    const childElement = renderNode(childNode, depth + 1);
                    nodeElement.appendChild(childElement);
                });
            }

            return nodeElement;
        }

        // グラフの描画
        const graphContainer = document.getElementById('graph-container');
        const nestedStructure = createNestedStructure(nodes, edges);
        const rootNode = renderNode(nestedStructure);
        graphContainer.appendChild(rootNode);
    </script>
    <script>
        const container = document.getElementById('graph-container');
        let scale = 1;
        const minScale = 1;
        const maxScale = 3;
        const revealThreshold = 1.5;

        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            const delta = -event.deltaY * 0.001; // Adjust sensitivity
            scale += delta;
            scale = Math.min(maxScale, Math.max(minScale, scale));
            container.style.transform = `scale(${scale})`;

            const allNodes = container.querySelectorAll('.node');
            allNodes.forEach(node => {
                const depth = parseInt(node.dataset.depth || '0');

                if(depth === 0){
                    node.style.maxHeight = '1000px';
                    node.style.opacity = '1';
                    return;
                }

                const threshold = 1.2 + depth * 0.2;
                if (scale >= threshold) {
                    node.style.maxHeight = '1000px';
                    node.style.opacity = '1';
                } else {
                    node.style.maxHeight = '0';
                    node.style.opacity = '0';
                }
            });
        }, { passive: false });
    </script>
</body>
</html>