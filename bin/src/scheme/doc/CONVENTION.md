# コーディング規約と開発ルール

## 開発の基本原則

### 1. 既存ファイルの確認
- 新しいファイルを作成する前に、同名または同様の機能を持つファイルが既に存在するか確認すること
- 既存ファイルを上書きする場合は必ずバックアップを取ること

### 2. コードレビューと改善提案
- 既存のファイルやコードに不足箇所や改善点がある場合は、ユーザーに改善を提案すること
- 提案は具体的な改善方法と、その理由を明示すること

### 3. リファクタリングのルール
- リファクタリングを行う際は、機能を変更せず、コードの品質と可読性の向上に集中すること
- 大規模な変更の前にはユーザーの承認を得ること

## コーディング規約

### 1. ディレクトリ構造
- クリーンアーキテクチャの原則に従い、以下の層に分けること
  - `interface`: UIとユーザー入力の処理
  - `application`: ユースケースとアプリケーションサービス
  - `domain`: ドメインモデルとビジネスルール
  - `infrastructure`: 外部システムとの連携

### 2. ファイル命名規則
- TypeScriptファイルにはキャメルケースを使用すること（例: `metaSchemaRepository.ts`）
- クラス名やインターフェース名にはパスカルケースを使用すること（例: `MetaSchemaRepository`）
- メタスキーマファイルは `.meta.json` で終わること
- 設定ファイルは `.config.json` で終わること
- 生成されたスキーマは `.schema.json` で終わること

### 3. コメント
- 関数、クラス、インターフェースには必ずJSDocスタイルのコメントを付けること
- 特に複雑なロジックには説明的なコメントを追加すること

### 4. エラー処理
- エラーは適切に捕捉し、意味のあるエラーメッセージを提供すること
- ユーザーが対処できるエラーは明確な指示を含めること

### 5. 関数型プログラミングアプローチ

#### 5.1 クラス使用の制限
- 状態保存をしない場合は可能な限りクラスを使用せず、純粋な関数として実装すること
- 必要な状態がある場合のみクラスを使用し、責務を明確にすること
- 関数型プログラミングのアプローチを優先し、副作用を最小限に抑えること
- 新しいクラスの作成は必要最小限にとどめ、既存のクラスは可能な限り関数に変換すること

#### 5.2 関数型プログラミングの原則
- 純粋関数（副作用のない関数）を優先的に使用
- 状態の変更よりも新しい値を返す関数を使用
- 不変性（immutability）を重視
- 関数合成を活用して複雑な処理を構築

#### 5.3 関数と変数の命名規則
- 関数名は動詞または動詞+名詞の形式を使用（例: `createNode`, `parseSchema`）
- 略語を避け、完全な単語を使用
- キャメルケース（camelCase）を使用
- 変数名は意味のある名前を使用し、短すぎる変数名（例: `a`, `x`）を避ける

### 6. 型システムの活用

#### 6.1 型チェック
- すべてのファイルは `--check` フラグを使用して厳格な型チェックを行う
- **`--no-check` フラグの使用は禁止**
- 型エラーは無視せず、必ず修正する
- 型定義が不明確な場合は、明示的な型アノテーションを追加する
- 型チェックを回避するための `any` 型の使用は最小限に抑える
- 型の安全性を確保するために、必要に応じて型ガードやアサーションを使用する

#### 6.2 型定義の使用方針
- interfaceよりもtype aliasを優先的に使用
- 型の合成と再利用を促進
- 型レベルプログラミングの活用
- 複雑な型定義には説明コメントを付ける
- 型の制約や意図を文書化

## テスト方針

### 1. In-Source テスト
- 単体テストはテストファイルを作成せず、実装ファイル内に直接記述する
- すべてのファイルは、そのファイル自身をテストする機能を含むべき
- ファイル実行時にテストが自動的に実行されるよう設定する
- テストコードはファイル末尾に配置し、明確なコメントで区切る
- `import.meta.main`を使用して直接実行された場合のみテストを実行する
- 特別なテストモードフラグやオプションを使用せず、単純な実行でテスト可能にする

### 2. テスト独立性
- 単体テストは別ファイルでのテストや外部ファイルに依存したテストは禁止
- 各モジュールは自己完結したテストを含める
- 外部依存を必要とする場合はモックを使用

### 3. テスト実行方法
- In-Source テストの実行コマンド例:
  ```
  deno run --allow-read --allow-write path/to/file.ts
  ```
- または以下のshebangを使用したファイルの場合:
  ```
  ./path/to/file.ts
  ```

### 4. テスト追加のルール
- 新規作成またはバグ修正時には、最低1つの正常系テストケースを追加すること
- 一つのテストは一つの機能の正常系動作を確認するものとする
- 複雑なエッジケースや大量のテストケースを含むテストスクリプトの作成は避ける
- 簡潔で理解しやすいテストケースを心がける
- テストケースは明確に定義され、期待される結果を明示
- 境界条件やエッジケースを含める
- 失敗ケースもテストする

### 5. E2Eテスト規約
- E2Eテストは単体テストと明確に分離し、専用の`/test`ディレクトリに配置
- E2Eテストファイル名はキャメルケース（例: `functionGraph.ts`, `schemaValidator.ts`）
- E2Eテストはプロジェクトルートから`deno run --allow-read --allow-write test/[テストファイル名].ts`で実行
- スクリプト内にはシバンを含める
- E2Eテストファイルは、プロジェクト内の複数モジュールを組み合わせたテストを目的とする
- 各ファイルは実行可能な独立したスクリプトとして機能する
- 単体テストとは異なり、外部ファイル（例：Function.meta.json）に依存してもよい
- テスト結果は標準出力に表示し、必要に応じてレポートファイルを生成
- 生成されたファイルは`.gitignore`に追加するか、一時ディレクトリに出力

## ドキュメント規約

### 1. 関数ドキュメント
- 各関数の目的と動作を説明
- パラメータと戻り値を文書化
- 例外やエッジケースについて記述

### 2. モジュールドキュメント
- ファイルの先頭にモジュールの説明を含める
- モジュールの役割と責任を明記
- 他のモジュールとの関係を説明

### 3. 型ドキュメント
- 複雑な型定義には説明を付ける
- 型の制約や意図を文書化

## 実行環境

- スクリプトファイルは用途に応じて適切なshebangを使用する:
  - 標準的なCLIスクリプト:
    ```
    #!/usr/bin/env -S nix shell nixpkgs#deno --command deno run --allow-read --allow-write --allow-run --check
    ```
  - Web APIサーバースクリプト:
    ```
    #!/usr/bin/env -S nix shell nixpkgs#deno --command deno run --allow-net --allow-read --check
    ```
- 実行権限が必要な場合は、開発者に明示的に申し出ること
- `--check`フラグは常に含めること（型チェックの重要性）

## 特定のファイル・ディレクトリの取り扱い

### データディレクトリ
- `./data/config/` および `./data/meta/` の変更は慎重に行うこと
- これらのディレクトリのファイルを変更する場合は、事前にユーザーの許可を得ること
- 変更を行う場合は元の状態を復元できるようにしておくこと

### ドキュメントディレクトリ
- `./doc/` 内のドキュメントは常に最新の状態に保つこと
- コード変更によってドキュメントが古くなった場合は、ドキュメントも合わせて更新すること
