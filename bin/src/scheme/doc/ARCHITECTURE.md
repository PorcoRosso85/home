# schemeプロジェクト アーキテクチャ設計書

## 概要

schemeプロジェクトは、JSONスキーマベースの型定義生成システムを提供します。本ドキュメントでは、プロジェクトのアーキテクチャ設計について説明します。

## レイヤードアーキテクチャ

プロジェクトは以下の4つのレイヤーで構成されています：

```
+------------------+
| インターフェース層 |
+------------------+
         |
         v
+------------------+
|  アプリケーション層 |
+------------------+
         |
         v
+------------------+
|    ドメイン層     |
+------------------+
         |
         v
+------------------+
|インフラストラクチャ層|
+------------------+
```

### 1. インターフェース層 (`src/interface/`)

ユーザーとシステムの境界を担当するレイヤーです。

**役割:**
- ユーザー入力の受付と検証
- 出力フォーマットの整形
- 他のレイヤーと連携してユーザーリクエストを処理

**主要コンポーネント:**
- `cli.ts`: CLIの入力解析と基本処理
- `cliController.ts`: コマンド振り分けと制御
- `requirements-generator.ts`: 要件生成インターフェース
- `generate-types-from-requirements.ts`: 要件からの型生成インターフェース

### 2. アプリケーション層 (`src/application/`)

アプリケーションのユースケースを実装するレイヤーです。

**役割:**
- ユースケースの実装
- ドメイン層のサービスを調整して業務フローを実現
- インターフェース層とドメイン層の橋渡し

**主要コンポーネント:**
- コマンドクラス群 (`xxxCommand.ts`): コマンドパターンの実装
- ユースケースクラス群 (`xxxUsecase.ts`): 特定のユースケースの実装
- `metaSchemaRegistryService.ts`: メタスキーマの登録・管理サービス

### 3. ドメイン層 (`src/domain/`)

業務ロジックとドメインモデルを定義するレイヤーです。

**役割:**
- ビジネスロジックの実装
- ドメインモデルの定義
- ビジネスルールの適用

**主要コンポーネント:**
- `schema.ts`: スキーマのインターフェース
- `metaSchema.ts`: メタスキーマのインターフェース
- `generationService.ts`: スキーマ生成サービス
- `validationService.ts`: バリデーションサービス
- `service/typeDependencyAnalyzer.ts`: 型依存関係解析

### 4. インフラストラクチャ層 (`src/infrastructure/`)

外部システムとの連携を担当するレイヤーです。

**役割:**
- 永続化処理
- 外部APIとの連携
- ファイルシステムやデータベースとの通信

**主要コンポーネント:**
- `fileMetaSchemaRepository.ts`: ファイルベースのメタスキーマリポジトリ
- `fileSystemReader.ts`: ファイルシステム読み込み
- `fileSystemWriter.ts`: ファイル書き込み

## 依存関係の方向

レイヤー間の依存関係は、上位レイヤーから下位レイヤーへの方向のみ許可されています。

```
インターフェース層 → アプリケーション層 → ドメイン層 → インフラストラクチャ層
```

下位レイヤーは上位レイヤーを直接参照することはできません。必要な場合は、インターフェースを介して依存性を逆転させます。

## ディレクトリ構造

```
/home/nixos/scheme/
├── data/                         # データファイル格納ディレクトリ
├── src/                          # ソースコード
│   ├── interface/                # インターフェース層
│   ├── application/              # アプリケーション層
│   │   ├── xxxCommand.ts         # コマンドクラス
│   │   └── xxxUsecase.ts         # ユースケースクラス
│   ├── domain/                   # ドメイン層
│   │   └── service/              # ドメインサービス
│   ├── infrastructure/           # インフラストラクチャ層
│   └── service/                  # その他のサービス（ユーティリティ）
├── demo/                         # デモ・サンプル
├── doc/                          # ドキュメント
└── archive/                      # アーカイブ済み古いファイル
```

## パターンと設計原則

### コマンドパターン

アプリケーション層では、コマンドパターンを採用しています。各コマンドは `Command` インターフェースを実装し、`execute` メソッドを提供します。

```typescript
interface Command {
  execute(args: any): Promise<void>;
}
```

### ユースケースパターン

特定のビジネスケースを実装するクラスは、`xxxUsecase.ts` という命名規則に従います。これらは単一責任の原則に基づいて、特定のユースケースロジックをカプセル化します。

### リポジトリパターン

データアクセスには、リポジトリパターンを採用しています。例えば、`MetaSchemaRepository` インターフェースを `FileMetaSchemaRepository` クラスが実装しています。

### 依存性注入

コンポーネント間の結合を疎にするため、依存性注入（DI）を採用しています。例えば、`CliController` はコンストラクタで依存するサービスを受け取ります。

## 命名規則

### ファイル命名規則

- **インターフェース層**: ハイフン区切りの名前（例: `requirements-generator.ts`）
- **アプリケーション層**:
  - コマンドクラス: キャメルケースの名前 + `Command` サフィックス（例: `generateCommand.ts`）
  - ユースケースクラス: キャメルケースの名前 + `Usecase` サフィックス（例: `requirementsDepsUsecase.ts`）
- **ドメイン層**: キャメルケースの名前（例: `generationService.ts`）
- **インフラストラクチャ層**: キャメルケースの名前（例: `fileSystemReader.ts`）

### クラス命名規則

- **インターフェース**: プレフィックスなし（例: `Command`, `ValidationResult`）
- **実装クラス**: インターフェース名 + `Impl` サフィックス（例: `ValidationServiceImpl`）
- **コマンドクラス**: 名前 + `Command` サフィックス（例: `GenerateCommand`）
- **サービスクラス**: 名前 + `Service` サフィックス（例: `GenerationService`）
- **ユースケースクラス**: 名前 + `Usecase` サフィックス（例: `RequirementsDepsUsecase`）

## 拡張性

アーキテクチャは、以下の点で拡張性を考慮して設計されています：

1. **新しいメタスキーマタイプ**: 新しいメタスキーマを追加する際は、対応するハンドラーを実装するだけで対応可能
2. **新しい出力形式**: 新しい出力形式（例: GraphQL、ProtoBuf）を追加する場合は、GenerationServiceに新しい生成ロジックを追加
3. **新しいストレージメカニズム**: ファイルシステム以外のストレージ（例: データベース）を使用する場合は、新しいリポジトリ実装を追加

## コマンドフロー

コマンドが実行される際のフローは以下の通りです：

1. ユーザーが `cliController.ts` を実行
2. `CliController` が引数を解析し、適切なコマンドを選択
3. コマンドの `execute` メソッドが実行され、ユースケースを呼び出す
4. ユースケースがドメインサービスを利用して業務ロジックを実行
5. 必要に応じてインフラストラクチャ層を通じてデータの読み書きを行う
6. 結果がユーザーに返される

## まとめ

schemeプロジェクトは、レイヤードアーキテクチャとオブジェクト指向設計原則に基づいて設計されています。この設計により、保守性、拡張性、テスト容易性が向上し、将来の機能追加や変更に対して柔軟に対応できるようになっています。
