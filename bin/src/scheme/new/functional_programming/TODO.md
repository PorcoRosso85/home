# Function__Meta.json 改善計画, タスク

このドキュメントは、Function__Meta.jsonスキーマの将来的な改善案をまとめたものです。

## GraphBuilder関連の改善と依存関係解析の最適化 ✅

- graphBuilder.tsのcollectReferencesRecursive関数の問題は解決されたが、依然として依存関係解析に課題が残る
- 単純なケースでは正しく動作するが、より複雑なケースで問題が発生する
- グラフ構造によるネストされた参照の適切な検出とエッジ構築の向上が必要
- buildDependencyTree関数の修正と拡張が必要

### グラフ構造実装時に発見された課題と改善点

実装過程で発見された課題と、将来検討すべき機能拡張を以下に記録します。

#### 未解決の課題

1. 実際のスキーマからの依存関係解析が正しく機能していない
   - 進捗: `graphBuilder.ts`の`collectReferencesRecursive`関数の改善により一部解決
   - 残課題: `buildDependencyTree`関数は依然として依存関係を正しく構築できていない
2. テスト用スキーマを用いた解析でも$refの依存関係が検出されない
   - 進捗: 単純なテストケースでは適切にノードとエッジの作成ができるように改善
   - 残課題: 複雑なスキーマでの完全な依存関係解析は引き続き課題
3. グラフ表示機能にフィルタリングオプションがない
4. 循環依存の視覚的区別が不十分

#### 新たに見つかった課題

1. 依存関係解析機能とグラフ出力機能の統合が不完全
   - 進捗: 基本的な統合は完了、グラフビルダーとシリアライザーが機能
   - 残課題: 依存関係解析からグラフへの変換処理の最適化
2. TypeDependency型の再利用に関する問題
   - 進捗: in-sourceテストを追加して問題箇所を特定
   - 残課題: buildDependencyTree関数の修正が必要
3. ノードの重複が解消されていない（UtilityFunctionが2回表示される）
   - 進捗: 問題が特定され、テストケースで検証済み
   - 残課題: 重複ノードの検出と統合メカニズムの実装
4. 大規模グラフの場合のパフォーマンス最適化が必要

## フロントエンドPoC ✅

- 左にディレクトリツリー採用し、ツリーの右側に各ツリーアイテム同士のエッジ情報を表示する ✅
- ディレクトリツリーはFunction__Meta.jsonで定義する関数のアドレス `file/to/path.xxx:::func_name` で表現 ✅
- ./src配下にすでにこの処理が存在する ✅
- ただ./src配下の解析処理が古い, ./new配下のドメインエンティティに従って（ない場合は新しいドメインエンティティを生成して）の、解析が必要 ✅
- 既存ドメインエンティティもしくは新規生成するべきドメインエンティティの確定 ✅
- それに依存するサービス・インフラと、アプリの再設計を行う、当然./srcの既存処理を持ってくることも可能 ✅

完了内容 (2025/04/01):
- フロントエンドPoCを関数型アプローチで実装
- TypeScriptでインターフェース層を整備
- HTML+JSでのUIコンポーネント実装
- インタラクティブな依存関係表示機能の実装
- ディレクトリ構造の整理（インターフェース層への移行）
- 実行時ディレクトリに依存しない絶対パス解決機能の実装

## Function__Meta.jsonがファイルパスを格納できるか確認 ✅

- これをメタスキーマとする各関数型スキーマjsonファイルが、その関数を実装格納するアドレス情報を保持できるか確認する

## 更新されたFunction__Meta.jsonに従って実実装関数型スキーマ生成処理を作成・更新 ✅

- ./new配下には未実装
- ./src配下に旧Function__Meta.jsonに従う生成処理は存在
- 転用と新規のどちらがいいか検討
- ./README.md, ./doc/CONVENTION.md, ./new/test/README.mdに従った実装を徹底する
	- 調査段階でこれに従っていない箇所には FIXME を記述する

## resourceUriプロパティをデフォルトで含めるようフラグ修正する ✅

- 現状では--resource-uriオプション指定時のみ生成されるが、スキーマとしては常に含める必要がある
- 実装コードとテストコードでは想定されているが、デフォルト生成時には含まれないため統一する
- defaultConfig内にデフォルトのresourceUri値を設定し、常に含まれるようにする

## ファイル命名規則の改善 ✅

- Function__Meta.json -> Function__Meta.json
- Xxx.Function.schema.json -> Xxx__Function.json

## スキーマ参照とURIの標準化 ✅

* draft 2020-12未適用かどうか確認し、未適用なら修正
* $schema, $ref, resourceUriの命名規則統一
* 以下とも整合性取りつつ整理
  - ディレクトリツリーはFunction__Meta
.jsonで定義する関数のアドレス `file/to/path.xxx:::func_name` で表現

## cli.tsリファクタリング ✅

- 実装完了内容:
  - ルートのcli.tsを削除
  - interface/cli.tsをメインエントリポイントとして再構成
  - interface/cli/ディレクトリを作成し、コマンドごとのファイルを配置
  - 動的コマンドロード機能を実装し、コマンドファイル追加だけで機能拡張可能に
  - 各コマンドがヘルプ情報を自己保持し、統合表示可能に

## 冗長ファイルの削除と整理 ✅

- リファクタリングによって不要となったファイルの削除
  - `interface/depsCommand.ts` - 機能が新しいcli/deps.tsに移行済み
  - `interface/ValidateSchemaCommand.ts` - 機能が新しいcli/validate.tsに移行済み
  - `interface/types.ts` - 必要な型定義が各モジュールに移行済み
  - `interface/handler.ts` - APIハンドラーとの重複機能の整理

- 実装ステップ:
  1. 各ファイルが他モジュールから参照されていないことを確認
  2. ファイル内の重要な機能が新構造に移行済みか検証
  3. 影響範囲を評価し、安全に削除可能か判断
  4. ファイルを削除し、必要なインポート文も修正

## ./interfacesディレクトリの意義確認と削除可能性 ✅

## ./ディレクトリ配下のブラウザ動作可能性と依存分離 ✅

- 現在denoによるサーバー動作にて開発中
- ファイル依存を分離しブラウザでの動作を検討中
- 分離箇所特定、分離計画案
  - その場合は例えば./interface層はバンドルしないなど

## cozodb typescript sdkを使用した、生成されたスキーマの格納 ✅

- cozodbについて https://github.com/cozodb/cozo
- cozo scriptわかる？
- 生成されるXxx__Function.jsonは、cozodbのスキーマで管理しきれる？

## cozodbで以下の機能が可能か確認したい ✅

- Function__Meta.jsonが draft2020-12 を参照している$scheme依存関係
- Function__Meta.jsonから生成された一つのXxx__Function.jsonが、Function__Meta.jsonを参照している$schema依存関係

## cliのときとserverのときとbrowserの時の, interfaceを統一したい ✅

- 以下の場合のobject処理層はどこか明確にしたい、かつ、application/type.tsに定義したい
  - cli -> ファイル実行引数parser -> object
  - server -> json? -> object
  - browser -> json? -> object

## ファイル保存のときとdb(cozodb)のときの、infrastructureを統一したい ✅

- 以下の場合のobject処理層はどこか明確にしたい、かつ、domain/repository.tsに定義したい
  - object -> file(path, object) -> file
  - object -> cozo(query, object) -> cozodb

完了内容 (2025/04/04):
- ドメイン層にリポジトリインターフェース（repository.ts, schemaRepository.ts）を定義
- ファイルとデータベース両方の永続化に対応する統一インターフェースを実装
- トランザクション対応リポジトリとバッチリポジトリをインターフェースとして定義
- ファイルベースリポジトリをリファクタリング（schemaFileRepository.ts）
- データベースリポジトリを新規実装（schemaDbRepository.ts, dbClient.ts）
- 設定に基づいて適切なリポジトリを選択するファクトリを実装（repositoryFactory.ts）

## cliArgParser.tsを削除, 改善 ✅

- cli処理はserver処理も依存しているので, parse処理＝validation処理として統一する

完了内容 (2025/04/04):
- cli.tsの削除が確認され、復元対応を実施
- 既存のcli.tsをリポジトリインターフェース実装と同様に整備
- 型定義の不整合を解消（SchemaGeneratorConfigの拡張など）
- generateSchemaの挙動改善とエラーハンドリング強化
- CLIエラー処理とメッセージ表示の最適化

## スキーマ生成機能の差異調査と統一 ✅

- Function__Meta.jsonとFunction__Meta_NEW.jsonに発生している差分の原因調査
  - title, descriptionの違い: CLI呼び出し時の引数または設定値の違い
  - multipleReturnsセクションの欠落: enableFeaturesのmultipleReturns設定がcliAdapter.tsで不足
  - compositionセクションの一部欠落: enableFeaturesのcomposition設定の不足

- 差分解消のための対応事項:
  - (1) SchemaGeneratorConfigのenableFeaturesに不足している機能設定を追加
  - (2) defaultConfigの値を元のFunction__Meta.jsonに合わせる
  - (3) generateSchemaでの機能有効化フラグの判定処理を統一
  - (4) CLI、サーバー、ブラウザから共通の設定を使用できるようアダプター層を強化

## cliで操作したときにfile_ioするかdb_ioするかをどう選択する？ ✅

- cliに引数を渡してinfra層で条件分岐
- cliのinterface層にてinfra/ioを呼び出す/選択する

## 更新されたFunction__Meta.jsonに従って実実装関数型スキーマ生成処理を作成・更新, 再確認 ✅

完了内容 (2025/04/05):
- 生成器アダプターパターンを実装し、異なる型のスキーマ生成に対応
- 型レジストリとジェネレーターファクトリを実装
- 関数型スキーマジェネレーターを作成し既存実装と統合
- 新しいCLIコマンド（generate-new）を追加
- ドキュメント（HowToAddNewMeta.md, HowToAddNewType.md）を整備
- `--no-xxx`形式のフラグを廃止し、`--skip`フラグに統一

実装内容:
- `domain/generators/schemaGenerator.ts` - 共通インターフェース
- `domain/generators/typeRegistry.ts` - 型登録管理システム
- `domain/generators/generatorFactory.ts` - 型に応じた生成器を返すファクトリ
- `domain/generators/functionSchemaGenerator.ts` - 関数型生成器
- `application/schemaGenerationService.ts` - アプリケーション層の統合サービス
- `interface/cli/generateNew.ts` - 拡張可能なCLIコマンド

## frontendディレクトリ名をdistでも動作するよう変更 ✅

完了内容 (2025/04/05):
- サーバーハンドラーを改修して、フロントエンドファイルを配信する際に`frontend`と`dist`の両方に対応
- パス解決アルゴリズムを最適化し、存在するディレクトリを優先的に使用
- `/`（ルートパス）アクセス時にも`dist`と`frontend`のどちらが存在するかを自動判定
- ディレクトリ構造に依存しない拡張性の高い実装に変更
- ファイル存在確認のヘルパー関数を追加して処理を明確化

## server.ts, server/*.tsのリファクタリングとCONVENTION準拠 ✅

完了内容 (2025/04/05):
- CONVENTION.mdに従ったリファクタリングの実施
  - クラスベースの実装から関数型アプローチへの移行
  - 状態の明示的な管理と純粋関数の使用
  - インターフェースから型エイリアスへの変更
  - 副作用の隔離と関数の責務の明確化
- サーバーアダプターの再設計
  - `ApplicationAdapter`/`CommandExecutor`/`ApiHandler` 型の定義
  - 関数型合成によるアダプター実装
  - 状態の明示的な管理 (`ServerAdapterState` 型)
- エラーハンドリングの強化
  - エラーハンドリング関数の分離と再利用
  - 型安全なエラー処理
- パス解決ユーティリティ追加
  - 実行時ディレクトリに依存しない絶対パス解決機能の追加
  - ファイルパス操作の共通化
- コマンドロード機能改善
  - 関数型アプローチによるコマンド管理 (`CommandStore` 型)
  - より堅牢なパス解決ロジックの実装
  - ログ出力の強化とデバッグ情報の追加
- シバンの追加
  - CONVENTION.mdの要件に合わせた実行環境の設定
  - `--check` フラグを含めた型安全性の確保
- In-Source テストの実装
  - 単体テストをファイル内に直接記述
  - テストヘルパー関数の作成
  - モックリクエスト/レスポンスを使用した検証
- 透過的な後方互換性の維持
  - 既存のクラスインターフェースをラッパーとして保持
  - 関数ベースAPIへの移行支援

## cli.tsのブラウザ共通化検討 ✅

- cliでもブラウザでもおこなうことは同じ＝サーバーに対して機能を呼び出す
- 前者はファイルにある関数を呼び出し、後者はブラウザ内の関数を呼び出す
- ただ引数の渡し方や事前準備も異なるだろう
- 共通処理を明確にしcliからもfrontendからも使用できる処理を分離する
- cli.tsにcliにしかできないこと, browser.tsにブラウザにしかできないこと, client/*.tsに共通処理とする
- ヘルプなども共通処理になる
- cli.tsやbrowser.tsはおもに呼び出し副作用処理と出力・コンソール副作用処理のみのレイヤーが残る想定だが、客観的にレビューすること

## 関数型が依存するプリミティブ型や構造型などの情報 ✅

- 関数に直接の引数・戻り値各型を記述することもある＝別途型定義をしないケースがある
- その場合型は書ける？確認したい

## E2Eテスト

- UserAuth関数型を生成する
- これが依存する、別のUserRegister型を生成する、依存は直接呼び出し
- UserAuth関数型から依存関係を探索するコマンド実行し、直接呼び出ししていることが「理解できるかどうか」確認



## クライアントとサーバーのスキーマ設定

- サーバーではスキーマファイル生成という副作用処理以外に、クライアントへ以下を返却する
  - 生成したスキーマファイル同士がもつ依存関係
  - スキーマファイルがresourceUriとしてもつパスが、今変更されているのかどうかの情報プッシュ（SSE化を検討中、別TODO）
  -
- もしかしたら役割ごとにサーバーを分けてもいいかもしれない

  
## サーバーのSSE化と、サーバーがどうやってファイル変更情報を受け取るか

- 現在のサーバー実装の確認
- SSE化計画

## フロントエンド

## LLMにどんどんスキーマ作らせる

## ./TODO/BrowserPhase1.mdを参考に
## ./TODO/BrowserPhase2.mdを参考に

## 正規化ルールの確認

- 柔軟性を受け入れたくない、カバーしたくない
- file:///path/to/file.ts形式のURIに標準化
- 相対パス形式の禁止（または警告）
- スキーマ内の$refやresourceUriの正規化

### UI機能拡張
- ノード検索機能の追加（ファイル名、関数名でのフィルタリング）
- グラフビューモードの完全実装
- 依存関係の深さや種類によるフィルタリングオプション追加
- 循環依存の視覚強調表示

### 既存エクスポート機能をsrcと連携
- DOT、Mermaid、JSONなど複数形式でのエクスポート機能
- GraphVizとの連携
- 静的HTML生成のサポート

### インフラ整備
- テストコードの拡充
- 実行時ディレクトリに依存しない堅牢なパス解決の補強
- エラーハンドリングの強化
- CI/CD連携機能

## 並行エージェント処理がどのファイルを編集するかを可視化するPoCを検討する

- MCPクライアント/C0はClaude - MCPサーバー/S0が新たにMCPクライアント/[C1,C2,C3,,,] となるcliツールを呼び出す
- 各C1,C2,,はどのファイルを編集するかの計画を保持 - S0に返却 - C0が取得可能
- それと同じ情報を管理する管理WebサーバーがSSEでフロントエンドを更新

## 実装済みスキーマ生成処理の応用

- 本生成処理を、このスキーマをメタスキーマとする別スキーマ生成の際の基盤処理として活用する
  - 本来行われるべき以下の運用コストを省略・スキップすることを期待するためである
    - 本生成処理によりjson schemaを生成する
    - このスキーマXをメタスキーマとする別スキーマYの生成器yをXに依存させる形で実装する
    - スキーマXの改善・更新に伴い生成器yおよびすでに生成された別スキーマYのメンテナンスを行う
  - ただし以下は達成されなければならない
    - メタスキーマXを生成する機能は独立して存在する
    - 生成器yのメンテナンスを下げるため、アダプター可能な設計とする
      - ただし規約には従来通り従う

## 運用上一つのメタスキーマから大量に生成されたスキーマファイルの更新について

- 本生成器xから生成されるスキーマXをメタスキーマとするスキーマYが、Xに従っている証明を保持する
  - これにより、Xに従ったバリデーションの結果Yが機能するあるいは機能しないことをハンドリング可能とする

## 当スキーマが関数型のためのものであることをコンセプト確立する

- 現在機能や値に関する情報も含まれているため、このコンセプトがぶれている恐れがある
- プロパティ内で、以下の範囲かそうでないかの情報追加を行いたい
  - haskellに代表される関数型プログラミング言語
  - leanに代表される定理証明系言語
- 型情報であることと機能情報・設計情報であることを明記するしたい、その理由は以下の通り
  - 型情報を基盤とした機能実装を行っていくという設計方針を明確にするため
  - 機能情報・設計情報により型を生成するだけのケースに対応できないことを避けるため

## パフォーマンス特性

- 計算量の構造化された記述
  - 時間計算量（最良・平均・最悪ケース）
  - 空間計算量（メモリ使用量）
  - スケーラビリティの特性
- 最適化に関する情報
  - JITコンパイルへの適合性
  - インライン化の可能性
  - コード生成戦略

## 並行処理のサポート

- 「concurrency」セクションの追加
  - スレッドセーフ性の記述
  - ロック要件の明示
- 並行実行モデルの特性
  - アクター、STM、CSPなどのサポート
  - データ競合回避戦略
- 「async」セクションとの統合
  - 非同期と並行の組み合わせパターン

## 形式的検証

- 形式的な仕様や証明に関するメタデータ
  - 事前条件・事後条件
  - 不変条件
- 検証手法の情報
  - モデル検査の適用可能性
  - 定理証明のアプローチ
- 形式的意味論との連携
  - 操作的意味論の記述
  - 表示的意味論の記述

## セマンティクス定義の強化

- 評価意味論の明示的な指定
  - 呼び出し規約（call-by-value, call-by-nameなど）
  - 評価順序の保証
- リソース使用の詳細な記述
  - メモリ管理パターン
  - ファイルハンドルなどの外部リソース
  - リソース解放の保証

## 実装品質の指標

- コード品質メトリクス
  - コードカバレッジ
  - 静的解析結果
  - 複雑性指標
- セキュリティ情報
  - 入力検証要件
  - 信頼境界の定義
  - セキュアコーディングの適合性
- 保守性評価
  - 変更の影響範囲
  - リファクタリングの安全性

## 型エラー修正

以下の型エラーを修正し、プロジェクト全体の型の安全性を確保します：

1. `unknown` 型のエラーハンドリングの修正
   - `error`/`e` 変数に適切な型アサーションまたは型ガードを追加
   - 例: `if (error instanceof Error) { console.error(error.message); }`

2. 存在しないエクスポートの修正
   - `domain/schema.ts` からエクスポートされていない型の問題を解決
   - `RecursionFeature`, `AsyncFeature`, `PurityFeature` などを正しくエクスポート

3. インターフェースの不一致修正
   - `FileSystemReader` インターフェースに欠けているメソッドを追加
   - または、正しいインターフェースを使用するようコードを修正

4. Node.jsモジュールの正しいインポート
   - 相対パスを使わないNodeモジュールのインポートを修正
   - 例: `import * as path from "path";` → `import * as path from "node:path";`

## 設計情報のみでスキーマを使用するケースにスキーマを対応させる

- 実装情報まで必要のない項目の明確化
- 実装時には必ず必要な情報の明確化
- 分離
- 実装情報が必要かどうかのフラグ、falseの場合は不要であり、どんな機能が必要かの抽象的な情報連鎖依存に役立つ
  - DDDにおけるinterface層やusecase, application層の一部では、ビジネスロジックがなかったり既存関数を呼び出すだけのケースもあるため、有用である

- graphBuilder.tsのcollectReferencesRecursive関数の問題が解決されました
- buildDependencyTree関数も改善され、重複ノードの検出と統合機能が追加されました
- 循環依存の適切な検出と視覚的表現も実装されました

### グラフ構造実装時に発見された課題と改善点

以下の課題が解決されました：

#### 解決された課題

1. 実際のスキーマからの依存関係解析が正しく機能していない
   - 解決: `collectReferencesRecursiveImproved`関数の実装により、ネストされた参照を正確に検出できるようになりました
   - 改善: パス追跡機能を追加し、ノードの一意性を保持できるようになりました

2. テスト用スキーマを用いた解析でも$refの依存関係が検出されない
   - 解決: 改善されたアルゴリズムにより、複雑なスキーマでも依存関係を正しく検出できるようになりました
   - 拡充: テストケースを拡充し、基本、ネスト、循環参照、重複参照のパターンをカバーしました

3. 循環依存の視覚的区別が不十分
   - 解決: 循環参照を検出すると、ノードとエッジの両方に`isCircular`プロパティが設定されるようになりました
   - 改善: グラフ表示時に循環参照を視覚的に区別できるようになりました

4. ノードの重複が解消されていない
   - 解決: `processedNodes`セットを使用して、処理済みのノードを追跡し、重複を防止できるようになりました
   - 改善: 同一ノードへの複数の参照がある場合でも、ノードは一度だけ作成されるようになりました

#### 今後の課題

1. グラフ表示機能にフィルタリングオプションの追加
   - ノードタイプやエッジタイプによるフィルタリング
   - 特定のパターンに基づく検索機能

2. パフォーマンスの最適化
   - 大規模スキーマ処理時のメモリ使用量と実行速度の改善
   - 部分的なグラフ構築とオンデマンド展開機能

## 構造体メタスキーマ生成処理の追加

- HowToAddNewMeta.mdおよびHowToAddNewType.mdを参照して構造体型のメタスキーマジェネレーターを実装
- `domain/generators/structSchemaGenerator.ts`の実装
- 構造体特有のプロパティ（フィールド定義、イミュータビリティなど）を設計
- 構造体スキーマ生成のユニットテスト実装
- 関数型と構造体型の両方をサポートするアダプター層が正しく機能するか確認

## サーバーからDBファイルを提供する （フロントエンド完結を想定する場合）

- opfsへ格納
- フロントエンドはそれを読み取る


