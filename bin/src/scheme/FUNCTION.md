# 関数型の機能的依存関係の設計

## 1. 基本概念

### 関数型の定義
- 「関数型」とは `Function.meta.json` で定義される型、または静的型言語で定義可能な関数型を指す
- 現状では主に引数の型と返り値の型から構成されている

### 機能的依存の定義
- 「機能的依存」とは関数が実装する際に依存する他の機能要素のこと
- 関数は単純に引数と返り値だけでなく、以下のような要素に依存する：
  - 他の関数呼び出し
  - 条件分岐ロジック
  - エラーハンドリング
  - 副作用を伴う処理
  - 内部状態の管理

## 2. 現状の型依存関係と機能的依存の違い

### 現状の型依存関係
- 型がどのような他の型から構成されているかを表す
- たとえば `UserWithAuth` が `User` 型と `Auth` 型に依存しているといった情報
- これは型の「構造的な依存関係」を表現している

### 機能的依存関係
- 関数がどのような機能に依存しているかを表す
- 単なる型構成ではなく、実際の処理フローや機能間の呼び出し関係を表現
- たとえば「ユーザー認証関数」が「パスワード検証関数」や「トークン生成関数」を呼び出すといった関係

## 3. スキーマでの表現方法（検討事項）

### 現時点での案
- 既存の関数型メタスキーマ（`Function.meta.json`）はそのままに保持
- 機能的依存を表現するために新しいメタスキーマを用意
- 既存システムとの統合性を保ちながら、オプショナルな機能として実装

### 検討すべき設計ポイント
1. **依存関係の表現方法**
   - 関数間の呼び出し関係をどのように表現するか
   - 直接依存と間接依存の区別をどう表現するか
   - 依存関係の順序（実行順序）を明示的に表現する

2. **メタデータの設計**
   - 初期段階では依存関係の順序を重視（条件分岐などは将来の拡張として検討）
   - 順序付けられた依存関係リストとして表現

3. **スキーマ拡張の方法**
   - 別のメタスキーマとして定義し、既存システムとの統合性を保つ
   - モジュール性を重視し、既存機能を変更せずに追加機能として実装

## 4. 期待される効果とユースケース

### メリット
- 関数型のドキュメントから、その関数がどのような機能に依存しているかが明確になる
- 依存関係を再帰的に解析することで、処理のコールスタックのような全体像を把握できる
- コードを書く前の設計段階でも機能間の依存関係を定義・可視化できる

### 活用シナリオ
- システム設計時のアーキテクチャ可視化
- 機能変更時の影響範囲分析
- テスト計画の策定（依存する機能を考慮したテストケース設計）
- リファクタリング対象の特定と優先順位付け

## 5. 実装の検討事項

### 既存機能との統合
- 現状の `deps` コマンドとの統合方法
- 型依存関係と機能的依存関係の表示の使い分け

### 可視化方法
- 初期段階では、既存の `output-type-path` コマンドの出力を拡張し、右側に依存関係を表示
- 例：
```
path/to/X.js:::X.Function    +        +         +            +
path/to/x.js:::x1.Function         +
path/to/x.js:::x2.Function                    +
path/to/x.js:::x3.Function                                 +
```
- 将来的には有向グラフ（DAG）などでの可視化も検討

### 検証方法
- 機能的依存関係の定義が実際のコード実装と一致しているかの検証方法
- CI/CDパイプラインでの活用方法

## 6. 次のステップ

1. 機能的依存のメタスキーマ設計案の詳細化
   - 新しい `FunctionDependency.meta.json` の設計
   - 依存関係の順序表現の詳細設計

2. プロトタイプ実装の検討
   - `output-type-path` コマンドの拡張実装
   - 依存関係表示のフォーマット実装

3. テストケースの設計
   - 実際の関数依存関係を用いたテストシナリオ作成

4. ユーザーインターフェース（CLI）の拡張検討
   - 既存コマンドとの統合方法
   - 新しいオプションの追加
