---
# CONVENTION.yaml - コーディング規約完全版

common:
  基本原則:
    クラス使用: "可能ならクラスは使わない"
    ファイルとクラス: "ファイルをモジュール・一つのクラスとみなせる場合はそうする"
    状態変化保持: "仮に状態変化を保持したい場合、クラスの使用を検討してよいが、劣後とする"
    インポート方法: "絶対インポートではなく相対インポートとすること、理由は各ファイルの依存関係を明確にするため"
    ファイルと関数: "各ファイルに各関数一つを基本とする"
    テスト記述: "各関数の動作を確認するテストは必ず記述する"
    シンプルコード: "可能な限りシンプルで読みやすいコードを書く、複雑な実装は避け、必要に応じてコメントで説明する"
    定数命名規則: "定数名は大文字のスネークケース（SNAKE_CASE）を使用"
    命名原則: "分かりやすい名前を付け、略語は避ける"
    禁止命名: "過度に汎用的と判断されうる命名は禁止する　例：util, tool"
    コメント付け方: "複雑なロジックには簡潔なコメント（# で始まる行コメント）を付ける"
    ファイルヘッダー: "ファイルにはヘッダー（shebang, coding指定など）は不要"
    実行権限: "実行可能なスクリプトには実行権限を付与しない"
  
  テスト規約:
    in_source_test: "モジュールの機能をテストするためのテストコードは、そのモジュール内のファイル末尾に直接記述する"
    テストファイル権限: "テストを含むファイルには実行権限を付与しない"
    テストファイル作成: "in source testの概念に従うため、別途テストファイルの作成は禁止"
    テスト独立性: "単体テストは別ファイルでのテストや外部ファイルに依存したテストは禁止"
    テスト自己完結性: "各モジュールは自己完結したテストを含める"
    外部依存テスト: "外部依存を必要とする場合はモックを使用"
    テスト包含: "すべてのファイルは、そのファイル自身をテストする機能を含むべき"
    テスト自動実行: "ファイル実行時にテストが自動的に実行されるよう設定する"
    テストコード配置: "テストコードはファイル末尾に配置し、明確なコメントで区切る"
    テストモード: "特別なテストモードフラグやオプションを使用せず、単純な実行でテスト可能にする"
    テスト用環境変数: "テスト用の臨時環境変数ファイル（env.test.sh など）は作成しない"
    テスト依存関係: "テスト専用の依存関係を増やさないようにする"
    テスト方針: "本プロジェクトはin source testingの方針で統一する"
    ユニットテスト実行: "ファイル指定でユニットテストが実行できるようにする"
    テストの焦点: "テストは関数の入出力のみに焦点を当ててください"
    テストの分離: "モックやスタブを活用して依存関係を分離してください"
    テストの命名: "テストは目的を明確に示す命名を使用してください"
    ユニットテスト: "すべての関数にユニットテストを書いてください"
    テストの焦点2: "テストはユースケースの検証に焦点を当てる"
    テストの層: "各層ごとにテストを作成する"
    統合テスト: "インターフェース層では、CLIを通じた統合テストを行う"

  エラー処理:
    エラー検出: "エラーはできるだけ早く検出し、明確なエラーメッセージを表示する"
    無効入力処理: "無効な入力に対しては、メイン側で適切な値を設定する（デフォルト引数は使用しない）"
    バッチ処理エラー: "バッチ処理では個別のエラーがプロセス全体を停止しないよう、各項目ごとに適切な例外処理を行う"
    診断情報: "スタックトレースなどの詳細情報はデバッグに役立つよう適切にログ出力する"
    デフォルト引数: "関数定義でのデフォルト引数は使用しない"
    デフォルト処理: "関数内でのデフォルト処理（var = var if var else default_var）も使用しない"
    値の設定方法: "呼び出し側で明示的に値を設定して渡す"
    設定値参照方法: "環境変数などの設定値はモジュールごとインポートで参照する"
    環境変数未設定時: "環境変数が設定されていない場合はデフォルト値を使用する"
    エラー処理方法: "エラーは値として扱い、例外に依存しない"
    エラーハンドリング: "代わりに、明示的なエラー型とエラーハンドリング関数を使用してください"
    エラー処理原則: "エラーは適切に捕捉し、意味のあるエラーメッセージを提供する"
    低レベル例外変換: "低レベルの例外は上位層で適切に変換する"
    エラーメッセージ区別: "ユーザー向けのエラーメッセージとデバッグ用の詳細情報を区別する"
    エラーログ: "エラーは常にコンソールログに出力し、詳細情報を開発者向けに残します"
    エラーメッセージ処理: "エラーメッセージに関しては各ライブラリが出力するものをそのまま使用する"
    エラーメッセージ変更: "エラーメッセージ変更の場合はフォーマットのためのプレフィックス付記や構造化に必ずとどめること"
    エラーメッセージ改変: "根本的なエラーメッセージの内容は改変せず、診断情報を保持すること"
    フォールバック処理: "フォールバック処理は一切禁止であり、すべてエラーとして返すこと"
    戻り値表現: "関数の戻り値として成功/失敗を表現してください"
    エラー判別関数: "エラーかどうかの判別関数を定義する"

  アーキテクチャ:
    Parse_dont_validate: "データ検証ではなくデータパースを優先する"
    パースメリット: "バリデーションでエラーを出すのではなく、パースで適切な型に変換する"
    入力データ扱い: "入力データは常に「未検証の生データ」として扱い、ドメインオブジェクトへの変換を確実に行う"
    エラー時早期対応: "変換できない場合は早期に失敗し、不正な値が内部に伝播しないようにする"
    ドメイン層アプリケーション層: "domainとapplicationレイヤーは完全に外部影響から分離する"
    純粋関数使用: "これらの層では純粋関数のみを使用し、副作用を排除する"
    外部通信制限: "外部との通信やファイルI/O、データベースアクセスなどを排除する"
    状態変更表現: "状態変更は新しい値を返すことで表現する（不変性の原則）"
    ドメインモデル特性: "ドメインモデルは自己完結し、どの環境でも同じ結果を返す"
    外部境界処理: "interface/infrastructureレイヤーでのみ外部影響・副作用を扱う"
    外部データ変換: "外部データをドメインオブジェクトに変換する責務を負う"
    ドメインオブジェクト外部変換: "ドメインオブジェクトを外部形式に変換する責務を負う"
    例外処理エラーハンドリング: "すべての例外処理とエラーハンドリングを行う"
    入出力変換: "入出力のバリデーションではなく、パースによる変換を行う"
    ディレクトリ構造: "クリーンアーキテクチャの原則に従い、以下の層に分けること（interface, application, domain, infrastructure）"
    interfaceレイヤー責務: "UIとユーザー入力の処理、外部との境界層"
    applicationレイヤー責務: "ユースケースとアプリケーションサービス、純粋な関数で実装"
    domainレイヤー責務: "ドメインモデルとビジネスルール、副作用なしの純粋な関数で実装"
    infrastructureレイヤー責務: "外部システムとの連携、副作用を含む処理の実装"
    ドメインレイヤー実装: "純粋な関数による実装を徹底する"
    ドメインレイヤーロジック: "副作用を含まないビジネスロジックの設計"
    ドメインレイヤー依存関係: "外部依存を持たず、他のレイヤーからも影響を受けない"
    ドメインレイヤー内容: "型定義と純粋なビジネスロジックのみを含む"
    アプリケーションレイヤー実装: "ユースケースの実装を担当"
    アプリケーションレイヤーロジック組合せ: "ドメインロジックを組み合わせて機能を実現"
    アプリケーションレイヤー依存関係: "外部依存を直接持たず、型で表現された依存のみを許可"
    アプリケーションレイヤー関数スタイル: "副作用を含まない純粋関数スタイルを基本とする"
    インターフェースインフラレイヤー副作用: "外部影響・副作用を扱う唯一のレイヤー"
    インターフェースインフラレイヤー外部API通信: "外部APIとの通信処理"
    インターフェースインフラレイヤーDB: "データベースアクセス"
    インターフェースインフラレイヤーファイル操作: "ファイルシステム操作"
    インターフェースインフラレイヤー外部連携: "外部サービスとの連携"
    インターフェースインフラレイヤー型変換: "境界での厳格な型変換処理"
    パースパターン: "「Parse, don't validate」パターンを使用し、早期に安全な型に変換する"
    レイヤー間依存表現: "レイヤー間の依存は型で表現し、実装は依存注入で差し替え可能にする"
    ドメインアプリケーションレイヤー実装: "ドメインとアプリケーションレイヤーは副作用を含まず、純粋な関数で実装する"
    ファイル命名規則: "ファイル命名規則を厳守し、モジュールの役割を明確にする"
    エンティティプロパティ名: "エンティティのプロパティ名はCSVのカラム名と統一する"
    エンティティ操作方法: "関数でエンティティを操作し、クラスは使用しない"
    ファイル出力モード: "file モードの場合は、関数がデータを返すようにする（ファイル書き込みは別途行う）"
    モジュールインポート方法: "モジュール自体をインポートする方法を優先する"
    クラス使用制限: "class キーワードを使用したクラス定義は避けてください"
    オブジェクト指向設計: "オブジェクト指向設計の代わりに、関数とデータの明確な分離を行ってください"
    関数実装スタイル: "可能な限り純粋関数（同じ入力に対して常に同じ出力を返し、副作用のない関数）を使用してください"
    状態管理方法: "状態を持つオブジェクトの代わりに、関数のクロージャを活用してください"
    高階関数活用: "高階関数（関数を引数として受け取るか、関数を返す関数）を活用してください"
    不変性確保: "データの変更は避け、新しいデータ構造を返してください"
    リスト操作: "リスト操作には map、filter、reduce などの高階関数を使用してください"
    モジュール設計: "各モジュールは明確に定義された単一の責任を持つべきです"
    関数グループ化: "関連する関数をモジュールにグループ化してください"
    依存関係グラフ: "循環依存を避けるために、依存関係グラフを意識してください"
    インポートルール: "相対パスを使用してインポートを行う"
    循環依存: "循環依存を避ける"
    依存方向: "依存方向は常に外側から内側へ（インターフェース層 → アプリケーション層 → ドメイン層 → インフラストラクチャ層）"
    アーキテクチャパターン: "クリーンアーキテクチャの原則に基づいた3層アーキテクチャを採用しています"
    インフラストラクチャ層概要: "データベースやファイルシステムなどの外部リソースとの直接的なやり取りを担当します"
    インフラストラクチャ層場所: "/infrastructure"
    インフラストラクチャ層責務詳細: "CozoDBとの通信、クエリの実行、低レベルなデータアクセス、外部リソースとのインターフェース"
    ドメイン層概要: "ビジネスロジックとドメインモデルを含む、アプリケーションの中核部分です"
    ドメイン層場所: "/domain"
    ドメイン層責務詳細: "ビジネスロジックの実装、ドメインモデルの定義、ドメインサービスの提供、ビジネスルールの適用"
    アプリケーション層概要: "ドメイン層とインフラストラクチャ層を連携させ、ユースケースを実現します"
    アプリケーション層場所: "/application"
    アプリケーション層責務詳細: "ユースケースの実装、ドメインサービスの調整、入出力の変換、高レベルAPIの提供"
    インターフェース層概要: "ユーザーやシステムとのインターフェースを提供します"
    インターフェース層場所: "/interface"
    インターフェース層責務詳細: "CLI/GUI実装、APIエンドポイント、入力バリデーション、レスポンスフォーマット"
    
  プログラミングスタイル:
    コードスタイル: "クラスではなく関数ベースのプログラミングスタイルを採用する"
    状態処理: "状態を持つ処理が必要な場合も、関数とパラメータで実現する"
    基本原則: "関数型プログラミングの原則に可能な限り従います"
    関数型プログラミングメリット: "これにより、コードの予測可能性、テスト容易性、保守性が向上します"
  
  ドキュメント:
    ドキュメント文字列: "すべての関数に適切なドキュメント文字列を書いてください"
    パラメータ戻り値文書化: "パラメータの型と戻り値の型を文書化してください"
    複雑ロジック説明: "複雑なロジックには説明コメントを追加してください"
    ドキュメント更新: "README.mdやCONVENTION.mdなどのドキュメントを最新に保つ"
  
  ファイル操作:
    既存ファイル確認: "新しいファイルを作成する前に、同名または同様の機能を持つファイルが既に存在するか確認すること"
    既存ファイル上書き: "既存ファイルを上書きする場合は必ずバックアップを取ること"
  
  コードレビュー:
    コードレビュー改善提案: "既存のファイルやコードに不足箇所や改善点がある場合は、ユーザーに改善を提案すること"
    改善提案内容: "提案は具体的な改善方法と、その理由を明示すること"
    リファクタリングルール: "リファクタリングを行う際は、機能を変更せず、コードの品質と可読性の向上に集中すること"
    大規模変更承認: "大規模な変更の前にはユーザーの承認を得ること"
    
  レイヤー別テスト要件:
    テスト要件定義: "各レイヤーごとに最小構成時の必須テストを定義する"
    Infrastructure層テスト: "副作用対象との接続正常系単体テストを必須とする"
    Domain層テスト: "ロジックに限りテスト対象とし、その責務を説明する実例データをハードコードで用意して期待する出力をするかどうかの正常系単体テストを必須とする"
    Application層テスト: "ロジックに限りテスト対象とし、その責務を説明する実例データをハードコードで用意して期待する出力をするかどうかの正常系単体テストを必須とする"
    Interface層テスト: "副作用を含めたE2Eテストを必須とする"
    レイヤー分離テスト: "ドメイン層とアプリケーション層は外部依存なしでテスト可能であることを確認"
    境界テスト: "インターフェース層とインフラストラクチャ層のテストでは境界の変換処理に焦点を当てる"
    変換テスト: "ドメインオブジェクトと外部表現の変換が正しく行われることを確認"
    
  その他:
    タイムスタンプ形式: "すべてのタイムスタンプはISO 8601形式を使用する（例: 2023-01-01T00:00:00Z）"
    タイムスタンプ検証: "タイムスタンプの検証は必ず行う"
    タイムスタンプ未指定時: "タイムスタンプが指定されない場合は現在時刻を使用する"
    RFC_URIノードID: "ノードIDは特定のURI形式に準拠する必要があります"
    デフォルト設定禁止: "デフォルト設定は一切禁止"
    デフォルト引数禁止: "デフォルト引数も同様にデフォルト設定なので禁止"

python:
  命名規則:
    変数関数名: "変数名、関数名はスネークケース（snake_case）を使用"
    クラス名: "パスカルケース（例: ClassName）を使用"
  
  docstring:
    記述方法: "docstringは1〜2行の簡潔な説明・意義・役割のみを記述する"
    制限: "引数や返却値に関する情報はdocstringに記述禁止"
    モジュールdocstring: "モジュールdocstring（ファイル先頭のdocstring）は使用禁止"
  
  ドメイン定義:
    ドメインエンティティ: "ドメインエンティティはTypedDictを使用して定義する"
    型定義方法: "すべての型定義は TypedClass を使用してください"
    型定義集約: "各層の types.py ファイルに型定義を集約します"
  
  出力方法:
    標準出力: "出力方法は print と file の2種類のみをサポート"
    デフォルト出力: "デフォルトは print"
  
  例外処理:
    例外処理ブロック: "例外処理ブロック（try...except）は必要最小限に抑え、単一の例外クラス（Exception）を使用して伝播させる"
    例外使用制限: "try/except ブロックや例外の使用は避けてください"
    例外発生制限: "raise や Exception の派生クラスは使用しないでください"
  
  インポート:
    推奨インポート形式: "推奨形式: from infrastructure import variables と variables.VALUE"
    非推奨インポート形式: "個別の値をインポートする形式は使用しない: ~~from module import var~~"
    環境変数管理: "環境変数は infrastructure/variables.py で一元管理する"
  
  テスト:
    テストコード配置: "テストコードは if __name__ == \"__main__\": ブロック内ではなく、ファイル末尾に各テストランナー(pythonであればpytest)が読み取れるテスト関数として記述する"
    テスト実行方法: "テストは常に実際の env.sh / env.dev.sh を使用して main.py を通して実行する"
    テスト実行エントリポイント: "テストの実行エントリポイントはmain.pyのみとする（個別モジュールの直接実行は避ける）"
    テスト実行: "ファイル末尾にテスト関数を記述し、各テストランナー(pythonであればpytest)が読み取れるテスト関数として実装する"
  
  その他:
    返却型例: "成功と例外をユニオン使用して記載すること"
    型アノテーション: "型アノテーションはすべての個所に使用する、変数についても"
    function-framework: "function-frameworkを使用したテストをサポートする"
    型システム活用: "型システムを駆使して、コンパイル時に不正な状態を防ぐ"
    Result型使用: "Result型は使用せず、以下の2+1種類の列挙型/共用体型を使用してください"
    設定箇所: "設定箇所は以下のみを許可する：infrastructure/variables.py"

typescript:
  命名規則:
    変数関数名: "camelCase （例：initializeDatabase, createConnection）"
    クラス型インターフェース名: "PascalCase （例：DatabaseConfig, KuzuConnection）"
    ファイル名: "kebab-case.ts （例：database-service.ts）"
    コンポーネントファイル: "PascalCase.tsx （例：DataTable.tsx）"
    ファイル名規則TypeScript: "キャメルケース（例: repository.ts, service.ts）"
    ディレクトリ名: "キャメルケース（例: timeTravel）"
    変数名規則TypeScript: "キャメルケース（例: filePath, commitMessage）"
    関数名規則TypeScript: "キャメルケース（例: getFileVersions, compareVersions）"
    クラス名規則TypeScript: "パスカルケース（例: TimeTravelRepository）"
  
  型定義:
    type定義: "type定義のみを使用し、interfaceは使わない"
    モナド型: "Either型やResult型などの複雑なモナド型は使用を最小限にし、共用型（union type）でエラーを表現する"
    型安全性: "型安全性を常に最優先し、型エラーは確実に修正する"
    型システム活用: "型システムを駆使して、コンパイル時に不正な状態を防ぐ"
    型アノテーション言語固有: "可能な限り型アノテーションを使用してください"
  
  モジュール:
    モジュール管理: "ESモジュール（ESM）が前提：CommonJSではなくESMを使用したモジュール管理が必須"
    モジュール定義: "deno.jsonのimportsセクションに定義されたESMモジュールを使用"
    モジュールインポート方法: "npm:kuzu-wasmとして直接モジュールをインポート"
  
  UI開発:
    エラーレンダリング原則: "エラーに関するレンダリングは一切禁止します"
    エラー表示方法: "エラーによりレンダリングできなかった場合は、何も表示せず（nullを返し）、標準ポップアップのみで対応します"
    カスタムエラーUI: "カスタムエラーUI（エラーボックス、エラーメッセージ、警告アイコンなど）の作成は禁止します"
    エラー表示コンソール整合性: "UIからエラーが表示されないようにする一方で、コンソールには正確な情報を出力します"
    エラー時レンダリング: "エラー発生時はコンポーネントのレンダリングをスキップし、親コンポーネントの処理に任せます"
    エラー内容表示: "エラー内容はコンソールで確認し、UIには一切表示しません"
    RFC_URI不正時処理: "ノードのURIが正しいRFC形式でない場合はエラーとして扱い、レンダリングを行わないようにします"
  
  ブラウザ連携:
    ブラウザ連携: "index.htmlでTypeScriptモジュールを読み込む"
    ロジック配置: "すべてのロジックをTypeScriptモジュールに移動"
    アプリケーション初期化: "DOMContentLoadedイベントでアプリケーションを初期化"
  
  テスト:
    テスト実行条件: "import.meta.mainを使用して直接実行された場合のみテストを実行する"
  
  ドキュメント:
    関数クラスドキュメント: "関数やクラスには適切なJSDocコメントを付ける"

wasm_csv:
  プロジェクト目的: "Wasmバイナリを配信する、CSVファイルを配信する、ブラウザ側でWasmを使ってCSVデータを解析する"
  CSVファイル: "public/remote_data.csvファイルを活用"
  プロジェクト特有:
    許可される変更: "src ディレクトリ内のファイルの調整、index.html の修正、既存の build.ts を利用したViteサーバーの活用"
    禁止される変更: "サーバーサイドのDeno化は行わない"
    不要なファイル例: "重複するJavaScriptファイル（例：src/lib/kuzu-browser.js）"
