# コーディング規約 (CONVENTION)

## 基本原則:
  description: 関数型プログラミングの原則に可能な限り従い、コードの予測可能性、テスト容易性、保守性を向上させる
  
## 型定義:
  rules:
    - TypedDictを使用すること
    - 各層のtypes.pyファイルに型定義を集約すること
    - 可能な限り型アノテーションを使用すること
  examples:
    good: |
      from typing import TypedDict, List, Optional
      
      class FunctionData(TypedDict):
          title: str
          description: Optional[str]
          type: str
          pure: bool
          parameters: List["ParameterData"]

## エラー処理:
  rules:
    - 例外を投げる代わりに、定義したエラー型を返却すること
    - 関数の戻り値として成功/失敗を表現すること
    - Result型は使用せず、以下の2+1種類の列挙型/共用体型を使用すること:
      - 成功時の戻り値型
      - 例外時の戻り値型
      - (オプション)副作用型
    - 全言語共通で以下の形式を採用すること:
      - 成功時は元の型をそのまま返す
      - 失敗時は特定のエラー型を返す
      - 型の判定はプロパティの有無などで行う
      - TypeScriptでは: 成功型 | エラー型A | エラー型B | ...
      - Pythonでは: Union[成功型, エラー型A, エラー型B, ...]
      - 言語を問わず同様の共用体型パターンを使用する
  examples:
    good: |
      from typing import TypedDict, Union, Literal
      
      class FunctionData(TypedDict):
          title: str
          description: str
          parameters: List[str]
      
      class FunctionError(TypedDict):
          code: str
          message: str
      
      # 成功型とエラー型の共用体型として定義
      FunctionResult = Union[FunctionData, FunctionError]
      
      def add_function(data: dict) -> FunctionResult:
          if not validate_data(data):
              return {"code": "INVALID_DATA", "message": "Invalid data"}
          
          # 処理...
          
          return {
              "title": result_title,
              "description": result_description,
              "parameters": result_parameters
          }
      
      # エラーかどうかの判別関数
      def is_error(result: FunctionResult) -> bool:
          return "code" in result and "message" in result
    
    typescript: |
      // TypeScriptでの例
      interface FunctionData {
          title: string;
          description: string;
          parameters: string[];
      }
      
      interface FunctionError {
          code: string;
          message: string;
      }
      
      // 成功型とエラー型の共用体型として定義
      type FunctionResult = FunctionData | FunctionError;
      
      function addFunction(data: any): FunctionResult {
          if (!validateData(data)) {
              return { code: "INVALID_DATA", message: "Invalid data" };
          }
          
          // 処理...
          
          return {
              title: resultTitle,
              description: resultDescription,
              parameters: resultParameters
          };
      }
      
      // エラーかどうかの判別関数
      function isError(result: FunctionResult): result is FunctionError {
          return 'code' in result && 'message' in result;
      }

## エラーメッセージの責務:
  rules:
    - エラーハンドリング自体は呼び出し側(cli.py)で行う
    - エラーメッセージの内容はコマンド側の責務とする
    - 各コマンドはエラー型の定義とメッセージを含むTypedDictエラー型を定義すること
  examples:
    good: |
      # コマンドモジュール(initialize.py)内
      from typing import TypedDict, Literal
      
      class InitError(TypedDict):
          error_type: Literal["DB_PATH_ERROR", "VALIDATION_ERROR", "INIT_DATA_ERROR"]
          message: str
          details: dict
      
      # エラーメッセージのヘルプも提供
      def get_error_help(error_type: str) -> str:
          error_help = {
              "DB_PATH_ERROR": "データベースパスの指定に問題があります。有効なパスを指定してください。\n例: --init /path/to/db または --init true",
              "VALIDATION_ERROR": "SHACL検証エラーが発生しました。データモデルを確認してください。",
              "INIT_DATA_ERROR": "初期データの登録に失敗しました。データファイルを確認してください。"
          }
          return error_help.get(error_type, "不明なエラーが発生しました。")
      
      # 実行例も提供
      def get_command_examples() -> list:
          return [
              "LD_LIBRARY_PATH=\"/nix/store/p44qan69linp3ii0xrviypsw2j4qdcp2-gcc-13.2.0-lib/lib/\":$LD_LIBRARY_PATH /home/nixos/bin/src/kuzu/upsert/.venv/bin/python /home/nixos/bin/src/kuzu/upsert/__main__.py --init true --with-data",
              "LD_LIBRARY_PATH=\"/nix/store/p44qan69linp3ii0xrviypsw2j4qdcp2-gcc-13.2.0-lib/lib/\":$LD_LIBRARY_PATH /home/nixos/bin/src/kuzu/upsert/.venv/bin/python /home/nixos/bin/src/kuzu/upsert/__main__.py --init /path/to/db --with-data"
          ]
      
      # 呼び出し側(cli.py)はコマンド側が提供するヘルプ情報を取得して表示する
      def handle_error(command_name: str, error: dict) -> None:
          # コマンドモジュールを動的にインポート
          module_name = command_name.replace("handle_", "")
          module = importlib.import_module(f"upsert.interface.commands.{module_name}")
          
          # エラーヘルプと実行例を取得(実装されている場合)
          error_help = getattr(module, "get_error_help", lambda x: "")(error.get("error_type", ""))
          examples = getattr(module, "get_command_examples", lambda: [])()
          
          # エラーメッセージを表示
          print(f"エラー: {error.get('message', '不明なエラー')}", file=sys.stderr)
          
          # エラーヘルプがある場合は表示
          if error_help:
              print(f"\n{error_help}", file=sys.stderr)
          
          # 実行例がある場合は表示
          if examples:
              print("\n実行例:", file=sys.stderr)
              for example in examples:
                  print(f"  {example}", file=sys.stderr)

## 禁止事項:
  items:
    ### クラス:
      description: classキーワードを使用したクラス定義は避ける
      reason: オブジェクト指向設計の代わりに、関数とデータの明確な分離を行う
      examples:
        avoid: |
          # 避けるべき例
          class FunctionRepository:
              def __init__(self, connection):
                  self.connection = connection
              
              def save(self, function):
                  # ...
        good: |
          # 良い例
          def create_function_repository(connection):
              def save(function):
                  # ...
              
              def find_by_id(function_id):
                  # ...
              
              return {
                  "save": save,
                  "find_by_id": find_by_id
              }
    
    ### 例外:
      description: try/exceptブロックや例外の使用は避ける
      reason: 明示的なエラー型とエラーハンドリング関数を使用する
      examples:
        avoid: |
          # 避けるべき例
          def divide(a, b):
              try:
                  return a / b
              except ZeroDivisionError:
                  raise ValueError("Cannot divide by zero")
        good: |
          # 良い例
          def divide(a, b):
              if b == 0:
                  return {"status": "error", "message": "Cannot divide by zero", "code": "ZERO_DIVISION"}
              return {"status": "success", "data": a / b}

## 推奨される実装スタイル:
  items:
    ### 関数のみで実装:
      description: 可能な限り純粋関数を使用する
      rules:
        - 同じ入力に対して常に同じ出力を返し、副作用のない関数を使用すること
        - 状態を持つオブジェクトの代わりに、関数のクロージャを活用すること
        - 高階関数（関数を引数として受け取るか、関数を返す関数）を活用すること
      examples:
        good: |
          # 良い例
          def create_validator(schema):
              def validate(data):
                  # schemaを使ってdataを検証
                  # ...
                  return is_valid, error_message
              
              return validate
          
          # 使用例
          validate_function = create_validator(function_schema)
          is_valid, error = validate_function(data)
    
    ### 不変性の確保:
      description: データの変更は避け、新しいデータ構造を返す
      rules:
        - データの変更は避け、新しいデータ構造を返すこと
        - リスト操作にはmap、filter、reduceなどの高階関数を使用すること
      examples:
        avoid: |
          # 避けるべき例
          def add_parameter(function, parameter):
              function["parameters"].append(parameter)
              return function
        good: |
          # 良い例
          def add_parameter(function, parameter):
              return {
                  **function,
                  "parameters": [*function["parameters"], parameter]
              }

## ファイル構造とモジュール設計:
  rules:
    - 各モジュールは明確に定義された単一の責任を持つべき
    - 関連する関数をモジュールにグループ化すること
    - 循環依存を避けるために、依存関係グラフを意識すること

## テスト:
  rules:
    - すべての関数にユニットテストを書くこと
    - テストは関数の入出力のみに焦点を当てること
    - テストは目的を明確に示す命名を使用すること
    - テストはpytestの規約に従って記述すること（assert文を使用）
    - 以下の2種類のテストを区別すること:
      - 単体テスト: 実装ファイル内に記述し、if __name__ == "__main__"ブロック内で実行
      - E2Eテスト: tests/e2e ディレクトリ内の専用ファイルに記述
    - 単体テストは別途テストファイルは作成せず、実装ファイル内に記述すること
    - E2Eテストは tests/e2e 内の適切なサブディレクトリに配置すること（例: interface, application）
    - E2Eテストは必ずpytestのフィクスチャ機能を活用してクリーンアップメカニズムを実装し、テスト実行時に作成されたファイルを削除すること
    - if __name__ == "__main__"ブロック内にテストケースを記述し、ファイル単体実行時にテストが実行されるようにすること
  examples:
    unit_test: |
      # 実装例
      def add(a: int, b: int) -> int:
          return a + b
      
      # テスト関数
      def verify_addition():
          assert add(1, 2) == 3
          assert add(-1, 1) == 0
          assert add(0, 0) == 0
      
      # テスト実行
      if __name__ == "__main__":
          import sys
          import pytest
          
          # このモジュールのテストを実行
          pytest.main([__file__])
    
    e2e_test: |
      """
      CLIのE2Eテスト
      
      このモジュールはCLIインターフェースのエンドツーエンドテストを提供します。
      """
      
      import os
      import pytest
      
      # ファイルクリーンアップを管理するフィクスチャ
      @pytest.fixture(scope="session", autouse=True)
      def cleanup_test_files():
          temp_files = []
          
          # 前処理
          yield temp_files
          
          # 後処理: 作成したファイルをクリーンアップ
          for file_path in temp_files:
              if os.path.exists(file_path):
                  os.remove(file_path)
                  print(f"削除: {file_path}")
      
      # テストケース
      def test_command_execution(tmp_path, cleanup_test_files):
          # 一時ファイルのパスを設定
          temp_file = tmp_path / "test_file.txt"
          cleanup_test_files.append(str(temp_file))
          
          # テスト実行
          # ...
          
          # 検証
          assert temp_file.exists()

## 最小構成の記述:
  rules:
    - 各テストは単一の機能や動作に焦点を当てること
    - テストコードは簡潔かつ明確に保ち、過度な複雑さを避けること
    - テストの前提条件、実行内容、期待される結果を明確にすること
    - 冗長なアサーションや検証は避け、必要最小限のチェックに留めること
    - テスト間の依存関係を最小限に抑え、独立して実行可能な構造にすること
    - pytestの標準機能（tmp_path、monkeypatchなど）を最大限に活用すること
  examples:
    good: |
      def test_init_command_creates_database(tmp_path, cleanup_test_files):
          # 前提条件
          db_dir = tmp_path / "test_db"
          db_dir.mkdir()
          cleanup_test_files.append(str(db_dir))
          
          # 実行
          result = execute_init_command(str(db_dir))
          
          # 検証（最小限のチェック）
          assert result["success"] is True
          assert (db_dir / "database.kuzu").exists()
    
    avoid: |
      # 避けるべき例: 複数の機能を一度にテストしている
      def test_multiple_features():
          # 初期化をテスト
          result1 = execute_init_command()
          assert result1["success"] is True
          
          # クエリ実行もテスト
          result2 = execute_query_command("MATCH (n) RETURN n")
          assert result2["success"] is True
          
          # データ取得もテスト
          result3 = execute_get_command("function1")
          assert result3["success"] is True

## ドキュメント:
  rules:
    - すべての関数に適切なドキュメント文字列を書くこと
    - パラメータの型と戻り値の型を文書化すること
    - 複雑なロジックには説明コメントを追加すること

## 設定管理:
  rules:
    - デフォルト設定は一切禁止
    - デフォルト引数も同様にデフォルト設定なので禁止
    - 設定箇所は以下のみを許可する:
      - infrastructure/variables.py
