# コーディング規約 (CONVENTION)

## 基本原則:
  description: 関数型プログラミングの原則に可能な限り従い、コードの予測可能性、テスト容易性、保守性を向上させる
  
## 言語横断的な記述方式:
  description: 汎用プログラミング言語の多くで共通可能な記述方法のみを使用する
  rules:
    - Result型、Option型、Maybe型などの関数型プログラミング特有の記述は禁止
    - Monad、Functor、Applicativeなどの高度な関数型概念は使用禁止
    - 言語固有の高度な型システム機能（Rust、Haskell、Scala等）は使用禁止
    - ダミーフォールバックモック一切禁止
    - 最小構成でコード維持を徹底する
    - 複雑な条件分岐には積極的にパターンマッチを使用する
    - 高階関数と依存性注入を活用し責務分離を徹底
    - 以下の汎用的な機能のみを使用すること:
      - 基本的なデータ型（文字列、数値、真偽値、配列、オブジェクト/辞書）
      - 条件分岐（if/else、switch/case）
      - ループ処理（for、while）
      - 関数定義と呼び出し
      - 高階関数（map、filter、reduce等の基本的なもの）
      - 共用体型（Union型、Tagged Union）による分岐処理
  examples:
    prohibited: |
      // 禁止: Result型の使用
      function divide(a: number, b: number): Result<number, string> {
        if (b === 0) {
          return Err("Division by zero");
        }
        return Ok(a / b);
      }
      
      // 禁止: Option型の使用
      function findById(id: string): Option<User> {
        const user = database.find(id);
        return user ? Some(user) : None;
      }
      
      // 禁止: モナディック処理
      const result = divide(10, 2)
        .map(x => x * 2)
        .flatMap(x => divide(x, 3))
        .unwrap();
    
    allowed: |
      // 許可: 共用体型による分岐処理
      interface DivisionSuccess { data: number; }
      interface DivisionError { code: string; message: string; }
      type DivisionResult = DivisionSuccess | DivisionError;
      
      function divide(a: number, b: number): DivisionResult {
        if (b === 0) {
          return { code: "DIVISION_BY_ZERO", message: "Cannot divide by zero" };
        }
        return { data: a / b };
      }
      
      // 許可: 明示的な分岐処理
      function processUser(id: string): UserResult | NotFoundError {
        const user = database.find(id);
        if (!user) {
          return { code: "USER_NOT_FOUND", message: "User not found" };
        }
        return { data: user };
      }
      
      // 許可: 基本的な高階関数
      const numbers = [1, 2, 3, 4, 5];
      const doubled = numbers.map(x => x * 2);
      const evens = numbers.filter(x => x % 2 === 0);
      const sum = numbers.reduce((acc, x) => acc + x, 0);
  
  reasoning: |
    この制約により以下の効果を得る:
    - Python、TypeScript、Java、C#、Go、Rust（基本機能のみ）等での一貫した実装が可能
    - 学習コストを最小限に抑制
    - 言語固有の高度な機能への依存を回避
    - チーム内での知識共有が容易
    - 将来的な言語移行時のリスク軽減
  
## 型定義:
  rules:
    - TypedDictを使用すること
    - 各層のtypes.pyファイルに型定義を集約すること
    - 可能な限り型アノテーションを使用すること
    - TypeScriptではinterfaceによる型定義よりtype定義使用を優先すること
    - 条件分岐は可能な限りパターンマッチで行い可読性向上に寄与させること
  examples:
    good: |
      # Python例
      from typing import TypedDict, List, Optional
      
      class FunctionData(TypedDict):
          title: str
          description: Optional[str]
          type: str
          pure: bool
          parameters: List["ParameterData"]
      
      # TypeScript例（type定義を優先）
      type FunctionData = {
          title: string;
          description?: string;
          type: string;
          pure: boolean;
          parameters: ParameterData[];
      };
      
      type ValidationError = {
          code: "VALIDATION_ERROR";
          message: string;
          field: string;
      };
      
      type NotFoundError = {
          code: "NOT_FOUND_ERROR";
          message: string;
          resource: string;
      };
      
      # 共用体型（Tagged Union）でのパターンマッチ
      type ProcessResult = FunctionData | ValidationError | NotFoundError;
      
      function handleResult(result: ProcessResult): string {
          # パターンマッチによる分岐（可読性向上）
          switch (result.code) {
              case "VALIDATION_ERROR":
                  return `バリデーションエラー: ${result.field} - ${result.message}`;
              case "NOT_FOUND_ERROR":
                  return `リソースが見つかりません: ${result.resource}`;
              default:
                  # 成功時（codeプロパティが存在しない場合）
                  return `処理成功: ${result.title}`;
          }
      }
    
    avoid: |
      # 避けるべき例: interface使用
      interface FunctionData {  // type定義を優先すべき
          title: string;
      }
      
      # 避けるべき例: 複雑な条件分岐
      function handleResult(result: ProcessResult): string {
          if ("code" in result && result.code === "VALIDATION_ERROR") {
              return `バリデーションエラー: ${result.message}`;
          } else if ("code" in result && result.code === "NOT_FOUND_ERROR") {
              return `リソースが見つかりません: ${result.message}`;
          } else {
              return `処理成功: ${(result as FunctionData).title}`;
          }
      }

## エラー処理:
  rules:
    - 例外を投げる代わりに、定義したエラー型を返却すること
    - 関数の戻り値として成功/失敗を表現すること
    - Result型は使用せず、以下の2+1種類の列挙型/共用体型を使用すること:
      - 成功時の戻り値型
      - 例外時の戻り値型
      - (オプション)副作用型
    - 全言語共通で以下の形式を採用すること:
      - 成功時は元の型をそのまま返す
      - 失敗時は特定のエラー型を返す
      - 型の判定はプロパティの有無などで行う
      - TypeScriptでは: 成功型 | エラー型A | エラー型B | ...
      - Pythonでは: Union[成功型, エラー型A, エラー型B, ...]
      - 言語を問わず同様の共用体型パターンを使用する
  examples:
    good: |
      # Python例（汎用記述方式）
      from typing import TypedDict, Union, Literal
      
      class FunctionData(TypedDict):
          title: str
          description: str
          parameters: List[str]
      
      class FunctionError(TypedDict):
          code: str
          message: str
      
      # 成功型とエラー型の共用体型として定義（汎用的な手法）
      FunctionResult = Union[FunctionData, FunctionError]
      
      def add_function(data: dict) -> FunctionResult:
          if not validate_data(data):
              # エラー時は明示的にエラー型を返す（汎用的な手法）
              return {"code": "INVALID_DATA", "message": "Invalid data"}
          
          # 処理...
          
          # 成功時は通常のデータを返す（汎用的な手法）
          return {
              "title": result_title,
              "description": result_description,
              "parameters": result_parameters
          }
      
      # エラーかどうかの判別関数（汎用的な手法）
      def is_error(result: FunctionResult) -> bool:
          return "code" in result and "message" in result
      
      # 使用例（汎用的な手法）
      result = add_function(input_data)
      if is_error(result):
          print(f"エラー: {result['message']}")
      else:
          print(f"成功: {result['title']}")
    
    typescript: |
      // TypeScript例（汎用記述方式）
      interface FunctionData {
          title: string;
          description: string;
          parameters: string[];
      }
      
      interface FunctionError {
          code: string;
          message: string;
      }
      
      // 成功型とエラー型の共用体型として定義（汎用的な手法）
      type FunctionResult = FunctionData | FunctionError;
      
      function addFunction(data: any): FunctionResult {
          if (!validateData(data)) {
              // エラー時は明示的にエラー型を返す（汎用的な手法）
              return { code: "INVALID_DATA", message: "Invalid data" };
          }
          
          // 処理...
          
          // 成功時は通常のデータを返す（汎用的な手法）
          return {
              title: resultTitle,
              description: resultDescription,
              parameters: resultParameters
          };
      }
      
      // エラーかどうかの判別関数（汎用的な手法）
      function isError(result: FunctionResult): result is FunctionError {
          return 'code' in result && 'message' in result;
      }
      
      // 使用例（汎用的な手法）
      const result = addFunction(inputData);
      if (isError(result)) {
          console.error(`エラー: ${result.message}`);
      } else {
          console.log(`成功: ${result.title}`);
      }
    
    note: |
      汎用記述方式の重要な特徴:
      - Result<T, E>やOption<T>などの関数型言語特有の型は使用しない
      - 代わりに共用体型（Union型、Tagged Union）を使用する
      - エラー判定は明示的な分岐処理で行う
      - map、flatMap、unwrapなどのモナディック操作は使用しない
      - 基本的な条件分岐とプロパティチェックのみを使用する

## エラーメッセージの責務:
  rules:
    - エラーハンドリング自体は呼び出し側(cli.py)で行う
    - エラーメッセージの内容はコマンド側の責務とする
    - 各コマンドはエラー型の定義とメッセージを含むTypedDictエラー型を定義すること
  examples:
    good: |
      # コマンドモジュール(initialize.py)内
      from typing import TypedDict, Literal
      
      class InitError(TypedDict):
          error_type: Literal["DB_PATH_ERROR", "VALIDATION_ERROR", "INIT_DATA_ERROR"]
          message: str
          details: dict
      
      # エラーメッセージのヘルプも提供
      def get_error_help(error_type: str) -> str:
          error_help = {
              "DB_PATH_ERROR": "データベースパスの指定に問題があります。有効なパスを指定してください。\n例: --init /path/to/db または --init true",
              "VALIDATION_ERROR": "SHACL検証エラーが発生しました。データモデルを確認してください。",
              "INIT_DATA_ERROR": "初期データの登録に失敗しました。データファイルを確認してください。"
          }
          return error_help.get(error_type, "不明なエラーが発生しました。")
      
      # 実行例も提供
      def get_command_examples() -> list:
          return [
              "LD_LIBRARY_PATH=\"/nix/store/p44qan69linp3ii0xrviypsw2j4qdcp2-gcc-13.2.0-lib/lib/\":$LD_LIBRARY_PATH /home/nixos/bin/src/kuzu/upsert/.venv/bin/python /home/nixos/bin/src/kuzu/upsert/__main__.py --init true --with-data",
              "LD_LIBRARY_PATH=\"/nix/store/p44qan69linp3ii0xrviypsw2j4qdcp2-gcc-13.2.0-lib/lib/\":$LD_LIBRARY_PATH /home/nixos/bin/src/kuzu/upsert/.venv/bin/python /home/nixos/bin/src/kuzu/upsert/__main__.py --init /path/to/db --with-data"
          ]
      
      # 呼び出し側(cli.py)はコマンド側が提供するヘルプ情報を取得して表示する
      def handle_error(command_name: str, error: dict) -> None:
          # コマンドモジュールを動的にインポート
          module_name = command_name.replace("handle_", "")
          module = importlib.import_module(f"upsert.interface.commands.{module_name}")
          
          # エラーヘルプと実行例を取得(実装されている場合)
          error_help = getattr(module, "get_error_help", lambda x: "")(error.get("error_type", ""))
          examples = getattr(module, "get_command_examples", lambda: [])()
          
          # エラーメッセージを表示
          print(f"エラー: {error.get('message', '不明なエラー')}", file=sys.stderr)
          
          # エラーヘルプがある場合は表示
          if error_help:
              print(f"\n{error_help}", file=sys.stderr)
          
          # 実行例がある場合は表示
          if examples:
              print("\n実行例:", file=sys.stderr)
              for example in examples:
                  print(f"  {example}", file=sys.stderr)

## 禁止事項:
  items:
    ### クラス:
      description: classキーワードを使用したクラス定義は避ける
      reason: オブジェクト指向設計の代わりに、関数とデータの明確な分離を行う
      examples:
        avoid: |
          # 避けるべき例
          class FunctionRepository:
              def __init__(self, connection):
                  self.connection = connection
              
              def save(self, function):
                  # ...
        good: |
          # 良い例
          def create_function_repository(connection):
              def save(function):
                  # ...
              
              def find_by_id(function_id):
                  # ...
              
              return {
                  "save": save,
                  "find_by_id": find_by_id
              }
    
    ### 例外:
      description: try/exceptブロックや例外の使用は避ける
      reason: 明示的なエラー型とエラーハンドリング関数を使用する
      examples:
        avoid: |
          # 避けるべき例
          def divide(a, b):
              try:
                  return a / b
              except ZeroDivisionError:
                  raise ValueError("Cannot divide by zero")
        good: |
          # 良い例
          def divide(a, b):
              if b == 0:
                  return {"status": "error", "message": "Cannot divide by zero", "code": "ZERO_DIVISION"}
              return {"status": "success", "data": a / b}
    
    ### ダミーフォールバックモック:
      description: ダミーフォールバックモック実装は一切禁止
      reason: 実装の不完全性を隠蔽し、バグの原因となる
      rules:
        - throw new Error('Mock not implemented')などのプレースホルダー実装は禁止
        - 開発用の仮実装も禁止
        - 実際に動作する最小実装のみを許可
        - 未実装機能は型定義から除外すること
      examples:
        avoid: |
          # 避けるべき例: ダミーモック
          export function createMockRepository(): Repository {
            throw new Error('Mock repository is not implemented. Use real implementation only.');
          }
          
          # 避けるべき例: 仮実装
          export function processData(data: any): ProcessResult {
            // TODO: 実装予定
            return { success: false, error: "Not implemented yet" };
          }
        good: |
          # 良い例: 最小実装
          export function createInMemoryRepository(): Repository {
            const data: Map<string, any> = new Map();
            
            return {
              save: (id: string, item: any) => {
                data.set(id, item);
                return { success: true };
              },
              find: (id: string) => {
                const item = data.get(id);
                return item ? { data: item } : { code: "NOT_FOUND", message: "Item not found" };
              }
            };
          }

## 推奨される実装スタイル:
  items:
    ### パターンマッチによる条件分岐:
      description: 可能な限りパターンマッチで条件分岐を行い可読性向上に寄与させる
      rules:
        - Tagged Unionを活用してdiscriminated unionパターンを使用すること
        - switch文やmatch文を優先的に使用すること
        - 複雑なif-else chainは避けること
        - パターンマッチできない言語でも類似の構造化された分岐を行うこと
      examples:
        good: |
          # TypeScript例（パターンマッチ優先）
          type QueryResult = 
            | { status: "success"; data: any }
            | { status: "validation_error"; field: string; message: string }
            | { status: "execution_error"; code: string; message: string }
            | { status: "not_found"; resource: string };
          
          function handleQueryResult(result: QueryResult): string {
              # パターンマッチによる分岐（可読性が高い）
              switch (result.status) {
                  case "success":
                      return `データ取得成功: ${JSON.stringify(result.data)}`;
                  case "validation_error":
                      return `バリデーションエラー [${result.field}]: ${result.message}`;
                  case "execution_error":
                      return `実行エラー [${result.code}]: ${result.message}`;
                  case "not_found":
                      return `リソースが見つかりません: ${result.resource}`;
                  default:
                      # 網羅性チェック（TypeScriptでnever型になる）
                      const _exhaustive: never = result;
                      throw new Error("未処理のケース");
              }
          }
          
          # Python例（辞書によるパターンマッチ風処理）
          from typing import TypedDict, Union, Literal
          
          class SuccessResult(TypedDict):
              status: Literal["success"]
              data: any
          
          class ValidationErrorResult(TypedDict):
              status: Literal["validation_error"]
              field: str
              message: str
          
          class ExecutionErrorResult(TypedDict):
              status: Literal["execution_error"]
              code: str
              message: str
          
          QueryResult = Union[SuccessResult, ValidationErrorResult, ExecutionErrorResult]
          
          def handle_query_result(result: QueryResult) -> str:
              # パターンマッチ風の構造化された分岐
              handlers = {
                  "success": lambda r: f"データ取得成功: {r['data']}",
                  "validation_error": lambda r: f"バリデーションエラー [{r['field']}]: {r['message']}",
                  "execution_error": lambda r: f"実行エラー [{r['code']}]: {r['message']}"
              }
              
              handler = handlers.get(result["status"])
              if handler:
                  return handler(result)
              else:
                  raise ValueError(f"未処理のステータス: {result['status']}")
        
        avoid: |
          # 避けるべき例: 複雑なif-else chain
          function handleQueryResult(result: QueryResult): string {
              if ("data" in result && result.status === "success") {
                  return `データ取得成功: ${JSON.stringify(result.data)}`;
              } else if ("field" in result && "message" in result && result.status === "validation_error") {
                  return `バリデーションエラー [${result.field}]: ${result.message}`;
              } else if ("code" in result && "message" in result && result.status === "execution_error") {
                  return `実行エラー [${result.code}]: ${result.message}`;
              } else {
                  return "未知のエラー";
              }
          }
    
    ### 関数のみで実装:
      description: 可能な限り純粋関数を使用する
      rules:
        - 同じ入力に対して常に同じ出力を返し、副作用のない関数を使用すること
        - 状態を持つオブジェクトの代わりに、関数のクロージャを活用すること
        - 高階関数（関数を引数として受け取るか、関数を返す関数）を活用すること
      examples:
        good: |
          # 良い例
          def create_validator(schema):
              def validate(data):
                  # schemaを使ってdataを検証
                  # ...
                  return is_valid, error_message
              
              return validate
          
          # 使用例
          validate_function = create_validator(function_schema)
          is_valid, error = validate_function(data)
    
    ### 高階関数による依存性注入:
      description: 可能な限り高階関数による依存性注入を行う
      reason: 純粋な関数合成により、テスト容易性と拡張性を向上させる
      rules:
        - 依存性は関数の引数として明示的に渡すこと
        - 高階関数を使用してサービス関数を生成すること
        - 依存性は型定義されたオブジェクトとして渡すこと
        - 関数カリー化を活用して部分適用を可能にすること
        - モジュール内でのグローバル状態は禁止すること
      examples:
        good: |
          # TypeScript例
          interface QueryDependencies {
            repository: {
              execute: (query: string, params: any) => Promise<QueryResult>;
              validate: (query: string) => boolean;
            };
            logger: {
              info: (message: string) => void;
              error: (message: string, error: any) => void;
            };
          }
          
          // 高階関数による依存性注入
          function createQueryService(deps: QueryDependencies) {
            return function executeQuery(query: string, params: any): QueryResult {
              if (!deps.repository.validate(query)) {
                deps.logger.error("Invalid query", { query });
                return { code: "INVALID_QUERY", message: "Query validation failed" };
              }
              
              try {
                const result = deps.repository.execute(query, params);
                deps.logger.info("Query executed successfully");
                return { data: result };
              } catch (error) {
                deps.logger.error("Query execution failed", error);
                return { code: "EXECUTION_ERROR", message: error.message };
              }
            };
          }
          
          // 関数カリー化による部分適用
          function createTemplateProcessor(deps: ProcessorDependencies) {
            return function processTemplate(templateName: string) {
              return function withParams(params: any): ProcessResult {
                // 依存性を使用した処理
                const template = deps.templateLoader.load(templateName);
                const validated = deps.validator.validate(params);
                
                if (!validated.isValid) {
                  return { code: "VALIDATION_ERROR", message: validated.error };
                }
                
                return deps.executor.process(template, params);
              };
            };
          }
          
          # Python例
          from typing import TypedDict, Callable, Any
          
          class QueryDependencies(TypedDict):
              repository: dict
              logger: dict
          
          def create_query_service(deps: QueryDependencies):
              def execute_query(query: str, params: Any):
                  if not deps["repository"]["validate"](query):
                      deps["logger"]["error"]("Invalid query", {"query": query})
                      return {"code": "INVALID_QUERY", "message": "Query validation failed"}
                  
                  result = deps["repository"]["execute"](query, params)
                  deps["logger"]["info"]("Query executed successfully")
                  return {"data": result}
              
              return execute_query
          
          # 使用例
          dependencies = {
              "repository": create_repository(connection),
              "logger": create_logger(config)
          }
          
          query_service = create_query_service(dependencies)
          result = query_service("MATCH (n) RETURN n", {})
        
        avoid: |
          # 避けるべき例: グローバル状態への依存
          repository = None  # グローバル変数
          
          def execute_query(query: str):
              global repository
              return repository.execute(query)  # グローバル状態への依存
          
          # 避けるべき例: ハードコードされた依存性
          def process_data(data):
              db = PostgreSQLDatabase()  # ハードコード
              validator = JsonValidator()  # ハードコード
              return db.save(validator.validate(data))
    
    ### 不変性の確保:
      description: データの変更は避け、新しいデータ構造を返す
      rules:
        - データの変更は避け、新しいデータ構造を返すこと
        - リスト操作にはmap、filter、reduceなどの高階関数を使用すること
      examples:
        avoid: |
          # 避けるべき例
          def add_parameter(function, parameter):
              function["parameters"].append(parameter)
              return function
        good: |
          # 良い例
          def add_parameter(function, parameter):
              return {
                  **function,
                  "parameters": [*function["parameters"], parameter]
              }

## ファイル構造とモジュール設計:
  rules:
    - 各モジュールは明確に定義された単一の責任を持つべき
    - 関連する関数をモジュールにグループ化すること
    - 循環依存を避けるために、依存関係グラフを意識すること
    - 最小構成でコード維持を徹底すること
    - 不要な機能、未使用の関数、冗長なコードは一切含めないこと
    - 1つのファイルは1つの明確な責務のみを持つこと

## テスト:
  rules:
    - すべての関数にユニットテストを書くこと
    - テストは関数の入出力のみに焦点を当てること
    - テストは目的を明確に示す命名を使用すること
    - テストはpytestの規約に従って記述すること（assert文を使用）
    - 以下の2種類のテストを区別すること:
      - 単体テスト: 実装ファイル内に記述し、if __name__ == "__main__"ブロック内で実行
      - E2Eテスト: tests/e2e ディレクトリ内の専用ファイルに記述
    - 単体テストは別途テストファイルは作成せず、実装ファイル内に記述すること
    - E2Eテストは tests/e2e 内の適切なサブディレクトリに配置すること（例: interface, application）
    - E2Eテストは必ずpytestのフィクスチャ機能を活用してクリーンアップメカニズムを実装し、テスト実行時に作成されたファイルを削除すること
    - if __name__ == "__main__"ブロック内にテストケースを記述し、ファイル単体実行時にテストが実行されるようにすること
  examples:
    unit_test: |
      # 実装例
      def add(a: int, b: int) -> int:
          return a + b
      
      # テスト関数
      def verify_addition():
          assert add(1, 2) == 3
          assert add(-1, 1) == 0
          assert add(0, 0) == 0
      
      # テスト実行
      if __name__ == "__main__":
          import sys
          import pytest
          
          # このモジュールのテストを実行
          pytest.main([__file__])
    
    e2e_test: |
      """
      CLIのE2Eテスト
      
      このモジュールはCLIインターフェースのエンドツーエンドテストを提供します。
      """
      
      import os
      import pytest
      
      # ファイルクリーンアップを管理するフィクスチャ
      @pytest.fixture(scope="session", autouse=True)
      def cleanup_test_files():
          temp_files = []
          
          # 前処理
          yield temp_files
          
          # 後処理: 作成したファイルをクリーンアップ
          for file_path in temp_files:
              if os.path.exists(file_path):
                  os.remove(file_path)
                  print(f"削除: {file_path}")
      
      # テストケース
      def test_command_execution(tmp_path, cleanup_test_files):
          # 一時ファイルのパスを設定
          temp_file = tmp_path / "test_file.txt"
          cleanup_test_files.append(str(temp_file))
          
          # テスト実行
          # ...
          
          # 検証
          assert temp_file.exists()

## 最小構成の記述:
  rules:
    - 各テストは単一の機能や動作に焦点を当てること
    - テストコードは簡潔かつ明確に保ち、過度な複雑さを避けること
    - テストの前提条件、実行内容、期待される結果を明確にすること
    - 冗長なアサーションや検証は避け、必要最小限のチェックに留めること
    - テスト間の依存関係を最小限に抑え、独立して実行可能な構造にすること
    - pytestの標準機能（tmp_path、monkeypatchなど）を最大限に活用すること
  examples:
    good: |
      def test_init_command_creates_database(tmp_path, cleanup_test_files):
          # 前提条件
          db_dir = tmp_path / "test_db"
          db_dir.mkdir()
          cleanup_test_files.append(str(db_dir))
          
          # 実行
          result = execute_init_command(str(db_dir))
          
          # 検証（最小限のチェック）
          assert result["success"] is True
          assert (db_dir / "database.kuzu").exists()
    
    avoid: |
      # 避けるべき例: 複数の機能を一度にテストしている
      def test_multiple_features():
          # 初期化をテスト
          result1 = execute_init_command()
          assert result1["success"] is True
          
          # クエリ実行もテスト
          result2 = execute_query_command("MATCH (n) RETURN n")
          assert result2["success"] is True
          
          # データ取得もテスト
          result3 = execute_get_command("function1")
          assert result3["success"] is True

## ドキュメント:
  rules:
    - すべての関数に適切なドキュメント文字列を書くこと
    - パラメータの型と戻り値の型を文書化すること
    - 複雑なロジックには説明コメントを追加すること

## 設定管理:
  rules:
    - デフォルト設定は一切禁止
    - デフォルト引数も同様にデフォルト設定なので禁止
    - 設定箇所は以下のみを許可する:
      - infrastructure/variables.py
