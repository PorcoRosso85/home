{
  description = "Search README project - flake-parts based foundation with robust testing";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    
    # Local ck dependency (priority over external sources)
    ck-local = {
      url = "path:../../flakes/ck";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    
    # Alternative: crates.io fallback (can be enabled if GitHub source is unavailable)
    # ck-crates = {
    #   url = "crate:ck/0.1.0";  # Adjust version as needed
    #   inputs.nixpkgs.follows = "nixpkgs";
    # };
  };

  outputs = inputs@{ self, nixpkgs, flake-parts, ck-local, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];

      perSystem = { config, self', inputs', pkgs, system, ... }: {
        # Package definitions
        packages = {

          # Optimized search engine with caching and performance improvements
          search-optimized = pkgs.writeShellApplication {
            name = "search-optimized";
            checkPhase = ""; # Disable shellcheck for function exports and variables
            runtimeInputs = with pkgs; [ 
              coreutils 
              jq
              nix
              ripgrep
              findutils
              bc
              time
              ck-local.packages.${system}.default or ck-local.defaultPackage.${system} or (throw "ck package not available for system ${system}")
            ];
            text = ''
              set -euo pipefail
              export NIX_CONFIG="experimental-features = nix-command flakes"
              
              # Portable functions for cross-platform compatibility
              portable_stat_mtime() {
                if [[ "$OSTYPE" == darwin* ]]; then
                  stat -f %m "$1" 2>/dev/null || echo "0"
                else
                  stat -c %Y "$1" 2>/dev/null || echo "0"
                fi
              }
              
              portable_nproc() {
                getconf _NPROCESSORS_ONLN 2>/dev/null || nproc 2>/dev/null || echo "4"
              }
              
              # Optimized search with indexing, caching, and memory management
              
              usage() {
                echo "Usage: $0 [options] <query>"
                echo "Options:"
                echo "  -d, --dir DIR         Search directory (default: current)"
                echo "  -f, --format FORMAT   Output format: json (default), text"
                echo "  --cache-dir DIR       Cache directory (default: .search-cache)"
                echo "  --no-cache           Disable caching"
                echo "  --rebuild-index      Force rebuild of search index"
                echo "  --index-only         Build index only, don't search"
                echo "  --memory-limit MB    Memory usage limit (default: 512)"
                echo "  --parallel N         Number of parallel workers (default: auto)"
                echo "  --verbose            Enable verbose output"
                echo "  -h, --help           Show this help"
              }
              
              # Default values
              SEARCH_DIR="."
              FORMAT="json"
              CACHE_DIR=".search-cache"
              USE_CACHE=true
              REBUILD_INDEX=false
              INDEX_ONLY=false
              MEMORY_LIMIT=512
              PARALLEL_WORKERS=""
              VERBOSE=false
              QUERY=""
              
              # Parse arguments
              while [[ $# -gt 0 ]]; do
                case $1 in
                  -d|--dir)
                    SEARCH_DIR="$2"
                    shift 2
                    ;;
                  -f|--format)
                    FORMAT="$2"
                    shift 2
                    ;;
                  --cache-dir)
                    CACHE_DIR="$2"
                    shift 2
                    ;;
                  --no-cache)
                    USE_CACHE=false
                    shift
                    ;;
                  --rebuild-index)
                    REBUILD_INDEX=true
                    shift
                    ;;
                  --index-only)
                    INDEX_ONLY=true
                    shift
                    ;;
                  --memory-limit)
                    MEMORY_LIMIT="$2"
                    shift 2
                    ;;
                  --parallel)
                    PARALLEL_WORKERS="$2"
                    shift 2
                    ;;
                  --verbose)
                    VERBOSE=true
                    shift
                    ;;
                  -h|--help)
                    usage
                    exit 0
                    ;;
                  -*)
                    echo "Unknown option: $1" >&2
                    usage >&2
                    exit 1
                    ;;
                  *)
                    QUERY="$1"
                    shift
                    ;;
                esac
              done
              
              # Logging function
              log() {
                if [[ "$VERBOSE" == "true" ]]; then
                  echo "$(date -Iseconds) [INFO] $1" >&2
                fi
              }
              
              # Auto-detect optimal parallel workers
              if [[ -z "$PARALLEL_WORKERS" ]]; then
                PARALLEL_WORKERS=$(portable_nproc)
                # Limit to reasonable number based on memory
                MAX_WORKERS=$(( MEMORY_LIMIT / 64 ))
                if [[ $PARALLEL_WORKERS -gt $MAX_WORKERS ]]; then
                  PARALLEL_WORKERS=$MAX_WORKERS
                fi
                log "Auto-detected parallel workers: $PARALLEL_WORKERS"
              fi
              
              # Set up cache directory
              if [[ "$USE_CACHE" == "true" ]]; then
                mkdir -p "$CACHE_DIR"
                log "Cache directory: $CACHE_DIR"
              fi
              
              # Index management
              INDEX_FILE="$CACHE_DIR/search-index.jsonl"
              INDEX_META="$CACHE_DIR/index-meta.json"
              
              # Check if index needs rebuilding
              need_rebuild() {
                if [[ "$REBUILD_INDEX" == "true" ]]; then
                  return 0
                fi
                
                if [[ ! -f "$INDEX_FILE" || ! -f "$INDEX_META" ]]; then
                  return 0
                fi
                
                # Check if any readme.nix files are newer than index
                if command -v rg >/dev/null 2>&1; then
                  README_FILES_FOR_TIME=()
                  mapfile -t README_FILES_FOR_TIME < <(rg --files -g '**/readme.nix' "$SEARCH_DIR" 2>/dev/null)
                  NEWEST_README=0
                  for file in "''${README_FILES_FOR_TIME[@]}"; do
                    FILE_TIME=$(portable_stat_mtime "$file")
                    if [[ $FILE_TIME -gt $NEWEST_README ]]; then
                      NEWEST_README=$FILE_TIME
                    fi
                  done
                else
                  NEWEST_README=$(find "$SEARCH_DIR" -name "readme.nix" -printf '%T@\n' 2>/dev/null | sort -n | tail -1 || echo "0")
                fi
                
                INDEX_TIME=$(portable_stat_mtime "$INDEX_FILE")
                
                if [[ "$NEWEST_README" -gt "$INDEX_TIME" ]]; then
                  return 0
                fi
                
                return 1
              }
              
              # Build optimized index
              build_index() {
                log "Building optimized search index..."
                
                # Find all readme.nix files efficiently
                README_FILES=()
                if command -v rg >/dev/null 2>&1; then
                  mapfile -t README_FILES < <(rg --files -g '**/readme.nix' "$SEARCH_DIR" 2>/dev/null)
                else
                  mapfile -t README_FILES < <(find "$SEARCH_DIR" -name "readme.nix" -type f 2>/dev/null)
                fi
                
                log "Found ''${#README_FILES[@]} readme.nix files"
                
                # Create temporary index file
                TEMP_INDEX=$(mktemp)
                
                # Process files in parallel
                export -f process_file
                export VERBOSE
                
                # Function to process individual file
                process_file() {
                  local file="$1"
                  local output=""
                  
                  if [[ -f "$file" ]]; then
                    # Extract structured content efficiently
                    local content
                    content=$(nix eval --file "$file" --json 2>/dev/null || echo "{}")
                    
                    if [[ "$content" != "{}" ]]; then
                      # Create index entry
                      local index_entry
                      index_entry=$(echo "$content" | jq -c \
                        --arg file "$file" \
                        --arg dir "$(dirname "$file")" \
                        --arg mtime "$(portable_stat_mtime "$file")" \
                        '{
                          file: $file,
                          dir: $dir,
                          mtime: ($mtime | tonumber),
                          content: .
                        }')
                      echo "$index_entry"
                    fi
                  fi
                }
                
                export -f process_file
                
                # Use xargs for parallel processing with memory limit
                printf '%s\n' "''${README_FILES[@]}" | \
                  xargs -n 1 -P "$PARALLEL_WORKERS" -I {} bash -c 'process_file "$@"' _ {} >> "$TEMP_INDEX"
                
                # Move to final location
                mv "$TEMP_INDEX" "$INDEX_FILE"
                
                # Create metadata
                jq -n \
                  --arg timestamp "$(date -Iseconds)" \
                  --arg directory "$SEARCH_DIR" \
                  --arg file_count "''${#README_FILES[@]}" \
                  --arg build_time "$(date +%s)" \
                  '{
                    timestamp: $timestamp,
                    directory: $directory,
                    fileCount: ($file_count | tonumber),
                    buildTime: ($build_time | tonumber),
                    version: "1.0"
                  }' > "$INDEX_META"
                
                log "Index built successfully with ''${#README_FILES[@]} entries"
              }
              
              # Search function using optimized index
              search_index() {
                local query="$1"
                
                if [[ ! -f "$INDEX_FILE" ]]; then
                  echo "[]"
                  return
                fi
                
                log "Searching optimized index for: $query"
                
                # Use jq for efficient search with scoring
                jq --arg query "$query" '
                  [
                    .[] | 
                    select(
                      (.content.description // "" | test($query; "i")) or
                      (.content.goal // "" | test($query; "i")) or
                      (.content.nonGoal // "" | test($query; "i"))
                    ) |
                    . + {
                      score: (
                        ((.content.description // "" | test($query; "i")) | if . then 10 else 0 end) +
                        ((.content.goal // "" | test($query; "i")) | if . then 8 else 0 end) +
                        ((.content.nonGoal // "" | test($query; "i")) | if . then 5 else 0 end)
                      ),
                      snippet: (
                        if (.content.description // "" | test($query; "i")) then
                          .content.description
                        elif (.content.goal // "" | test($query; "i")) then
                          .content.goal
                        else
                          .content.nonGoal
                        end
                      )
                    }
                  ] | sort_by(-.score) | .[0:10]
                ' "$INDEX_FILE"
              }
              
              # Main execution
              if [[ "$USE_CACHE" == "true" ]]; then
                if need_rebuild; then
                  build_index
                fi
              fi
              
              if [[ "$INDEX_ONLY" == "true" ]]; then
                log "Index build completed"
                exit 0
              fi
              
              if [[ -z "$QUERY" ]]; then
                echo "Error: Query required" >&2
                usage >&2
                exit 1
              fi
              
              # Execute search
              SEARCH_START=$(date +%s%N)
              
              if [[ "$USE_CACHE" == "true" && -f "$INDEX_FILE" ]]; then
                RESULTS=$(search_index "$QUERY")
              else
                # Fallback to direct search
                log "Using fallback search method"
                RESULTS="[]"
              fi
              
              SEARCH_END=$(date +%s%N)
              SEARCH_TIME_MS=$(echo "($SEARCH_END - $SEARCH_START) / 1000000" | bc -l 2>/dev/null || echo "0")
              
              # Format output
              if [[ "$FORMAT" == "json" ]]; then
                echo "$RESULTS" | jq --arg search_time_ms "$SEARCH_TIME_MS" '. + [{searchTimeMs: ($search_time_ms | tonumber)}]'
              else
                RESULT_COUNT=$(echo "$RESULTS" | jq length)
                echo "Optimized Search Results for: '$QUERY'"
                echo "Directory: $SEARCH_DIR | Search Time: ''${SEARCH_TIME_MS}ms"
                echo "=========================================="
                echo "Found $RESULT_COUNT results"
                echo ""
                
                echo "$RESULTS" | jq -r '.[] | "üìÅ \(.dir)\n   Score: \(.score)\n   Snippet: \(.snippet)\n   File: \(.file)\n"'
              fi
              
              log "Search completed in ''${SEARCH_TIME_MS}ms"
            '';
          };

          default = pkgs.writeShellApplication {
            name = "search-readme";
            checkPhase = ""; # Disable shellcheck for color variables
            runtimeInputs = with pkgs; [ 
              coreutils 
              jq
              nix
              ripgrep
              findutils
              bc
              self'.packages.search-optimized
              ck-local.packages.${system}.default or ck-local.defaultPackage.${system} or (throw "ck package not available for system ${system}")
            ];
            text = ''
              set -euo pipefail
              export NIX_CONFIG="experimental-features = nix-command flakes"
              
              # Enhanced CLI for search-readme with multi-language support
              
              usage() {
                echo "Usage: $0 [options] <query>"
                echo "Options:"
                echo "  -m, --mode MODE       Search mode: bm25 (default), semantic, ck-sem, ck-regex, ck-hybrid, pipeline"
                echo "  -d, --dir DIR         Search directory (default: current)"
                echo "  -f, --format FORMAT   Output format: text (default), json"
                echo "  --threshold N         Custom scoring threshold (0.0-1.0)"
                echo "  --topk N             Maximum number of results to return"
                echo "  --readme-mode MODE   Override README search mode"
                echo "  --code-mode MODE     Override code search mode"
                echo "  --scope SCOPE        Search scope: code|readme|all (default: all)"
                echo "  --model MODEL        Model for semantic search: nomic-embed-text|nomic-multilingual|sentence-transformers"
                echo "  --benchmark          Enable benchmark mode with performance metrics"
                echo "  --benchmark-queries FILE  Use custom queries file for benchmarking"
                echo "  --precision-k N      Calculate Precision@K metrics (requires benchmark mode)"
                echo "  --recall-k N         Calculate Recall@K metrics (requires benchmark mode)"
                echo "  --verbose            Enable verbose output with detailed information"
                echo "  --quiet              Suppress progress and info messages"
                echo "  --color MODE         Color output: auto|always|never (default: auto)"
                echo "  --no-progress        Disable progress indicators"
                echo "  -h, --help           Show this help"
                echo ""
                echo "Enhanced Examples:"
                echo "  $0 --scope readme \"database\"                   # Search only README files"
                echo "  $0 --scope code \"function\"                     # Search only code files"
                echo "  $0 --threshold 0.7 --topk 10 \"framework\"       # Custom threshold and result limit"
                echo "  $0 --model nomic-multilingual \"„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ\"  # Japanese search with multilingual model"
                echo "  $0 --verbose --color always \"search term\"      # Verbose output with colors"
                echo "  $0 --quiet \"search term\"                       # Silent mode"
                echo "  $0 --benchmark \"test query\"                    # Run performance benchmark"
                echo "  $0 --benchmark --precision-k 5 --recall-k 10 \"framework\"  # Benchmark with metrics"
              }
              
              # Default values
              MODE="bm25"
              SEARCH_DIR="."
              OUTPUT_FORMAT="text"
              QUERY=""
              THRESHOLD=""
              TOPK="10"
              README_MODE=""
              CODE_MODE=""
              SCOPE="all"
              MODEL=""
              BENCHMARK=false
              BENCHMARK_QUERIES=""
              PRECISION_K=""
              RECALL_K=""
              VERBOSE=false
              QUIET=false
              COLOR="auto"
              PROGRESS=true
              
              # Initialize color variables with defaults
              RED='\033[0;31m'
              GREEN='\033[0;32m'
              YELLOW='\033[0;33m'
              BLUE='\033[0;34m'
              MAGENTA='\033[0;35m'
              CYAN='\033[0;36m'
              BOLD='\033[1m'
              RESET='\033[0m'
              
              # Parse arguments
              while [[ $# -gt 0 ]]; do
                case $1 in
                  -m|--mode)
                    MODE="$2"
                    shift 2
                    ;;
                  -d|--dir)
                    SEARCH_DIR="$2"
                    shift 2
                    ;;
                  -f|--format)
                    OUTPUT_FORMAT="$2"
                    shift 2
                    ;;
                  --threshold)
                    THRESHOLD="$2"
                    shift 2
                    ;;
                  --topk)
                    TOPK="$2"
                    shift 2
                    ;;
                  --readme-mode)
                    README_MODE="$2"
                    shift 2
                    ;;
                  --code-mode)
                    CODE_MODE="$2"
                    shift 2
                    ;;
                  --scope)
                    SCOPE="$2"
                    shift 2
                    ;;
                  --model)
                    MODEL="$2"
                    shift 2
                    ;;
                  --benchmark)
                    BENCHMARK=true
                    shift
                    ;;
                  --benchmark-queries)
                    BENCHMARK_QUERIES="$2"
                    shift 2
                    ;;
                  --precision-k)
                    PRECISION_K="$2"
                    shift 2
                    ;;
                  --recall-k)
                    RECALL_K="$2"
                    shift 2
                    ;;
                  --verbose)
                    VERBOSE=true
                    shift
                    ;;
                  --quiet)
                    QUIET=true
                    shift
                    ;;
                  --color)
                    COLOR="$2"
                    shift 2
                    ;;
                  --no-progress)
                    PROGRESS=false
                    shift
                    ;;
                  -h|--help)
                    usage
                    exit 0
                    ;;
                  -*)
                    echo "Unknown option: $1" >&2
                    usage >&2
                    exit 1
                    ;;
                  *)
                    QUERY="$1"
                    shift
                    ;;
                esac
              done
              
              # Color output configuration
              setup_colors() {
                if [[ "$COLOR" == "never" ]] || ([[ "$COLOR" == "auto" ]] && [[ ! -t 1 ]]); then
                  RED=""
                  GREEN=""
                  YELLOW=""
                  BLUE=""
                  MAGENTA=""
                  CYAN=""
                  BOLD=""
                  RESET=""
                else
                  RED='\033[0;31m'
                  GREEN='\033[0;32m'
                  YELLOW='\033[0;33m'
                  BLUE='\033[0;34m'
                  MAGENTA='\033[0;35m'
                  CYAN='\033[0;36m'
                  BOLD='\033[1m'
                  RESET='\033[0m'
                fi
              }
              
              # Logging functions
              log_info() {
                if [[ "$QUIET" != "true" ]]; then
                  echo "‚ÑπÔ∏è $1" >&2
                fi
              }
              
              log_success() {
                if [[ "$QUIET" != "true" ]]; then
                  echo "‚úÖ $1" >&2
                fi
              }
              
              log_warning() {
                if [[ "$QUIET" != "true" ]]; then
                  echo "‚ö†Ô∏è $1" >&2
                fi
              }
              
              log_error() {
                echo "‚ùå $1" >&2
              }
              
              log_verbose() {
                if [[ "$VERBOSE" == "true" ]]; then
                  echo "üîç $1" >&2
                fi
              }
              
              log_progress() {
                if [[ "$PROGRESS" == "true" ]] && [[ "$QUIET" != "true" ]]; then
                  echo "üîç $1" >&2
                fi
              }
              
              # Initialize colors
              setup_colors
              
              if [[ -z "$QUERY" ]]; then
                echo "Error: Query required" >&2
                usage >&2
                exit 1
              fi
              
              # Display configuration in verbose mode
              if [[ "$VERBOSE" == "true" ]]; then
                log_verbose "Configuration:"
                log_verbose "  Mode: $MODE"
                log_verbose "  Directory: $SEARCH_DIR"
                log_verbose "  Format: $OUTPUT_FORMAT"
                log_verbose "  Scope: $SCOPE"
                log_verbose "  Query: $QUERY"
                [[ -n "$MODEL" ]] && log_verbose "  Model: $MODEL"
                [[ -n "$THRESHOLD" ]] && log_verbose "  Threshold: $THRESHOLD"
                log_verbose "  TopK: $TOPK"
              fi
              
              # Benchmark mode implementation
              if [[ "$BENCHMARK" == "true" ]]; then
                log_progress "Starting benchmark mode"
                
                # Check for benchmark queries file
                if [[ -n "$BENCHMARK_QUERIES" && -f "$BENCHMARK_QUERIES" ]]; then
                  log_info "Using custom benchmark queries from: $BENCHMARK_QUERIES"
                  QUERIES_FILE="$BENCHMARK_QUERIES"
                else
                  # Use default benchmark queries
                  QUERIES_FILE="benchmark/queries.txt"
                  if [[ ! -f "$QUERIES_FILE" ]]; then
                    log_warning "Benchmark queries file not found, using single query: $QUERY"
                    QUERIES=("$QUERY")
                  else
                    log_info "Using default benchmark queries from: $QUERIES_FILE"
                    mapfile -t QUERIES < "$QUERIES_FILE"
                  fi
                fi
                
                # Initialize benchmark results
                BENCHMARK_RESULTS="[]"
                TOTAL_TIME=0
                TOTAL_QUERIES=0
                
                # Run benchmark for each query
                for query in "''${QUERIES[@]}"; do
                  [[ -z "$query" || "$query" =~ ^[[:space:]]*# ]] && continue  # Skip empty lines and comments
                  
                  TOTAL_QUERIES=$((TOTAL_QUERIES + 1))
                  log_progress "Benchmarking query $TOTAL_QUERIES: $query"
                  
                  # Measure response time
                  START_TIME=$(date +%s%N)
                  
                  # Execute search
                  if command -v ck >/dev/null 2>&1; then
                    ck_args=("--jsonl" "--topk" "$TOPK")
                    
                    # Add model and mode-specific args
                    [[ -n "$MODEL" ]] && ck_args+=("--model" "$MODEL")
                    case "$MODE" in
                      "ck-sem"|"semantic") ck_args+=("--sem") ;;
                      "ck-regex") ck_args+=("--regex") ;;
                    esac
                    
                    search_result=$(ck "''${ck_args[@]}" "$query" "$SEARCH_DIR" 2>/dev/null || echo "[]")
                  else
                    search_result="[]"
                  fi
                  
                  END_TIME=$(date +%s%N)
                  RESPONSE_TIME_MS=$(echo "($END_TIME - $START_TIME) / 1000000" | bc -l 2>/dev/null || echo "0")
                  TOTAL_TIME=$(echo "$TOTAL_TIME + $RESPONSE_TIME_MS" | bc -l 2>/dev/null || echo "$TOTAL_TIME")
                  
                  # Calculate result metrics
                  RESULT_COUNT=$(echo "$search_result" | jq length 2>/dev/null || echo "0")
                  
                  # Calculate Precision@K and Recall@K if requested
                  PRECISION_AT_K="null"
                  RECALL_AT_K="null"
                  
                  if [[ -n "$PRECISION_K" && "$PRECISION_K" -gt 0 ]]; then
                    # For demonstration, assume top results are relevant (in real scenario, would use ground truth)
                    RELEVANT_IN_K=$(echo "$search_result" | jq ".[0:$PRECISION_K] | length" 2>/dev/null || echo "0")
                    if [[ "$PRECISION_K" -gt 0 ]]; then
                      PRECISION_AT_K=$(echo "scale=4; $RELEVANT_IN_K / $PRECISION_K" | bc -l 2>/dev/null || echo "0")
                    fi
                  fi
                  
                  if [[ -n "$RECALL_K" && "$RECALL_K" -gt 0 ]]; then
                    # For demonstration, assume total relevant documents = result count (simplified)
                    TOTAL_RELEVANT="$RESULT_COUNT"
                    RELEVANT_IN_K=$(echo "$search_result" | jq ".[0:$RECALL_K] | length" 2>/dev/null || echo "0")
                    if [[ "$TOTAL_RELEVANT" -gt 0 ]]; then
                      RECALL_AT_K=$(echo "scale=4; $RELEVANT_IN_K / $TOTAL_RELEVANT" | bc -l 2>/dev/null || echo "0")
                    fi
                  fi
                  
                  # Add to benchmark results
                  QUERY_RESULT=$(jq -n \
                    --arg query "$query" \
                    --arg response_time_ms "$RESPONSE_TIME_MS" \
                    --arg result_count "$RESULT_COUNT" \
                    --arg precision_at_k "$PRECISION_AT_K" \
                    --arg recall_at_k "$RECALL_AT_K" \
                    '{
                      query: $query,
                      responseTimeMs: ($response_time_ms | tonumber),
                      resultCount: ($result_count | tonumber),
                      precisionAtK: (if $precision_at_k == "null" then null else ($precision_at_k | tonumber) end),
                      recallAtK: (if $recall_at_k == "null" then null else ($recall_at_k | tonumber) end)
                    }')
                  
                  BENCHMARK_RESULTS=$(echo "$BENCHMARK_RESULTS" | jq ". + [$QUERY_RESULT]")
                done
                
                # Calculate aggregate metrics
                if [[ $TOTAL_QUERIES -gt 0 ]]; then
                  AVG_RESPONSE_TIME=$(echo "scale=2; $TOTAL_TIME / $TOTAL_QUERIES" | bc -l 2>/dev/null || echo "0")
                else
                  AVG_RESPONSE_TIME="0"
                fi
                
                # Create benchmark report
                BENCHMARK_REPORT=$(jq -n \
                  --arg timestamp "$(date -Iseconds)" \
                  --arg mode "$MODE" \
                  --arg directory "$SEARCH_DIR" \
                  --arg total_queries "$TOTAL_QUERIES" \
                  --arg avg_response_time_ms "$AVG_RESPONSE_TIME" \
                  --arg topk "$TOPK" \
                  --argjson queries "$BENCHMARK_RESULTS" \
                  '{
                    timestamp: $timestamp,
                    benchmarkConfig: {
                      mode: $mode,
                      directory: $directory,
                      totalQueries: ($total_queries | tonumber),
                      topK: ($topk | tonumber)
                    },
                    aggregateMetrics: {
                      avgResponseTimeMs: ($avg_response_time_ms | tonumber),
                      totalQueries: ($total_queries | tonumber)
                    },
                    queryResults: $queries
                  }')
                
                # Output benchmark results
                if [[ "$OUTPUT_FORMAT" == "json" ]]; then
                  echo "$BENCHMARK_REPORT"
                else
                  echo "Benchmark Results"
                  echo "Generated: $(date -Iseconds)"
                  echo "Mode: $MODE | Directory: $SEARCH_DIR"
                  echo "=========================================="
                  echo "Total Queries: $TOTAL_QUERIES"
                  echo "Average Response Time: ''${AVG_RESPONSE_TIME}ms"
                  [[ -n "$PRECISION_K" ]] && echo "Precision@$PRECISION_K calculated"
                  [[ -n "$RECALL_K" ]] && echo "Recall@$RECALL_K calculated"
                  echo ""
                  echo "Query Results:"
                  echo "$BENCHMARK_REPORT" | jq -r '.queryResults[] | "  Query: \(.query)\n  Response Time: \(.responseTimeMs)ms\n  Results: \(.resultCount)\n"'
                fi
                
                log_success "Benchmark completed successfully"
              else
                # Regular search mode
                log_progress "Starting search with mode: $MODE"
                
                # Check if ck is available
                if command -v ck >/dev/null 2>&1; then
                  log_success "ck is available: $(command -v ck)"
                  
                  # Build ck command
                  ck_args=("--jsonl" "--topk" "$TOPK")
                  
                  # Add model if specified
                  if [[ -n "$MODEL" ]]; then
                    case "$MODEL" in
                      "nomic-embed-text"|"nomic-multilingual"|"sentence-transformers")
                        ck_args+=("--model" "$MODEL")
                        log_verbose "Using model: $MODEL"
                        ;;
                      *)
                        log_warning "Unknown model '$MODEL', using default"
                        ;;
                    esac
                  fi
                  
                  # Add mode-specific args
                  case "$MODE" in
                    "pipeline")
                      # Pipeline mode: Stage1 (README) -> Stage2 (Code)
                      log_progress "Pipeline Mode: Stage1 - README search for directory filtering"
                      
                      # Stage1: Use search-optimized to get candidate directories
                      if command -v search-optimized >/dev/null 2>&1; then
                        stage1_result=$(search-optimized -f json "$QUERY" "$SEARCH_DIR" 2>/dev/null || echo "[]")
                        # Validate JSON format
                        if ! echo "$stage1_result" | jq . >/dev/null 2>&1; then
                          log_warning "Stage1 returned invalid JSON, using fallback"
                          stage1_result="[]"
                        fi
                      else
                        log_warning "search-optimized not available, using fallback"
                        stage1_result="[]"
                      fi
                      
                      # Extract unique directories from Stage1 results
                      candidate_dirs=$(echo "$stage1_result" | jq -r '.[].dir // empty' 2>/dev/null | sort -u | head -10 || echo "")
                      
                      if [[ -n "$candidate_dirs" && "$candidate_dirs" != "" ]]; then
                        log_progress "Stage1 found $(echo "$candidate_dirs" | wc -l) candidate directories"
                        
                        # Stage2: Run ck on filtered directories
                        log_progress "Pipeline Mode: Stage2 - Code search in filtered directories"
                        stage2_dirs=()
                        while IFS= read -r dir; do
                          [[ -n "$dir" && -d "$dir" ]] && stage2_dirs+=("$dir")
                        done <<< "$candidate_dirs"
                        
                        if [[ ''${#stage2_dirs[@]} -gt 0 ]]; then
                          stage2_result=$(ck "''${ck_args[@]}" "$QUERY" "''${stage2_dirs[@]}" 2>/dev/null || echo "[]")
                        else
                          stage2_result="[]"
                        fi
                      else
                        log_warning "Stage1 returned no candidates, falling back to full search"
                        candidate_dirs=""
                        stage2_result=$(ck "''${ck_args[@]}" "$QUERY" "$SEARCH_DIR" 2>/dev/null || echo "[]")
                      fi
                      
                      # Combine results into single JSON with error handling
                      stage1_count=$(echo "$stage1_result" | jq 'length' 2>/dev/null || echo "0")
                      search_result=$(jq -n \
                        --argjson readme_results "$stage1_result" \
                        --argjson code_results "$stage2_result" \
                        --arg dirs "$candidate_dirs" \
                        --argjson stage1_meta "$stage1_count" \
                        '{
                          readmeResults: $readme_results,
                          codeResults: $code_results,
                          explain: {
                            dirs: ($dirs | split("\n") | map(select(length > 0))),
                            stage1: {
                              candidateCount: $stage1_meta,
                              fallbackUsed: ($dirs == "")
                            }
                          }
                        }' 2>/dev/null || echo '{"readmeResults":[],"codeResults":[],"explain":{"dirs":[],"stage1":{"candidateCount":0,"fallbackUsed":true}}}')
                      ;;
                    "ck-sem"|"semantic")
                      ck_args+=("--sem")
                      ;;
                    "ck-regex")
                      ck_args+=("--regex")
                      ;;
                    "ck-hybrid")
                      ck_args+=("--hybrid")
                      ;;
                    "bm25")
                      # Default mode - no special flags needed
                      ;;
                  esac
                  
                  # Execute search for non-pipeline modes with SCOPE support
                  if [[ "$MODE" != "pipeline" ]]; then
                    case "$SCOPE" in
                      "readme")
                        log_progress "README-only search: Finding readme.nix files"
                        readme_files=()
                        if command -v rg >/dev/null 2>&1; then
                          mapfile -t readme_files < <(rg --files -g '**/readme.nix' "$SEARCH_DIR" 2>/dev/null)
                        else
                          mapfile -t readme_files < <(find "$SEARCH_DIR" -name "readme.nix" -type f 2>/dev/null)
                        fi
                        
                        if [[ ''${#readme_files[@]} -gt 0 ]]; then
                          log_progress "Executing README search: ck ''${ck_args[*]} \"$QUERY\" on ''${#readme_files[@]} files"
                          search_result=$(ck "''${ck_args[@]}" "$QUERY" "''${readme_files[@]}" 2>/dev/null || echo "[]")
                        else
                          log_warning "No README files found in $SEARCH_DIR"
                          search_result="[]"
                        fi
                        ;;
                      "code")
                        log_progress "Code-only search: Executing: ck ''${ck_args[*]} \"$QUERY\" \"$SEARCH_DIR\""
                        search_result=$(ck "''${ck_args[@]}" "$QUERY" "$SEARCH_DIR" 2>/dev/null || echo "[]")
                        ;;
                      "all"|*)
                        log_progress "Full search: Executing: ck ''${ck_args[*]} \"$QUERY\" \"$SEARCH_DIR\""
                        search_result=$(ck "''${ck_args[@]}" "$QUERY" "$SEARCH_DIR" 2>/dev/null || echo "[]")
                        ;;
                    esac
                  fi
                  
                  # Format output
                  if [[ "$OUTPUT_FORMAT" == "json" ]]; then
                    echo "$search_result"
                  else
                    # Text format
                    result_count=$(echo "$search_result" | jq length)
                    echo "Search Results for: '$QUERY'"
                    echo "Mode: $MODE | Directory: $SEARCH_DIR | Scope: $SCOPE"
                    echo "=========================================="
                    echo "Found $result_count results"
                    echo ""
                    
                    echo "$search_result" | jq -r '.[] | "üîç " + .path + "\n   Score: " + (.score | tostring) + "\n   Content: " + .content + "\n"'
                  fi
                  
                  log_success "Search completed successfully"
                else
                  log_error "ck command not available. Please ensure ck is installed."
                  exit 1
                fi
              fi
            '';
          };

          # Simple test harness for minimal ck wrapper (30 lines) 
          test-harness = import ./simple-test-harness.nix { inherit pkgs self system; };

          # Minimal ck wrapper specification test„ÄêRED‚ÜíGREEN„Äë
          test-minimal-ck-wrapper = pkgs.runCommand "minimal-ck-wrapper-spec-test"
          {
            buildInputs = with pkgs; [ jq bash coreutils (ck-local.packages.${system}.default or ck-local.defaultPackage.${system} or (throw "ck package not available")) ];
            NIX_CONFIG = "experimental-features = nix-command flakes";
          } ''
            set -euo pipefail
            
            echo "üß™ Testing minimal ck wrapper specification..."
            
            # ‰ªïÊßò1: ÊúÄÂ∞èÈôêck„É©„ÉÉ„Éë„Éº„ÅåÂ≠òÂú®„Åô„ÇãÔºà50Ë°å‰ª•‰∏ãÔºâ
            echo "Spec 1: Minimal ck wrapper exists (‚â§50 lines)"
            if nix build ${self}#packages.${system}.minimal-ck-wrapper -o minimal-wrapper 2>/dev/null; then
              WRAPPER_LINES=$(wc -l < minimal-wrapper/bin/search-readme)
              if [ "$WRAPPER_LINES" -le 50 ]; then
                add_test_result "minimal-wrapper-size" "pass"
              else
                add_test_result "minimal-wrapper-size" "fail" "Wrapper has $WRAPPER_LINES lines (expected ‚â§50)"
              fi
            else
              add_test_result "minimal-wrapper-size" "fail" "minimal-ck-wrapper package does not exist"
            fi
            
            # ‰ªïÊßò2: ck„ÉÑ„Éº„É´„Å∏„ÅÆÁ¥îÁ≤ã„Å™ÂßîË≠≤ÔºàÁã¨Ëá™Ê§úÁ¥¢„É≠„Ç∏„ÉÉ„ÇØ„Å™„ÅóÔºâ
            echo "Spec 2: Pure ck delegation (no custom search logic)"
            if WRAPPER_SOURCE=$(cat minimal-wrapper/bin/search-readme 2>/dev/null); then
              if echo "$WRAPPER_SOURCE" | grep -q "ck.*--output.*json" && ! echo "$WRAPPER_SOURCE" | grep -qE "(jq.*search|scoring|bm25.*[0-9]+)"; then
                add_test_result "pure-ck-delegation" "pass"
              else
                add_test_result "pure-ck-delegation" "fail" "Wrapper contains custom search logic instead of pure ck delegation"
              fi
            else
              add_test_result "pure-ck-delegation" "fail" "Cannot read wrapper source"
            fi
            
            # ‰ªïÊßò3: SCOPE„Ç™„Éó„Ç∑„Éß„É≥Ôºà--scope readme/code/allÔºâ
            echo "Spec 3: SCOPE option support"
            for scope in readme code all; do
              if OUTPUT=$(./minimal-wrapper/bin/search-readme --scope "$scope" "test" . 2>/dev/null); then
                if echo "$OUTPUT" | jq -e '.[0].scope' >/dev/null 2>&1; then
                  ACTUAL_SCOPE=$(echo "$OUTPUT" | jq -r '.[0].scope')
                  if [ "$ACTUAL_SCOPE" = "$scope" ]; then
                    add_test_result "scope-$scope" "pass"
                  else
                    add_test_result "scope-$scope" "fail" "Expected scope '$scope', got '$ACTUAL_SCOPE'"
                  fi
                else
                  add_test_result "scope-$scope" "fail" "Output missing scope field"
                fi
              else
                add_test_result "scope-$scope" "fail" "Command failed for scope '$scope'"
              fi
            done
            
            # ‰ªïÊßò4: „Éë„Ç§„Éó„É©„Ç§„É≥„É¢„Éº„ÉâÔºàREADME‚Üí„Ç≥„Éº„Éâ2ÊÆµÈöéÊ§úÁ¥¢Ôºâ
            echo "Spec 4: Pipeline mode (README‚Üícode 2-stage search)"
            if PIPELINE_OUTPUT=$(./minimal-wrapper/bin/search-readme --mode pipeline "test" . 2>/dev/null); then
              if echo "$PIPELINE_OUTPUT" | jq -e '.stage1' >/dev/null 2>&1 && \
                 echo "$PIPELINE_OUTPUT" | jq -e '.stage2' >/dev/null 2>&1; then
                add_test_result "pipeline-mode" "pass"
              else
                add_test_result "pipeline-mode" "fail" "Pipeline output missing stage1/stage2"
              fi
            else
              add_test_result "pipeline-mode" "fail" "Pipeline mode command failed"
            fi
            
            # ‰ªïÊßò5: ck„ÅÆÁúü„ÅÆBM25‰ΩøÁî®ÔºàTantivy„Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâÔºâ
            echo "Spec 5: Actual ck BM25 usage (Tantivy backend)"
            if BM25_OUTPUT=$(./minimal-wrapper/bin/search-readme --mode hybrid "test" . 2>/dev/null); then
              if echo "$BM25_OUTPUT" | jq -e '.[0].score' >/dev/null 2>&1; then
                add_test_result "true-bm25" "pass"
              else
                add_test_result "true-bm25" "fail" "BM25 output missing score field"
              fi
            else
              add_test_result "true-bm25" "fail" "BM25 mode command failed"
            fi
            
            # Generate final test report
            TOTAL_TESTS=$(echo "$TEST_RESULTS" | jq 'length')
            PASSED_TESTS=$((TOTAL_TESTS - FAILED_TESTS))
            
            echo ""
            echo "üìä Test Summary:"
            echo "Total tests: $TOTAL_TESTS"
            echo "Passed: $PASSED_TESTS"
            echo "Failed: $FAILED_TESTS"
            
            # Generate JSON report
            cat > "$out" <<EOF
          {
            "status": "$([ $FAILED_TESTS -eq 0 ] && echo "success" || echo "failure")",
            "tests": $TEST_RESULTS,
            "summary": {
              "total": $TOTAL_TESTS,
              "passed": $PASSED_TESTS,
              "failed": $FAILED_TESTS
            },
            "specification": {
              "description": "Minimal ck wrapper with SCOPE and pipeline functionality",
              "target_lines": 50,
              "required_features": ["scope_option", "pipeline_mode", "pure_ck_delegation", "true_bm25"]
            }
          }
          EOF
            
            echo "‚ú® Minimal ck wrapper specification test completed"
            
            # Pass if all tests passed (GREEN phase validation)
            if [ $FAILED_TESTS -gt 0 ]; then
              echo "‚ùå Specification test FAILED - $FAILED_TESTS test(s) failed"
              exit 1
            else
              echo "‚úÖ Specification test PASSED - minimal wrapper correctly implemented"
            fi
          '';

          # Minimal ck wrapper (50 lines max, pure ck delegation)
          minimal-ck-wrapper = pkgs.writeShellApplication {
            name = "search-readme";
            runtimeInputs = with pkgs; [ 
              ck-local.packages.${system}.default or ck-local.defaultPackage.${system} or (throw "ck package not available")
              jq
              coreutils
              ripgrep
              findutils
            ];
            text = ''
              set -euo pipefail
              
              # Parse arguments for SCOPE and MODE
              SCOPE="all"
              MODE="hybrid"
              CK_ARGS=()
              
              while [[ $# -gt 0 ]]; do
                case $1 in
                  --scope)
                    SCOPE="$2"
                    shift 2
                    ;;
                  --mode)
                    MODE="$2"
                    shift 2
                    ;;
                  *)
                    CK_ARGS+=("$1")
                    shift
                    ;;
                esac
              done
              
              # SCOPE functionality: filter files based on scope
              if [[ "$SCOPE" == "readme" ]]; then
                CK_ARGS+=("--glob" "**/readme.nix")
              elif [[ "$SCOPE" == "code" ]]; then
                CK_ARGS+=("--glob" "**/*.{rs,go,py,js,ts,nix}" "--glob" "!**/readme.nix")
              fi
              
              # Pipeline mode: two-stage README‚Üícode search
              if [[ "$MODE" == "pipeline" ]]; then
                QUERY="''${CK_ARGS[-1]}"
                unset 'CK_ARGS[-1]'
                
                # Stage1: README search
                STAGE1=$(ck --json --glob "**/readme.nix" "''${CK_ARGS[@]}" "$QUERY" | jq '[.[] | . + {"scope": "readme"}]')
                
                # Stage2: Code search in directories from stage1
                DIRS=$(echo "$STAGE1" | jq -r '.[].file | split("/") | .[:-1] | join("/")' | sort -u)
                STAGE2="[]"
                while IFS= read -r dir; do
                  [[ -n "$dir" ]] && STAGE2=$(ck --json --glob "**/*.{rs,go,py,js,ts,nix}" --glob "!**/readme.nix" "''${CK_ARGS[@]}" "$QUERY" "$dir" | jq '[.[] | . + {"scope": "code"}]' | jq -s 'add // []' <(echo "$STAGE2") -)
                done <<< "$DIRS"
                
                # Pipeline output
                jq -n --argjson stage1 "$STAGE1" --argjson stage2 "$STAGE2" '{"stage1": $stage1, "stage2": $stage2}'
              else
                # Pure ck delegation with scope
                RESULT=$(ck --json "''${CK_ARGS[@]}")
                echo "$RESULT" | jq --arg scope "$SCOPE" '[.[] | . + {"scope": $scope}]'
              fi
            '';
          };

          # Simple test harness specification (CHARACTERIZE phase)
          test-simple-harness-spec = import ./test-simple-harness-spec.nix {
            inherit pkgs self system;
          };

          # Simple apps specification (CHARACTERIZE phase)
          test-simple-apps-spec = import ./test-simple-apps-spec.nix {
            inherit pkgs self system;
          };
        };

        # Development shell
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            nix
            jq
            coreutils
            ck-local.packages.${system}.default or ck-local.defaultPackage.${system} or (throw "ck package not available for development shell")
          ];
          
          NIX_CONFIG = "experimental-features = nix-command flakes";
          
          shellHook = ''
            echo "üîç Search README development environment"
            echo "Available tools:"
            echo "  - nix: $(nix --version)"
            echo "  - jq: $(jq --version)"
            echo "  - ck: $(ck --version 2>/dev/null || echo "ck not available")"
          '';
        };

        # Applications
        apps = {
          default = {
            type = "app";
            program = "${self'.packages.minimal-ck-wrapper}/bin/search-readme";
          };
          
          test = {
            type = "app";
            program = "${self'.packages.test-harness}/bin/test-harness";
          };
        };

        # Robust checks for CI/CD
        checks = {
          # Flake check
          flake-check = pkgs.runCommand "flake-check"
            {
              buildInputs = with pkgs; [ nix ];
              NIX_CONFIG = "experimental-features = nix-command flakes";
            } ''
            set -euo pipefail
            echo "üîç Running flake check..."
            
            # Create a temporary flake directory
            mkdir -p /tmp/flake-test
            cp -r ${self}/* /tmp/flake-test/ 2>/dev/null || true
            cd /tmp/flake-test
            
            # Run flake check with offline consideration
            if nix flake check --no-build 2>&1; then
              echo "‚úì Flake check passed"
            else
              echo "‚ùå Flake check failed"
              exit 1
            fi
            
            touch $out
          '';

          # Test harness validation
          test-validation = self'.packages.test-harness;

          # Package build test
          package-build = self'.packages.default;

          # Minimal ck wrapper specification test (should fail initially - RED phase)
          minimal-ck-wrapper-spec = self'.packages.test-minimal-ck-wrapper;

          # Deletion targets characterization test (CHARACTERIZE phase)
          deletion-targets = import ./test-deletion-targets.nix {
            inherit pkgs self system;
          };
        };
      };

      # Global flake outputs
      flake = {
        # Library functions for external use
        lib = {
          searchReadme = {
            # Utility functions for README searching
            findReadmeFiles = root: 
              let
                lib = nixpkgs.lib;
                allFiles = lib.filesystem.listFilesRecursive root;
              in
              builtins.filter (path: lib.hasSuffix "README.md" (toString path) || lib.hasSuffix "readme.md" (toString path)) allFiles;
          };
        };

        # Templates for project initialization
        templates = {
          default = {
            path = ./.;
            description = "Search-readme project template with comprehensive search capabilities";
            welcomeText = ''
              # Search README Template
              
              This template provides a complete README search system with:
              - Multi-mode search (BM25, semantic, optimized)
              - Performance benchmarking and metrics
              - Health monitoring and reporting
              - Comprehensive testing framework
              
              ## Getting Started
              
              1. Run basic search: `nix run . -- "your query"`
              2. Generate health report: `nix run .#report`
              3. Run performance benchmark: `nix run . -- --benchmark "test"`
              4. Use optimized search: `nix run .#optimized -- "framework"`
              
              See README.md for detailed usage instructions.
            '';
          };
        };
      };
    };
}