{
  description = "Search README project - flake-parts based foundation with robust testing";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-parts.url = "github:hercules-ci/flake-parts";
    
    # flake-readme integration for structured documentation collection
    flake-readme = {
      url = "path:../flake-readme";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    
    # Multiple ck dependency resolution routes (Priority: local flake > GitHub > crates.io > nixpkgs fallback)
    # 1. Local ck flake (highest priority - working implementation)
    ck-local = {
      url = "path:../../flakes/ck";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    
    # 2. GitHub source (future support when available)
    # ck-github = {
    #   url = "github:BeaconBay/ck";
    #   inputs.nixpkgs.follows = "nixpkgs";
    # };
    
    # 3. Crates.io fallback (can be enabled if GitHub source becomes unavailable)
    # ck-crates = {
    #   url = "crate:ck/0.4.5";  # Match current version
    #   inputs.nixpkgs.follows = "nixpkgs";
    # };
  };

  outputs = inputs@{ self, nixpkgs, flake-parts, flake-readme, ck-local, ... }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];

      perSystem = { config, self', inputs', pkgs, system, ... }: 
      let
        # Import core-docs.nix library from flake-readme
        docs = import "${flake-readme}/lib/core-docs.nix" { 
          lib = pkgs.lib; 
          self = self; 
        };
        
        # Robust ck dependency resolution with multiple fallback strategies
        ckPackage = 
          # 1. Local ck flake (highest priority)
          if inputs' ? ck-local && inputs'.ck-local ? packages && inputs'.ck-local.packages ? default
          then inputs'.ck-local.packages.default
          # 2. GitHub source fallback (when available)
          else if inputs' ? ck-github && inputs'.ck-github ? packages && inputs'.ck-github.packages ? default
          then inputs'.ck-github.packages.default
          # 3. Crates.io fallback (when available)
          else if inputs' ? ck-crates && inputs'.ck-crates ? packages && inputs'.ck-crates.packages ? default
          then inputs'.ck-crates.packages.default
          # 4. nixpkgs fallback (pkgs.ck-search if available)
          else if pkgs ? ck-search
          then pkgs.ck-search
          # 5. PATH detection fallback (minimal functionality)
          else null;
      in {
        # Package definitions
        packages = {
          default = pkgs.writeShellApplication {
            name = "search-readme";
            runtimeInputs = with pkgs; [ 
              coreutils 
              jq
              nix
              ripgrep
              findutils
              gawk
            ] ++ pkgs.lib.optionals (ckPackage != null) [ ckPackage ];
            text = ''
              set -euo pipefail
              export NIX_CONFIG="experimental-features = nix-command flakes"
              
              # README Search Engine with ck Integration
              # Supports readme.nix limited search, BM25 and semantic search modes
              # Includes robust ck (semantic search) integration with multiple fallback strategies
              
              # ck Wrapper Functions - Robust ck dependency resolution and validation
              detect_ck() {
                # Try to detect ck through multiple strategies
                local ck_path=""
                
                # 1. Check if ck is in PATH (from nix runtime inputs)
                if command -v ck >/dev/null 2>&1; then
                  ck_path="ck"
                else
                  # 2. PATH detection fallback - check common locations
                  for path in "/usr/local/bin/ck" "/usr/bin/ck" "$HOME/.cargo/bin/ck" "$HOME/.local/bin/ck"; do
                    if [[ -x "$path" ]]; then
                      ck_path="$path"
                      break
                    fi
                  done
                fi
                
                echo "$ck_path"
              }
              
              # Validate ck installation with --version check
              validate_ck() {
                local ck_path="$1"
                if [[ -z "$ck_path" ]]; then
                  return 1
                fi
                
                # Test --version to ensure ck is working
                if "$ck_path" --version >/dev/null 2>&1; then
                  return 0
                else
                  return 1
                fi
              }
              
              # Smoke test ck with --jsonl output to ensure JSONL functionality works
              smoke_test_ck() {
                local ck_path="$1"
                local test_dir="$2"
                
                if [[ -z "$ck_path" ]] || [[ ! -d "$test_dir" ]]; then
                  return 1
                fi
                
                # Try a simple --jsonl search to validate JSONL output functionality
                if echo '{}' | "$ck_path" --jsonl "test" --topk 1 "$test_dir" >/dev/null 2>&1; then
                  return 0
                else
                  return 1
                fi
              }
              
              # JSONLâ†’Nix structure parser for ck output
              parse_ck_jsonl() {
                local jsonl_output="$1"
                local query="$2"
                
                # Parse ck JSONL output and convert to search-readme compatible JSON structure
                echo "$jsonl_output" | jq -s '[.[] | {
                  dir: (.path | split("/") | .[:-1] | join("/")),
                  kind: "code",
                  field: "content",
                  snippet: .snippet // (.path + ":" + (.span.line_start | tostring)),
                  score: (.score * 100 | round),
                  file: .path,
                  ck_metadata: {
                    byte_start: .span.byte_start,
                    byte_end: .span.byte_end,
                    line_start: .span.line_start,
                    line_end: .span.line_end,
                    language: .language
                  }
                }]'
              }
              
              # Enhanced code search interface using ck with failsafe support
              search_code_with_ck() {
                local query="$1"
                local directories="$2"  # JSON array of directory paths
                local mode="$3"         # regex, sem, or hybrid
                local ck_path="$4"
                local relaxation_stage="''${5:-0}"  # 0=normal, 1-4=relaxation stages
                
                if [[ -z "$ck_path" ]]; then
                  echo "[]"
                  return 0
                fi
                
                # Stage-based topk configuration (progressively more results)
                local topk=10
                case "$relaxation_stage" in
                  1) topk=20 ;;      # Stage 2: 2x topk
                  2) topk=40 ;;      # Stage 2: 4x topk  
                  3|4) topk=80 ;;    # Stage 3+: 8x topk for maximum recall
                esac
                
                local ck_args=("--jsonl" "--topk" "$topk")
                
                # Configure ck mode
                case "$mode" in
                  "semantic"|"sem")
                    ck_args+=("--sem")
                    ;;
                  "regex")
                    ck_args+=("--regex")
                    ;;
                  "hybrid")
                    # ck default behavior (hybrid semantic + text)
                    ;;
                esac
                
                # Add model selection if specified
                if [[ -n "$MODEL" ]]; then
                  case "$MODEL" in
                    "nomic-embed-text"|"nomic-multilingual"|"sentence-transformers")
                      ck_args+=("--model" "$MODEL")
                      log_verbose "Using model: $MODEL"
                      ;;
                    *)
                      log_warning "Unknown model '$MODEL', using default"
                      ;;
                  esac
                fi
                
                # Add custom topk if specified globally
                if [[ -n "$TOPK" ]]; then
                  ck_args=("--jsonl" "--topk" "$TOPK")
                  log_verbose "Using custom topk: $TOPK"
                fi
                
                # Process directory list (assume JSON array)
                local search_dirs
                search_dirs=$(echo "$directories" | jq -r '.[]?' 2>/dev/null || echo ".")
                
                local all_results=""
                
                # Search each directory and collect results
                while IFS= read -r dir; do
                  if [[ -n "$dir" ]] && [[ -d "$dir" ]]; then
                    local ck_output
                    ck_output=$("$ck_path" "''${ck_args[@]}" "$query" "$dir" 2>/dev/null || echo "")
                    
                    if [[ -n "$ck_output" ]]; then
                      local parsed_results
                      parsed_results=$(parse_ck_jsonl "$ck_output" "$query")
                      
                      # Add relaxation stage metadata to results
                      parsed_results=$(echo "$parsed_results" | jq --argjson stage "$relaxation_stage" 'map(. + {relaxationStage: $stage})')
                      
                      if [[ "$all_results" == "" ]]; then
                        all_results="$parsed_results"
                      else
                        # Merge JSON arrays
                        all_results=$(echo "$all_results $parsed_results" | jq -s 'add')
                      fi
                    fi
                  fi
                done <<< "$search_dirs"
                
                # Sort by score descending and return
                echo "$all_results" | jq 'sort_by(-.score)'
              }
              
              # Structured Failsafe Code Search Engine with ck
              search_code_with_ck_failsafe() {
                local query="$1"
                local directories="$2"
                local mode="$3"
                local ck_path="$4"
                local explain="''${5:-false}"
                
                if [[ -z "$ck_path" ]]; then
                  echo '{"results": [], "failsafe": {"stageUsed": -1, "fallbackTriggered": true, "log": ["ck not available"], "totalStages": 5}}'
                  return 0
                fi
                
                local failsafe_log=()
                local final_results='[]'
                local stage_used=0
                local fallback_triggered=false
                
                # Stage 0: Normal search (topk=10)
                echo "ðŸ” Code Failsafe Stage 0: Normal search (topk=10)..." >&2
                final_results=$(search_code_with_ck "$query" "$directories" "$mode" "$ck_path" 0)
                local stage0_count=$(echo "$final_results" | jq 'length')
                
                failsafe_log+=("Stage 0 (Normal): $stage0_count results with topk=10")
                
                if [[ "$stage0_count" -gt 0 ]]; then
                  stage_used=0
                  echo "âœ… Code Stage 0 successful: $stage0_count results found" >&2
                else
                  # Stage 1: Increase topk (2x)
                  echo "âš ï¸ Code Stage 0 failed, trying Stage 1: Increase topk (2x)..." >&2
                  final_results=$(search_code_with_ck "$query" "$directories" "$mode" "$ck_path" 1)
                  local stage1_count=$(echo "$final_results" | jq 'length')
                  
                  failsafe_log+=("Stage 1 (Topk 2x): $stage1_count results with topk=20")
                  
                  if [[ "$stage1_count" -gt 0 ]]; then
                    stage_used=1
                    fallback_triggered=true
                    echo "âœ… Code Stage 1 successful: $stage1_count results found" >&2
                  else
                    # Stage 2: Further increase topk (4x)
                    echo "âš ï¸ Code Stage 1 failed, trying Stage 2: Increase topk (4x)..." >&2
                    final_results=$(search_code_with_ck "$query" "$directories" "$mode" "$ck_path" 2)
                    local stage2_count=$(echo "$final_results" | jq 'length')
                    
                    failsafe_log+=("Stage 2 (Topk 4x): $stage2_count results with topk=40")
                    
                    if [[ "$stage2_count" -gt 0 ]]; then
                      stage_used=2
                      fallback_triggered=true
                      echo "âœ… Code Stage 2 successful: $stage2_count results found" >&2
                    else
                      # Stage 3: Mode switching (try hybrid if not already)
                      local fallback_mode="hybrid"
                      if [[ "$mode" == "hybrid" ]]; then
                        fallback_mode="semantic"
                      fi
                      
                      echo "âš ï¸ Code Stage 2 failed, trying Stage 3: Mode switch to $fallback_mode..." >&2
                      final_results=$(search_code_with_ck "$query" "$directories" "$fallback_mode" "$ck_path" 3)
                      local stage3_count=$(echo "$final_results" | jq 'length')
                      
                      failsafe_log+=("Stage 3 (Mode switch to $fallback_mode): $stage3_count results with topk=80")
                      
                      if [[ "$stage3_count" -gt 0 ]]; then
                        stage_used=3
                        fallback_triggered=true
                        echo "âœ… Code Stage 3 successful: $stage3_count results found" >&2
                      else
                        # Stage 4: Final fallback (broader directory search)
                        echo "âš ï¸ Code Stage 3 failed, trying Stage 4: Final fallback (broader search)..." >&2
                        
                        # Expand directories to include parent directories
                        local expanded_dirs
                        expanded_dirs=$(echo "$directories" | jq -r '.[]' | while IFS= read -r dir; do
                          echo "\"$dir\""
                          if [[ -d "$dir/.." ]]; then
                            echo "\"$(readlink -f "$dir/..")\""
                          fi
                        done | jq -s .)
                        
                        final_results=$(search_code_with_ck "$query" "$expanded_dirs" "hybrid" "$ck_path" 4)
                        local stage4_count=$(echo "$final_results" | jq 'length')
                        
                        failsafe_log+=("Stage 4 (Broader search): $stage4_count results with expanded directories")
                        
                        if [[ "$stage4_count" -gt 0 ]]; then
                          stage_used=4
                          fallback_triggered=true
                          echo "âœ… Code Stage 4 successful: $stage4_count results found" >&2
                        else
                          stage_used=4
                          fallback_triggered=true
                          echo "âŒ All code stages failed: No results found even with maximum relaxation" >&2
                        fi
                      fi
                    fi
                  fi
                fi
                
                # Create structured output with failsafe metadata
                local output
                output=$(jq -n \
                  --argjson results "$final_results" \
                  --argjson stageUsed "$stage_used" \
                  --argjson fallbackTriggered "$fallback_triggered" \
                  --argjson failsafeLog "$(printf '%s\n' "''${failsafe_log[@]}" | jq -R . | jq -s .)" \
                  '{
                    results: $results,
                    failsafe: {
                      stageUsed: $stageUsed,
                      fallbackTriggered: $fallbackTriggered,
                      log: $failsafeLog,
                      totalStages: 5
                    }
                  }')
                
                if [[ "$explain" == "true" ]]; then
                  echo "$output"
                else
                  echo "$output" | jq '.results'
                fi
              }
              
              # Initialize ck system with robust error handling
              CK_PATH=""
              CK_AVAILABLE=false
              
              if CK_PATH=$(detect_ck) && [[ -n "$CK_PATH" ]]; then
                if validate_ck "$CK_PATH"; then
                  CK_AVAILABLE=true
                  log_success "ck detected and validated: $CK_PATH"
                else
                  log_warning "ck found but validation failed"
                fi
              else
                log_info "ck not available - falling back to text-only search modes"
              fi
              
              usage() {
                echo "Usage: $0 [options] <query>"
                echo "Options:"
                echo "  -m, --mode MODE       Search mode: bm25 (default), semantic, ck-sem, ck-regex, ck-hybrid, pipeline"
                echo "  -d, --dir DIR         Search directory (default: current)"
                echo "  -f, --format FORMAT   Output format: text (default), json"
                echo "  --dirs-json JSON      Search multiple directories (JSON array)"
                echo "  --explain            Show pipeline explanation (with pipeline mode)"
                echo "  --failsafe           Enable structured failsafe mode (4-stage progressive relaxation)"
                echo "  --stage1-mode MODE   README search mode for pipeline (default: bm25)"
                echo "  --stage2-mode MODE   Code search mode for pipeline (default: ck-sem)"
                echo "  --max-dirs N         Maximum directories from Stage 1 for Stage 2 (default: 5)"
                echo ""
                echo "Enhanced CLI Options:"
                echo "  --threshold N        Custom scoring threshold (0.0-1.0)"
                echo "  --topk N            Maximum number of results to return"
                echo "  --readme-mode MODE  Override README search mode"
                echo "  --code-mode MODE    Override code search mode"
                echo "  --scope SCOPE       Search scope: code|readme|all (default: all)"
                echo "  --model MODEL       Model for semantic search: nomic-embed-text|nomic-multilingual|sentence-transformers"
                echo ""
                echo "Output Control:"
                echo "  --verbose           Enable verbose output with detailed information"
                echo "  --quiet             Suppress progress and info messages"
                echo "  --color MODE        Color output: auto|always|never (default: auto)"
                echo "  --no-progress       Disable progress indicators"
                echo "  -h, --help           Show this help"
                echo ""
                echo "Search Modes:"
                echo "  bm25        - Text frequency-based scoring with field bonuses (README only)"
                echo "  semantic    - Simplified semantic search (README only)"
                echo "  ck-sem      - ck semantic search (code files, requires ck)"
                echo "  ck-regex    - ck regex search (code files, requires ck)"
                echo "  ck-hybrid   - ck hybrid semantic+text search (code files, requires ck)"
                echo "  pipeline    - Two-stage search: README -> filtered directory ck search"
                echo ""
                echo "Failsafe Features:"
                echo "  --failsafe          - Enable 4-stage progressive relaxation for zero-result recovery"
                echo "    Stage 1: Threshold relaxation (0.5x, 0.25x scoring weights)"
                echo "    Stage 2: Topk expansion (2x, 4x result limits)"  
                echo "    Stage 3: Filterâ†’Priority mode switch (fuzzy matching)"
                echo "    Stage 4: Final fallback (maximum relaxation + hybrid search)"
                echo ""
                echo "ck Integration Status: $(if [[ "$CK_AVAILABLE" == "true" ]]; then echo "âœ“ Available"; else echo "âœ— Not available"; fi)"
                echo ""
                echo "Examples:"
                echo "  $0 \"search term\"                              # BM25 README search in current directory"
                echo "  $0 -m semantic \"search term\"                  # Semantic README search"
                echo "  $0 -m ck-sem \"function auth\"                  # ck semantic code search"
                echo "  $0 -m pipeline \"web framework\"                # Two-stage pipeline search"
                echo "  $0 -m pipeline --explain \"auth function\"      # Pipeline with explanation"
                echo "  $0 -m pipeline --stage1-mode semantic \"data\"  # Pipeline with semantic README stage"
                echo "  $0 --failsafe \"nonexistent concept\"           # Failsafe mode for zero-result recovery"
                echo "  $0 -m pipeline --failsafe --explain \"missing\" # Full failsafe pipeline with explanation"
                echo "  $0 -f json \"search term\"                      # JSON output"
                echo "  $0 -d /path/to/dir \"search term\"              # Search specific directory"
                echo "  $0 --dirs-json '[\"dir1\",\"dir2\"]' \"term\"     # Search multiple directories"
                echo ""
                echo "Enhanced Examples:"
                echo "  $0 --scope readme \"database\"                  # Search only README files"
                echo "  $0 --scope code \"function\"                    # Search only code files"
                echo "  $0 --threshold 0.7 --topk 10 \"framework\"      # Custom threshold and result limit"
                echo "  $0 --model nomic-multilingual \"ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯\" # Japanese search with multilingual model"
                echo "  $0 --readme-mode semantic --code-mode ck-hybrid \"auth\" # Custom mode overrides"
                echo "  $0 --verbose --color always \"search term\"     # Verbose output with colors"
                echo "  $0 --quiet --no-progress \"search term\"        # Silent mode"
                echo "  $0 -m pipeline --topk 20 --verbose \"web app\"  # Pipeline with custom settings"
              }
              
              # Default values
              MODE="bm25"
              SEARCH_DIR="."
              OUTPUT_FORMAT="text"
              QUERY=""
              DIRS_JSON=""  # For multiple directory search
              EXPLAIN=false
              FAILSAFE=false  # Structured failsafe mode
              STAGE1_MODE="bm25"
              STAGE2_MODE="ck-sem"
              MAX_DIRS=5
              
              # New CLI options for enhanced functionality
              THRESHOLD=""      # Custom threshold for scoring
              TOPK=""          # Custom top-k results limit
              README_MODE=""   # Override for README search mode
              CODE_MODE=""     # Override for code search mode  
              SCOPE="all"      # Scope: code|readme|all
              MODEL=""         # Model selection for semantic search
              VERBOSE=false    # Verbose output mode
              QUIET=false      # Quiet output mode
              COLOR="auto"     # Color output: auto|always|never
              PROGRESS=true    # Show progress indicators
              
              # Parse arguments
              while [[ $# -gt 0 ]]; do
                case $1 in
                  -m|--mode)
                    MODE="$2"
                    shift 2
                    ;;
                  -d|--dir)
                    SEARCH_DIR="$2"
                    shift 2
                    ;;
                  -f|--format)
                    OUTPUT_FORMAT="$2"
                    shift 2
                    ;;
                  --dirs-json)
                    DIRS_JSON="$2"
                    shift 2
                    ;;
                  --explain)
                    EXPLAIN=true
                    shift
                    ;;
                  --failsafe)
                    FAILSAFE=true
                    shift
                    ;;
                  --stage1-mode)
                    STAGE1_MODE="$2"
                    shift 2
                    ;;
                  --stage2-mode)
                    STAGE2_MODE="$2"
                    shift 2
                    ;;
                  --max-dirs)
                    MAX_DIRS="$2"
                    shift 2
                    ;;
                  --threshold)
                    THRESHOLD="$2"
                    shift 2
                    ;;
                  --topk)
                    TOPK="$2"
                    shift 2
                    ;;
                  --readme-mode)
                    README_MODE="$2"
                    shift 2
                    ;;
                  --code-mode)
                    CODE_MODE="$2"
                    shift 2
                    ;;
                  --scope)
                    SCOPE="$2"
                    shift 2
                    ;;
                  --model)
                    MODEL="$2"
                    shift 2
                    ;;
                  --verbose)
                    VERBOSE=true
                    shift
                    ;;
                  --quiet)
                    QUIET=true
                    shift
                    ;;
                  --color)
                    COLOR="$2"
                    shift 2
                    ;;
                  --no-progress)
                    PROGRESS=false
                    shift
                    ;;
                  -h|--help)
                    usage
                    exit 0
                    ;;
                  -*)
                    echo "Unknown option: $1" >&2
                    usage >&2
                    exit 1
                    ;;
                  *)
                    QUERY="$1"
                    shift
                    ;;
                esac
              done
              
              if [[ -z "$QUERY" ]]; then
                echo "Error: Query required" >&2
                usage >&2
                exit 1
              fi
              
              # Color output configuration
              setup_colors() {
                if [[ "$COLOR" == "never" ]] || ([[ "$COLOR" == "auto" ]] && [[ ! -t 1 ]]); then
                  # No colors
                  RED=""
                  GREEN=""
                  YELLOW=""
                  BLUE=""
                  MAGENTA=""
                  CYAN=""
                  BOLD=""
                  RESET=""
                else
                  # Enable colors
                  RED='\033[0;31m'
                  GREEN='\033[0;32m'
                  YELLOW='\033[0;33m'
                  BLUE='\033[0;34m'
                  MAGENTA='\033[0;35m'
                  CYAN='\033[0;36m'
                  BOLD='\033[1m'
                  RESET='\033[0m'
                fi
              }
              
              # Logging functions with verbose/quiet support
              log_info() {
                if [[ "$QUIET" != "true" ]]; then
                  echo -e "${CYAN}â„¹ï¸${RESET} $1" >&2
                fi
              }
              
              log_success() {
                if [[ "$QUIET" != "true" ]]; then
                  echo -e "${GREEN}âœ…${RESET} $1" >&2
                fi
              }
              
              log_warning() {
                if [[ "$QUIET" != "true" ]]; then
                  echo -e "${YELLOW}âš ï¸${RESET} $1" >&2
                fi
              }
              
              log_error() {
                echo -e "${RED}âŒ${RESET} $1" >&2
              }
              
              log_verbose() {
                if [[ "$VERBOSE" == "true" ]]; then
                  echo -e "${MAGENTA}ðŸ”${RESET} $1" >&2
                fi
              }
              
              log_progress() {
                if [[ "$PROGRESS" == "true" ]] && [[ "$QUIET" != "true" ]]; then
                  echo -e "${BLUE}ðŸ”${RESET} $1" >&2
                fi
              }
              
              # Initialize color support
              setup_colors
              
              # Function to find readme.nix files using rg + mapfile pattern
              find_readme_files() {
                local search_root="$1"
                local readme_files=()
                
                # Use rg to find readme.nix files with proper globbing
                if mapfile -t readme_files < <(rg --files -g '**/readme.nix' "$search_root" 2>/dev/null); then
                  printf '%s\n' "''${readme_files[@]}"
                else
                  # Fallback to find if rg fails
                  find "$search_root" -name "readme.nix" -type f 2>/dev/null || true
                fi
              }
              
              # Enhanced BM25-like scoring function with failsafe relaxation support
              calculate_bm25_score() {
                local content="$1"
                local query="$2"
                local relaxation_stage="''${3:-0}"  # 0=normal, 1=stage1, 2=stage2, etc.
                
                # Simple scoring based on term frequency and position with stage-based relaxation
                local score=0
                local query_lower
                local content_lower
                query_lower=$(echo "$query" | tr '[:upper:]' '[:lower:]')
                content_lower=$(echo "$content" | tr '[:upper:]' '[:lower:]')
                
                # Stage-based scoring weights (progressively more permissive)
                local exact_weight=10
                local partial_weight=5
                local field_bonus=20
                
                case "$relaxation_stage" in
                  1) # Stage 1: threshold relaxation (0.5x weights)
                    exact_weight=5
                    partial_weight=3
                    field_bonus=10
                    ;;
                  2) # Stage 2: further threshold relaxation (0.25x weights)
                    exact_weight=3
                    partial_weight=2
                    field_bonus=5
                    ;;
                  3|4) # Stage 3+: maximum relaxation
                    exact_weight=2
                    partial_weight=1
                    field_bonus=3
                    ;;
                esac
                
                # Count exact matches
                local exact_matches
                exact_matches=$(echo "$content_lower" | grep -o "$query_lower" | wc -l)
                score=$((score + exact_matches * exact_weight))
                
                # Count partial word matches
                local word_matches
                word_matches=$(echo "$content_lower" | grep -o "\\b\\w*''${query_lower}\\w*\\b" | wc -l)
                score=$((score + word_matches * partial_weight))
                
                # Stage 3+: Additional fuzzy matching for maximum recall
                if [[ "$relaxation_stage" -ge 3 ]]; then
                  # Split query into words and search for any word matches
                  local query_words
                  IFS=' ' read -ra query_words <<< "$query_lower"
                  for word in "''${query_words[@]}"; do
                    if [[ ''${#word} -ge 3 ]]; then  # Only for words 3+ chars
                      local fuzzy_matches
                      fuzzy_matches=$(echo "$content_lower" | grep -o "\\b\\w*''${word}\\w*\\b" | wc -l)
                      score=$((score + fuzzy_matches * 1))
                    fi
                  done
                fi
                
                # Bonus for matches in description/goal sections
                if echo "$content_lower" | grep -E "(description|goal)" | grep -q "$query_lower"; then
                  score=$((score + field_bonus))
                fi
                
                echo "$score"
              }
              
              # Enhanced search function with failsafe relaxation support
              search_readmes() {
                local query="$1"
                local search_dir="$2"
                local mode="$3"
                local relaxation_stage="''${4:-0}"  # 0=normal, 1-4=relaxation stages
                local min_score_threshold="''${5:-1}"  # minimum score threshold
                local results=()
                
                # Find all readme.nix files
                local readme_files
                mapfile -t readme_files < <(find_readme_files "$search_dir")
                
                if [[ ${''\{#readme_files[@]}} -eq 0 ]]; then
                  echo "No readme.nix files found in $search_dir" >&2
                  return 1
                fi
                
                # Process each readme.nix file
                for file in "''${readme_files[@]}"; do
                  if [[ ! -f "$file" ]]; then
                    continue
                  fi
                  
                  local dir_name
                  local content
                  dir_name=$(dirname "$file")
                  content=$(cat "$file" 2>/dev/null || echo "")
                  
                  # Skip empty files
                  if [[ -z "$content" ]]; then
                    continue
                  fi
                  
                  # Extract structured content using simpler pattern matching
                  local description
                  local goal
                  local nonGoal
                  description=$(echo "$content" | grep -o 'description = "[^"]*"' | sed 's/description = "//; s/"$//' || echo "")
                  goal=$(echo "$content" | grep -o 'goal = "[^"]*"' | sed 's/goal = "//; s/"$//' || echo "")
                  nonGoal=$(echo "$content" | grep -o 'nonGoal = "[^"]*"' | sed 's/nonGoal = "//; s/"$//' || echo "")
                  
                  # Stage 3+: Relaxed field matching (search in all content if no field matches)
                  local all_content=""
                  if [[ "$relaxation_stage" -ge 3 ]]; then
                    all_content="$description $goal $nonGoal"
                  fi
                  
                  # Search in different fields with progressive relaxation
                  local field=""
                  local snippet=""
                  local found=false
                  
                  # Check description field
                  if [[ -n "$description" ]] && echo "$description" | grep -qi "$query"; then
                    field="description"
                    snippet=$(echo "$description" | sed "s/\($query\)/\[MATCH\]\1\[\/MATCH\]/gi" | head -c 200)
                    found=true
                  fi
                  
                  # Check goal field
                  if [[ -n "$goal" ]] && echo "$goal" | grep -qi "$query"; then
                    field="goal"
                    snippet=$(echo "$goal" | sed "s/\($query\)/\[MATCH\]\1\[\/MATCH\]/gi" | head -c 200)
                    found=true
                  fi
                  
                  # Check nonGoal field  
                  if [[ -n "$nonGoal" ]] && echo "$nonGoal" | grep -qi "$query"; then
                    field="nonGoal"
                    snippet=$(echo "$nonGoal" | sed "s/\($query\)/\[MATCH\]\1\[\/MATCH\]/gi" | head -c 200)
                    found=true
                  fi
                  
                  # Stage 3+: Search in any content if no specific field match
                  if [[ "$found" == "false" ]] && [[ "$relaxation_stage" -ge 3 ]] && [[ -n "$all_content" ]]; then
                    if echo "$all_content" | grep -qi "$query"; then
                      field="any"
                      snippet=$(echo "$all_content" | sed "s/\($query\)/\[MATCH\]\1\[\/MATCH\]/gi" | head -c 200)
                      found=true
                    fi
                  fi
                  
                  # If found, calculate score and add to results
                  if [[ "$found" == "true" ]]; then
                    local score=0
                    if [[ "$mode" == "bm25" ]]; then
                      score=$(calculate_bm25_score "$content" "$query" "$relaxation_stage")
                    else
                      # Semantic mode placeholder (simplified)
                      score=50
                    fi
                    
                    # Apply minimum score threshold
                    if [[ "$score" -ge "$min_score_threshold" ]]; then
                      # Create result entry
                      local result
                      result=$(jq -n \
                        --arg dir "$dir_name" \
                        --arg kind "readme" \
                        --arg field "$field" \
                        --arg snippet "$snippet" \
                        --arg score "$score" \
                        --arg file "$file" \
                        --arg relaxationStage "$relaxation_stage" \
                        '{dir: $dir, kind: $kind, field: $field, snippet: $snippet, score: ($score | tonumber), file: $file, relaxationStage: ($relaxationStage | tonumber)}')
                      
                      results+=("$result")
                    fi
                  fi
                done
                
                # Sort results by score (descending) and output
                if [[ ${''\{#results[@]}} -gt 0 ]]; then
                  printf '%s\n' "''${results[@]}" | jq -s 'sort_by(-.score)'
                else
                  echo "[]"
                fi
              }
              
              # Structured Failsafe Search Engine - 4-stage progressive relaxation
              search_readmes_with_failsafe() {
                local query="$1"
                local search_dir="$2"
                local mode="$3"
                local explain="''${4:-false}"
                
                # Stage configurations
                local stage1_threshold=5    # 0.5x of normal threshold (10)
                local stage2_threshold=2    # 0.25x of normal threshold
                local stage3_threshold=1    # minimum threshold
                local stage4_threshold=0    # no threshold
                
                local failsafe_log=()
                local final_results='[]'
                local stage_used=0
                local fallback_triggered=false
                
                # Stage 0: Normal search (no relaxation)
                echo "ðŸ” Failsafe Stage 0: Normal search..." >&2
                final_results=$(search_readmes "$query" "$search_dir" "$mode" 0 10)
                local stage0_count=$(echo "$final_results" | jq 'length')
                
                failsafe_log+=("Stage 0 (Normal): $stage0_count results with threshold 10")
                
                if [[ "$stage0_count" -gt 0 ]]; then
                  stage_used=0
                  echo "âœ… Stage 0 successful: $stage0_count results found" >&2
                else
                  # Stage 1: Threshold relaxation (0.5x)
                  echo "âš ï¸ Stage 0 failed, trying Stage 1: Threshold relaxation (0.5x)..." >&2
                  final_results=$(search_readmes "$query" "$search_dir" "$mode" 1 "$stage1_threshold")
                  local stage1_count=$(echo "$final_results" | jq 'length')
                  
                  failsafe_log+=("Stage 1 (Threshold 0.5x): $stage1_count results with threshold $stage1_threshold")
                  
                  if [[ "$stage1_count" -gt 0 ]]; then
                    stage_used=1
                    fallback_triggered=true
                    echo "âœ… Stage 1 successful: $stage1_count results found" >&2
                  else
                    # Stage 2: Further threshold relaxation (0.25x)
                    echo "âš ï¸ Stage 1 failed, trying Stage 2: Further threshold relaxation (0.25x)..." >&2
                    final_results=$(search_readmes "$query" "$search_dir" "$mode" 2 "$stage2_threshold")
                    local stage2_count=$(echo "$final_results" | jq 'length')
                    
                    failsafe_log+=("Stage 2 (Threshold 0.25x): $stage2_count results with threshold $stage2_threshold")
                    
                    if [[ "$stage2_count" -gt 0 ]]; then
                      stage_used=2
                      fallback_triggered=true
                      echo "âœ… Stage 2 successful: $stage2_count results found" >&2
                    else
                      # Stage 3: Filter â†’ Priority mode (fuzzy matching)
                      echo "âš ï¸ Stage 2 failed, trying Stage 3: Priority mode (fuzzy matching)..." >&2
                      final_results=$(search_readmes "$query" "$search_dir" "$mode" 3 "$stage3_threshold")
                      local stage3_count=$(echo "$final_results" | jq 'length')
                      
                      failsafe_log+=("Stage 3 (Priority/Fuzzy): $stage3_count results with threshold $stage3_threshold")
                      
                      if [[ "$stage3_count" -gt 0 ]]; then
                        stage_used=3
                        fallback_triggered=true
                        echo "âœ… Stage 3 successful: $stage3_count results found" >&2
                      else
                        # Stage 4: Final fallback (maximum relaxation + hybrid search)
                        echo "âš ï¸ Stage 3 failed, trying Stage 4: Final fallback (maximum relaxation)..." >&2
                        final_results=$(search_readmes "$query" "$search_dir" "$mode" 4 "$stage4_threshold")
                        local stage4_count=$(echo "$final_results" | jq 'length')
                        
                        failsafe_log+=("Stage 4 (Final fallback): $stage4_count results with threshold $stage4_threshold")
                        
                        if [[ "$stage4_count" -gt 0 ]]; then
                          stage_used=4
                          fallback_triggered=true
                          echo "âœ… Stage 4 successful: $stage4_count results found" >&2
                        else
                          stage_used=4
                          fallback_triggered=true
                          echo "âŒ All stages failed: No results found even with maximum relaxation" >&2
                        fi
                      fi
                    fi
                  fi
                fi
                
                # Create structured output with failsafe metadata
                local output
                output=$(jq -n \
                  --argjson results "$final_results" \
                  --argjson stageUsed "$stage_used" \
                  --argjson fallbackTriggered "$fallback_triggered" \
                  --argjson failsafeLog "$(printf '%s\n' "''${failsafe_log[@]}" | jq -R . | jq -s .)" \
                  '{
                    results: $results,
                    failsafe: {
                      stageUsed: $stageUsed,
                      fallbackTriggered: $fallbackTriggered,
                      log: $failsafeLog,
                      totalStages: 5
                    }
                  }')
                
                if [[ "$explain" == "true" ]]; then
                  echo "$output"
                else
                  echo "$output" | jq '.results'
                fi
              }
              
              # Enhanced Two-stage pipeline search function with failsafe
              search_pipeline() {
                local query="$1"
                local search_dir="$2"
                local stage1_mode="$3"
                local stage2_mode="$4"
                local max_dirs="$5"
                # explain parameter not used in function logic (handled by JSON structure)
                
                # Stage 1: README search to find relevant directories
                log_progress "Stage 1: Searching READMEs with '$stage1_mode' mode..."
                local readme_results
                readme_results=$(search_readmes "$query" "$search_dir" "$stage1_mode")
                
                # Extract directories from README results, sorted by score (descending)
                local candidate_dirs
                candidate_dirs=$(echo "$readme_results" | jq -r ".[0:$max_dirs] | .[].dir" | sort -u)
                
                local readme_candidates_count
                readme_candidates_count=$(echo "$readme_results" | jq 'length')
                
                local selected_dirs_array
                selected_dirs_array=$(echo "$candidate_dirs" | jq -R . | jq -s .)
                local selected_dirs_count
                selected_dirs_count=$(echo "$selected_dirs_array" | jq 'length')
                
                echo "ðŸ“Š Stage 1 Results: $readme_candidates_count README matches -> $selected_dirs_count directories selected" >&2
                
                # Stage 2: Code search in selected directories (if ck available and dirs found)
                local code_results='[]'
                local fallback_triggered=false
                
                if [[ "$selected_dirs_count" -gt 0 ]]; then
                  if [[ "$CK_AVAILABLE" == "true" ]]; then
                    log_progress "Stage 2: Searching code with '$stage2_mode' mode in selected directories..."
                    
                    # Map stage2_mode to ck mode
                    local ck_mode=""
                    case "$stage2_mode" in
                      "ck-sem") ck_mode="semantic" ;;
                      "ck-regex") ck_mode="regex" ;;
                      "ck-hybrid") ck_mode="hybrid" ;;
                      *) ck_mode="semantic" ;;  # default fallback
                    esac
                    
                    code_results=$(search_code_with_ck "$query" "$selected_dirs_array" "$ck_mode" "$CK_PATH")
                  else
                    echo "âš ï¸ Stage 2: ck not available, skipping code search" >&2
                    fallback_triggered=true
                  fi
                else
                  echo "â„¹ï¸ Stage 2: No directories selected from Stage 1, skipping code search" >&2
                  fallback_triggered=true
                fi
                
                local code_matches_count
                code_matches_count=$(echo "$code_results" | jq 'length')
                echo "ðŸ“Š Stage 2 Results: $code_matches_count code matches found" >&2
                
                # Normalize scores to 0-100 range for both result sets
                local normalized_readme_results
                normalized_readme_results=$(echo "$readme_results" | jq '[.[] | .score = (.score | if . > 100 then 100 else . end)]')
                
                local normalized_code_results
                normalized_code_results=$(echo "$code_results" | jq '[.[] | .score = (.score | if . > 100 then 100 else . end)]')
                
                # Create unified output structure
                local unified_output
                unified_output=$(jq -n \
                  --argjson readmeResults "$normalized_readme_results" \
                  --argjson codeResults "$normalized_code_results" \
                  --argjson explainData "$(jq -n \
                    --argjson readmeCandidates "$readme_results" \
                    --argjson selectedDirs "$selected_dirs_array" \
                    --argjson codeMatches "$code_results" \
                    --argjson fallbackTriggered "$fallback_triggered" \
                    '{
                      readmeCandidates: $readmeCandidates,
                      selectedDirs: $selectedDirs,
                      codeMatches: $codeMatches,
                      fallbackTriggered: $fallbackTriggered,
                      stage1Mode: "'"$stage1_mode"'",
                      stage2Mode: "'"$stage2_mode"'",
                      maxDirs: '"$max_dirs"'
                    }')" \
                  '{
                    readmeResults: $readmeResults,
                    codeResults: $codeResults,
                    explain: $explainData
                  }')
                
                echo "$unified_output"
              }
              
              # Comprehensive Pipeline Search with Structured Failsafe
              search_pipeline_with_failsafe() {
                local query="$1"
                local search_dir="$2"
                local stage1_mode="$3"
                local stage2_mode="$4"
                local max_dirs="$5"
                local explain="''${6:-false}"
                
                # Phase 1: README Failsafe Search
                echo "ðŸš€ Pipeline Failsafe: Starting README search with failsafe..." >&2
                local readme_failsafe_result
                readme_failsafe_result=$(search_readmes_with_failsafe "$query" "$search_dir" "$stage1_mode" true)
                
                local readme_results
                readme_results=$(echo "$readme_failsafe_result" | jq '.results')
                local readme_failsafe_info
                readme_failsafe_info=$(echo "$readme_failsafe_result" | jq '.failsafe')
                
                local readme_count=$(echo "$readme_results" | jq 'length')
                local readme_stage_used=$(echo "$readme_failsafe_info" | jq '.stageUsed')
                local readme_fallback_triggered=$(echo "$readme_failsafe_info" | jq '.fallbackTriggered')
                
                echo "ðŸ“Š README Failsafe Results: $readme_count matches (Stage $readme_stage_used used)" >&2
                
                # Extract directories with dynamic max_dirs based on stage
                local effective_max_dirs="$max_dirs"
                if [[ "$readme_stage_used" -ge 2 ]]; then
                  effective_max_dirs=$((max_dirs * 2))  # Increase directory count for later stages
                  echo "ðŸ”§ Increasing max_dirs to $effective_max_dirs due to Stage $readme_stage_used" >&2
                fi
                
                local candidate_dirs
                candidate_dirs=$(echo "$readme_results" | jq -r ".[0:$effective_max_dirs] | .[].dir" | sort -u)
                
                local selected_dirs_array
                selected_dirs_array=$(echo "$candidate_dirs" | jq -R . | jq -s .)
                local selected_dirs_count
                selected_dirs_count=$(echo "$selected_dirs_array" | jq 'length')
                
                # Phase 2: Code Failsafe Search (if directories found)
                local code_results='[]'
                local code_failsafe_info='{}'
                local overall_fallback_triggered="$readme_fallback_triggered"
                
                if [[ "$selected_dirs_count" -gt 0 ]] && [[ "$CK_AVAILABLE" == "true" ]]; then
                  echo "ðŸš€ Pipeline Failsafe: Starting code search with failsafe..." >&2
                  
                  # Map stage2_mode to ck mode
                  local ck_mode=""
                  case "$stage2_mode" in
                    "ck-sem") ck_mode="semantic" ;;
                    "ck-regex") ck_mode="regex" ;;
                    "ck-hybrid") ck_mode="hybrid" ;;
                    *) ck_mode="semantic" ;;  # default fallback
                  esac
                  
                  local code_failsafe_result
                  code_failsafe_result=$(search_code_with_ck_failsafe "$query" "$selected_dirs_array" "$ck_mode" "$CK_PATH" true)
                  
                  code_results=$(echo "$code_failsafe_result" | jq '.results')
                  code_failsafe_info=$(echo "$code_failsafe_result" | jq '.failsafe')
                  
                  local code_count=$(echo "$code_results" | jq 'length')
                  local code_stage_used=$(echo "$code_failsafe_info" | jq '.stageUsed')
                  local code_fallback_triggered=$(echo "$code_failsafe_info" | jq '.fallbackTriggered')
                  
                  echo "ðŸ“Š Code Failsafe Results: $code_count matches (Stage $code_stage_used used)" >&2
                  
                  # Update overall fallback status
                  if [[ "$code_fallback_triggered" == "true" ]]; then
                    overall_fallback_triggered=true
                  fi
                else
                  if [[ "$selected_dirs_count" -eq 0 ]]; then
                    echo "âš ï¸ Pipeline Failsafe: No directories selected from README search" >&2
                    overall_fallback_triggered=true
                  elif [[ "$CK_AVAILABLE" != "true" ]]; then
                    echo "âš ï¸ Pipeline Failsafe: ck not available, skipping code search" >&2
                    overall_fallback_triggered=true
                  fi
                  
                  code_failsafe_info=$(jq -n '{
                    stageUsed: -1,
                    fallbackTriggered: true,
                    log: ["Code search skipped: no directories or ck unavailable"],
                    totalStages: 5
                  }')
                fi
                
                # Normalize scores to 0-100 range for both result sets
                local normalized_readme_results
                normalized_readme_results=$(echo "$readme_results" | jq '[.[] | .score = (.score | if . > 100 then 100 else . end)]')
                
                local normalized_code_results
                normalized_code_results=$(echo "$code_results" | jq '[.[] | .score = (.score | if . > 100 then 100 else . end)]')
                
                # Create comprehensive output structure with failsafe metadata
                local unified_output
                unified_output=$(jq -n \
                  --argjson readmeResults "$normalized_readme_results" \
                  --argjson codeResults "$normalized_code_results" \
                  --argjson readmeFailsafe "$readme_failsafe_info" \
                  --argjson codeFailsafe "$code_failsafe_info" \
                  --argjson overallFallbackTriggered "$overall_fallback_triggered" \
                  --argjson explainData "$(jq -n \
                    --argjson readmeCandidates "$readme_results" \
                    --argjson selectedDirs "$selected_dirs_array" \
                    --argjson codeMatches "$code_results" \
                    --argjson fallbackTriggered "$overall_fallback_triggered" \
                    --argjson readmeFailsafe "$readme_failsafe_info" \
                    --argjson codeFailsafe "$code_failsafe_info" \
                    '{
                      readmeCandidates: $readmeCandidates,
                      selectedDirs: $selectedDirs,
                      codeMatches: $codeMatches,
                      fallbackTriggered: $fallbackTriggered,
                      stage1Mode: "'"$stage1_mode"'",
                      stage2Mode: "'"$stage2_mode"'",
                      maxDirs: '"$max_dirs"',
                      readmeFailsafe: $readmeFailsafe,
                      codeFailsafe: $codeFailsafe,
                      effectiveMaxDirs: '"$effective_max_dirs"'
                    }')" \
                  '{
                    readmeResults: $readmeResults,
                    codeResults: $codeResults,
                    failsafe: {
                      readmeFailsafe: $readmeFailsafe,
                      codeFailsafe: $codeFailsafe,
                      overallFallbackTriggered: $overallFallbackTriggered,
                      pipelineVersion: "v2-structured-failsafe"
                    },
                    explain: $explainData
                  }')
                
                if [[ "$explain" == "true" ]]; then
                  echo "$unified_output"
                else
                  # Return results with minimal failsafe info for compatibility
                  echo "$unified_output" | jq '{
                    readmeResults: .readmeResults,
                    codeResults: .codeResults,
                    failsafeTriggered: .failsafe.overallFallbackTriggered
                  }'
                fi
              }
              
              # Validate and apply scope restrictions
              log_verbose "Search scope: $SCOPE"
              log_verbose "Search mode: $MODE"
              log_verbose "Query: $QUERY"
              
              # Apply scope restrictions and mode overrides
              case "$SCOPE" in
                "readme")
                  # Force README-only modes
                  case "$MODE" in
                    "ck-sem"|"ck-regex"|"ck-hybrid")
                      log_warning "Mode '$MODE' not compatible with scope 'readme', switching to 'semantic'"
                      MODE="semantic"
                      ;;
                    "pipeline")
                      log_warning "Pipeline mode with scope 'readme' will only perform Stage 1 (README search)"
                      ;;
                  esac
                  ;;
                "code")
                  # Force code-only modes  
                  case "$MODE" in
                    "bm25"|"semantic")
                      if [[ "$CK_AVAILABLE" == "true" ]]; then
                        log_warning "Mode '$MODE' not compatible with scope 'code', switching to 'ck-sem'"
                        MODE="ck-sem"
                      else
                        log_error "Scope 'code' requires ck for code search, but ck is not available"
                        exit 1
                      fi
                      ;;
                    "pipeline")
                      log_warning "Pipeline mode with scope 'code' will only perform Stage 2 (code search)"
                      ;;
                  esac
                  ;;
                "all")
                  # No restrictions, use mode as specified
                  ;;
                *)
                  log_error "Invalid scope '$SCOPE'. Valid options: code|readme|all"
                  exit 1
                  ;;
              esac
              
              # Apply mode overrides if specified
              if [[ -n "$README_MODE" ]] && [[ "$SCOPE" != "code" ]]; then
                case "$MODE" in
                  "bm25"|"semantic"|"pipeline")
                    log_verbose "Overriding README mode with: $README_MODE"
                    if [[ "$MODE" == "pipeline" ]]; then
                      STAGE1_MODE="$README_MODE"
                    else
                      MODE="$README_MODE"
                    fi
                    ;;
                esac
              fi
              
              if [[ -n "$CODE_MODE" ]] && [[ "$SCOPE" != "readme" ]]; then
                case "$MODE" in
                  "ck-sem"|"ck-regex"|"ck-hybrid"|"pipeline")
                    log_verbose "Overriding code mode with: $CODE_MODE"
                    if [[ "$MODE" == "pipeline" ]]; then
                      STAGE2_MODE="$CODE_MODE"
                    else
                      MODE="$CODE_MODE"
                    fi
                    ;;
                esac
              fi
              
              # Execute search - Route to appropriate search engine based on mode
              search_results=""
              
              case "$MODE" in
                "pipeline")
                  # Two-stage pipeline search mode with optional failsafe
                  if [[ "$STAGE2_MODE" =~ ^ck- ]] && [[ "$CK_AVAILABLE" != "true" ]]; then
                    echo "Warning: ck is required for Stage 2 mode '$STAGE2_MODE' but not available" >&2
                    echo "Pipeline will only perform Stage 1 (README search)" >&2
                  fi
                  
                  if [[ "$FAILSAFE" == "true" ]]; then
                    log_progress "Starting Pipeline with Structured Failsafe..."
                    search_results=$(search_pipeline_with_failsafe "$QUERY" "$SEARCH_DIR" "$STAGE1_MODE" "$STAGE2_MODE" "$MAX_DIRS" "$EXPLAIN")
                  else
                    log_progress "Starting Two-Stage Pipeline Search..."
                    search_results=$(search_pipeline "$QUERY" "$SEARCH_DIR" "$STAGE1_MODE" "$STAGE2_MODE" "$MAX_DIRS" "$EXPLAIN")
                  fi
                  ;;
                  
                "ck-sem"|"ck-regex"|"ck-hybrid")
                  # ck-based code search modes with optional failsafe
                  if [[ "$CK_AVAILABLE" != "true" ]]; then
                    echo "Error: ck is required for mode '$MODE' but not available" >&2
                    echo "Please install ck or use a different search mode (bm25, semantic, pipeline)" >&2
                    exit 1
                  fi
                  
                  # Prepare directory list for ck search
                  dirs_to_search=""
                  if [[ -n "$DIRS_JSON" ]]; then
                    dirs_to_search="$DIRS_JSON"
                  else
                    dirs_to_search=$(echo "[\"$SEARCH_DIR\"]" | jq -c '.')
                  fi
                  
                  # Map mode to ck mode
                  ck_mode=""
                  case "$MODE" in
                    "ck-sem") ck_mode="semantic" ;;
                    "ck-regex") ck_mode="regex" ;;
                    "ck-hybrid") ck_mode="hybrid" ;;
                  esac
                  
                  if [[ "$FAILSAFE" == "true" ]]; then
                    echo "ðŸš€ Starting Code Search with Structured Failsafe..." >&2
                    search_results=$(search_code_with_ck_failsafe "$QUERY" "$dirs_to_search" "$ck_mode" "$CK_PATH" "$EXPLAIN")
                  else
                    search_results=$(search_code_with_ck "$QUERY" "$dirs_to_search" "$ck_mode" "$CK_PATH")
                  fi
                  ;;
                  
                "bm25"|"semantic")
                  # Traditional README search modes with optional failsafe
                  if [[ "$FAILSAFE" == "true" ]]; then
                    log_progress "Starting README Search with Structured Failsafe..."
                    search_results=$(search_readmes_with_failsafe "$QUERY" "$SEARCH_DIR" "$MODE" "$EXPLAIN")
                  else
                    # Apply custom threshold if specified
                    local custom_threshold=""
                    if [[ -n "$THRESHOLD" ]]; then
                      custom_threshold="$THRESHOLD"
                      log_verbose "Using custom threshold: $THRESHOLD"
                    fi
                    search_results=$(search_readmes "$QUERY" "$SEARCH_DIR" "$MODE" 0 "$custom_threshold")
                  fi
                  ;;
                  
                *)
                  echo "Error: Unknown search mode '$MODE'" >&2
                  echo "Available modes: bm25, semantic, ck-sem, ck-regex, ck-hybrid, pipeline" >&2
                  echo "Use --failsafe for structured 4-stage progressive relaxation" >&2
                  exit 1
                  ;;
              esac
              
              # Output results
              if [[ "$OUTPUT_FORMAT" == "json" ]]; then
                if [[ "$MODE" == "pipeline" ]]; then
                  # For pipeline mode, output the unified structure
                  if [[ "$EXPLAIN" == "true" ]]; then
                    echo "$search_results"
                  else
                    # Without explain, just combine results
                    echo "$search_results" | jq '{
                      readmeResults: .readmeResults,
                      codeResults: .codeResults
                    }'
                  fi
                else
                  echo "$search_results"
                fi
              else
                # Text format output
                if [[ "$MODE" == "pipeline" ]]; then
                  # Pipeline text output with failsafe information
                  echo "Two-Stage Pipeline Search Results for: '$QUERY'"
                  echo "Stage 1 Mode: $STAGE1_MODE | Stage 2 Mode: $STAGE2_MODE"
                  echo "Directory: $SEARCH_DIR | Max Dirs: $MAX_DIRS | Failsafe: $(if [[ "$FAILSAFE" == "true" ]]; then echo "Enabled"; else echo "Disabled"; fi)"
                  echo "========================================================"
                  
                  readme_count=$(echo "$search_results" | jq '.readmeResults | length')
                  code_count=$(echo "$search_results" | jq '.codeResults | length')
                  echo "ðŸ“Š Pipeline Summary: $readme_count README matches â†’ $code_count code matches"
                  
                  # Show failsafe information if available
                  if [[ "$FAILSAFE" == "true" ]] && echo "$search_results" | jq -e '.failsafe' >/dev/null 2>&1; then
                    local readme_stage_used=$(echo "$search_results" | jq '.failsafe.readmeFailsafe.stageUsed // -1')
                    local code_stage_used=$(echo "$search_results" | jq '.failsafe.codeFailsafe.stageUsed // -1')
                    local overall_fallback=$(echo "$search_results" | jq '.failsafe.overallFallbackTriggered // false')
                    
                    echo "ðŸ›¡ï¸  Failsafe Status: $(if [[ "$overall_fallback" == "true" ]]; then echo "Triggered"; else echo "Not needed"; fi)"
                    echo "   README Stage Used: $readme_stage_used | Code Stage Used: $code_stage_used"
                  fi
                  echo ""
                  
                  if [[ "$EXPLAIN" == "true" ]]; then
                    echo "ðŸ” Pipeline Explanation:"
                    echo "$search_results" | jq -r '.explain | 
                      "   Stage 1: \(.readmeCandidates | length) README candidates found\n" +
                      "   Selected: \(.selectedDirs | length) directories for Stage 2\n" +
                      "   Stage 2: \(.codeMatches | length) code matches found\n" +
                      "   Fallback: \(if .fallbackTriggered then "Yes (ck unavailable or no dirs)" else "No" end)\n" +
                      "   Selected directories: \(.selectedDirs | join(", "))"'
                    
                    # Show detailed failsafe logs if available
                    if [[ "$FAILSAFE" == "true" ]] && echo "$search_results" | jq -e '.failsafe.readmeFailsafe.log' >/dev/null 2>&1; then
                      echo ""
                      echo "ðŸ›¡ï¸  Detailed Failsafe Log:"
                      echo "   README Failsafe:"
                      echo "$search_results" | jq -r '.failsafe.readmeFailsafe.log[] | "     - \(.)"'
                      if echo "$search_results" | jq -e '.failsafe.codeFailsafe.log' >/dev/null 2>&1; then
                        echo "   Code Failsafe:"
                        echo "$search_results" | jq -r '.failsafe.codeFailsafe.log[] | "     - \(.)"'
                      fi
                    fi
                    echo ""
                  fi
                  
                  # Show README results
                  if [[ "$readme_count" -gt 0 ]]; then
                    echo "ðŸ“ README Results (Stage 1):"
                    echo "$search_results" | jq -r '.readmeResults[] | 
                      "   ðŸ“‹ \(.dir)\n" +
                      "      Field: \(.field) | Score: \(.score)\n" +
                      "      Snippet: \(.snippet)\n" +
                      "      File: \(.file)\n"'
                  fi
                  
                  # Show code results
                  if [[ "$code_count" -gt 0 ]]; then
                    echo "ðŸ” Code Results (Stage 2):"
                    echo "$search_results" | jq -r '.codeResults[] | 
                      "   ðŸ—‚ï¸  \(.dir)\n" +
                      "      Kind: \(.kind) | Score: \(.score)\n" +
                      "      Snippet: \(.snippet)\n" +
                      "      File: \(.file)\n" +
                      (if .ck_metadata.line_start then "      Line: \(.ck_metadata.line_start)" + (if .ck_metadata.line_end != .ck_metadata.line_start then "-\(.ck_metadata.line_end)" else "" end) + "\n" else "" end)'
                  fi
                else
                  # Traditional single-mode text output with failsafe information
                  echo "Search Results for: '$QUERY'"
                  echo "Mode: $MODE"
                  echo "Directory: $SEARCH_DIR | Failsafe: $(if [[ "$FAILSAFE" == "true" ]]; then echo "Enabled"; else echo "Disabled"; fi)"
                  echo "----------------------------------------"
                  
                  # Handle failsafe results format vs regular results format
                  if [[ "$FAILSAFE" == "true" ]] && echo "$search_results" | jq -e '.results' >/dev/null 2>&1; then
                    # Failsafe format with .results and .failsafe
                    result_count=$(echo "$search_results" | jq '.results | length')
                    local stage_used=$(echo "$search_results" | jq '.failsafe.stageUsed // -1')
                    local fallback_triggered=$(echo "$search_results" | jq '.failsafe.fallbackTriggered // false')
                    
                    echo "Found $result_count results"
                    echo "ðŸ›¡ï¸  Failsafe Status: $(if [[ "$fallback_triggered" == "true" ]]; then echo "Triggered (Stage $stage_used used)"; else echo "Not needed"; fi)"
                    
                    if [[ "$EXPLAIN" == "true" ]] && echo "$search_results" | jq -e '.failsafe.log' >/dev/null 2>&1; then
                      echo "ðŸ›¡ï¸  Failsafe Log:"
                      echo "$search_results" | jq -r '.failsafe.log[] | "   - \(.)"'
                    fi
                    echo ""
                    
                    # Display results with relaxation stage information
                    echo "$search_results" | jq -r '.results[] | 
                      if .kind == "code" then
                        "ðŸ” " + (.dir // "") + (if .relaxationStage and .relaxationStage > 0 then " (Relaxation Stage " + (.relaxationStage | tostring) + ")" else "" end) + "\n   Kind: " + (.kind // "") + " (ck)\n   Score: " + (.score | tostring) + "\n   Snippet: " + (.snippet // "") + "\n   File: " + (.file // "") + "\n" + (if .ck_metadata.line_start then "   Line: " + (.ck_metadata.line_start | tostring) + (if .ck_metadata.line_end != .ck_metadata.line_start then "-" + (.ck_metadata.line_end | tostring) else "" end) + "\n" else "" end)
                      else
                        "ðŸ“ " + (.dir // "") + (if .relaxationStage and .relaxationStage > 0 then " (Relaxation Stage " + (.relaxationStage | tostring) + ")" else "" end) + "\n   Field: " + (.field // "") + "\n   Score: " + (.score | tostring) + "\n   Snippet: " + (.snippet // "") + "\n   File: " + (.file // "") + "\n"
                      end'
                  else
                    # Regular format
                    result_count=$(echo "$search_results" | jq 'length')
                    echo "Found $result_count results"
                    echo ""
                    
                    echo "$search_results" | jq -r '.[] | 
                      if .kind == "code" then
                        "ðŸ” " + (.dir // "") + "\n   Kind: " + (.kind // "") + " (ck)\n   Score: " + (.score | tostring) + "\n   Snippet: " + (.snippet // "") + "\n   File: " + (.file // "") + "\n" + (if .ck_metadata.line_start then "   Line: " + (.ck_metadata.line_start | tostring) + (if .ck_metadata.line_end != .ck_metadata.line_start then "-" + (.ck_metadata.line_end | tostring) else "" end) + "\n" else "" end)
                      else
                        "ðŸ“ " + (.dir // "") + "\n   Field: " + (.field // "") + "\n   Score: " + (.score | tostring) + "\n   Snippet: " + (.snippet // "") + "\n   File: " + (.file // "") + "\n"
                      end'
                  fi
                fi
              fi
            '';
          };

          # Structured documentation report using flake-readme
          readme-report = pkgs.runCommand "readme-report"
            {
              buildInputs = with pkgs; [ jq ];
              NIX_CONFIG = "experimental-features = nix-command flakes";
            } ''
            set -euo pipefail
            
            echo "ðŸ“Š Generating structured documentation report..."
            
            # Get the documentation index from flake-readme
            echo '${builtins.toJSON (docs.index { root = self.outPath; })}' > raw_index.json
            
            # Process and structure the output
            cat raw_index.json | jq '{
              schemaVersion: .schemaVersion,
              totalDocs: (.docs | length),
              missingCount: (.missingReadmes | length),
              errorCount: .errorCount,
              warningCount: .warningCount,
              docs: .docs,
              missingReadmes: .missingReadmes,
              reports: .reports
            }' > $out
            
            echo "âœ… Documentation report generated at: $out"
          '';

          # E2E test harness using runCommand + jq with comprehensive search testing
          test-harness = pkgs.runCommand "search-readme-test-harness"
            {
              buildInputs = with pkgs; [ jq coreutils ripgrep findutils gawk ] 
                ++ pkgs.lib.optionals (ckPackage != null) [ ckPackage ];
              # Offline-safe nix eval environment
              NIX_CONFIG = "experimental-features = nix-command flakes";
            } ''
            set -euo pipefail
            
            echo "ðŸ§ª Running search-readme E2E test harness..."
            
            # Setup test environment with search tool
            export PATH="${self'.packages.default}/bin:$PATH"
            
            # Create test data directly
            mkdir -p test-env/test-readmes
            cd test-env
            
            # Create test readme.nix files
            mkdir -p test-readmes/project-a
            cat > test-readmes/project-a/readme.nix << 'EOF'
{
  description = "A comprehensive web application framework for building modern reactive applications with real-time features";
  
  goal = "Create a full-stack framework that enables developers to build reactive web applications with minimal configuration while maintaining high performance and scalability.";
  
  nonGoal = "This is not intended to be a static site generator or a simple templating system. It focuses on dynamic, interactive applications.";
  
  features = [
    "Real-time data synchronization"
    "Component-based architecture" 
    "Built-in state management"
    "TypeScript support"
  ];
  
  status = "active";
}
EOF

            mkdir -p test-readmes/project-b
            cat > test-readmes/project-b/readme.nix << 'EOF'
{
  description = "A lightweight database abstraction layer for Nix-based applications with focus on simplicity and performance";
  
  goal = "Provide a simple and efficient database interface that works seamlessly with Nix environments and supports multiple database backends including SQLite, PostgreSQL, and DuckDB.";
  
  nonGoal = "Not intended to replace full-featured ORMs or provide complex query building capabilities. Focuses on straightforward database operations.";
  
  features = [
    "Multi-database support"
    "Nix-first configuration"
    "Type-safe operations"
    "Connection pooling"
  ];
  
  status = "experimental";
}
EOF

            mkdir -p test-readmes/tools/cli-util
            cat > test-readmes/tools/cli-util/readme.nix << 'EOF'
{
  description = "Command-line utility for managing development environments and automating common tasks";
  
  goal = "Streamline developer workflows by providing a unified interface for environment management, project scaffolding, and automation tasks across different programming languages and frameworks.";
  
  nonGoal = "Not a replacement for language-specific package managers or build tools. Does not aim to provide IDE functionality or complex debugging features.";
  
  features = [
    "Environment management"
    "Project templates"
    "Task automation"
    "Multi-language support"
  ];
  
  status = "stable";
}
EOF

            mkdir -p test-readmes/data-processing
            cat > test-readmes/data-processing/readme.nix << 'EOF'
{
  description = "High-performance data processing pipeline with support for streaming and batch operations";
  
  goal = "Enable efficient processing of large datasets through a flexible pipeline architecture that supports both real-time streaming and batch processing with built-in monitoring and error handling.";
  
  nonGoal = "Not designed for simple data transformations or one-off scripts. Does not provide data storage or visualization capabilities directly.";
  
  features = [
    "Streaming data processing"
    "Batch operations"
    "Pipeline monitoring"
    "Error recovery"
    "Scalable architecture"
  ];
  
  status = "beta";
}
EOF
            
            # Test 1: Basic search functionality
            echo "Test 1: Basic BM25 search functionality"
            search_result=$(search-readme -f json -d test-readmes "framework" || echo '[]')
            
            if echo "$search_result" | jq -e '. | length > 0' > /dev/null; then
              echo "âœ“ Basic search returned results"
            else
              echo "âŒ Basic search failed to return results"
              echo "Search result: $search_result"
              exit 1
            fi
            
            # Test 2: Field-specific search
            echo "Test 2: Field-specific search testing"
            description_search=$(search-readme -f json -d test-readmes "database" || echo '[]')
            goal_search=$(search-readme -f json -d test-readmes "environment" || echo '[]')
            
            desc_count=$(echo "$description_search" | jq 'length')
            goal_count=$(echo "$goal_search" | jq 'length')
            
            echo "  - Description field matches: $desc_count"
            echo "  - Goal field matches: $goal_count"
            
            if [[ "$desc_count" -gt 0 ]] || [[ "$goal_count" -gt 0 ]]; then
              echo "âœ“ Field-specific search working"
            else
              echo "âŒ Field-specific search failed"
              exit 1
            fi
            
            # Test 3: JSON output structure validation
            echo "Test 3: JSON output structure validation"
            sample_result=$(search-readme -f json -d test-readmes "application" | jq '.[0]? // {}')
            
            required_fields=("dir" "kind" "field" "snippet" "score")
            for field in "''${required_fields[@]}"; do
              if echo "$sample_result" | jq -e "has(\"$field\")" > /dev/null; then
                echo "âœ“ Required field '$field' present"
              else
                echo "âŒ Required field '$field' missing"
                echo "Sample result: $sample_result"
                exit 1
              fi
            done
            
            # Test 4: Scoring system validation
            echo "Test 4: Scoring system validation"
            scored_results=$(search-readme -f json -d test-readmes "data" | jq '[.[] | select(.score > 0)]')
            scored_count=$(echo "$scored_results" | jq 'length')
            
            if [[ "$scored_count" -gt 0 ]]; then
              echo "âœ“ Scoring system working (found $scored_count scored results)"
            else
              echo "âŒ Scoring system failed"
              exit 1
            fi
            
            # Test 5: Multiple search modes
            echo "Test 5: Multiple search modes testing"
            bm25_results=$(search-readme -m bm25 -f json -d test-readmes "processing" || echo '[]')
            semantic_results=$(search-readme -m semantic -f json -d test-readmes "processing" || echo '[]')
            
            bm25_count=$(echo "$bm25_results" | jq 'length')
            semantic_count=$(echo "$semantic_results" | jq 'length')
            
            echo "  - BM25 mode results: $bm25_count"
            echo "  - Semantic mode results: $semantic_count"
            echo "âœ“ Multiple search modes working"
            
            # Test 6: File enumeration with rg + mapfile pattern
            echo "Test 6: File enumeration testing"
            readme_files_found=$(find test-readmes -name "readme.nix" -type f | wc -l)
            echo "  - Total readme.nix files found: $readme_files_found"
            
            if [[ "$readme_files_found" -eq 4 ]]; then
              echo "âœ“ File enumeration working correctly"
            else
              echo "âŒ File enumeration failed (expected 4, found $readme_files_found)"
              exit 1
            fi
            
            # Test 7: flake-readme integration test
            echo "Test 7: flake-readme library integration"
            cd ..
            echo '${builtins.toJSON (docs.index { root = self.outPath; })}' > integration_test.json
            
            if jq -e '.schemaVersion' integration_test.json > /dev/null; then
              echo "âœ“ flake-readme integration successful"
            else
              echo "âŒ flake-readme integration failed"
              exit 1
            fi
            
            # Test 8: ck Integration Tests (comprehensive ck functionality validation)
            echo "Test 8: ck Integration Testing"
            
            # Create test code files for ck to search
            cd test-env
            mkdir -p test-code/src
            
            # Create sample source files for ck testing
            cat > test-code/src/auth.rs << 'EOF'
fn authenticate(user: &str, password: &str) -> Result<bool, AuthError> {
    // Basic authentication function
    let hashed = hash_password(password);
    validate_credentials(user, &hashed)
}

pub fn hash_password(password: &str) -> String {
    // Simple password hashing implementation
    format!("hashed_{}", password)
}
EOF

            cat > test-code/src/database.py << 'EOF'
import sqlite3

class DatabaseManager:
    def __init__(self, db_path):
        self.connection = sqlite3.connect(db_path)
    
    def create_user(self, username, email):
        """Create a new user in the database"""
        cursor = self.connection.cursor()
        cursor.execute(
            "INSERT INTO users (username, email) VALUES (?, ?)",
            (username, email)
        )
        self.connection.commit()
        return cursor.lastrowid

    def authenticate_user(self, username, password_hash):
        """Authenticate user credentials"""
        cursor = self.connection.cursor()
        result = cursor.execute(
            "SELECT id FROM users WHERE username = ? AND password = ?",
            (username, password_hash)
        ).fetchone()
        return result is not None
EOF

            cat > test-code/src/functions.js << 'EOF'
// Authentication and user management functions
function validateUser(username, password) {
    // Basic user validation function
    if (!username || !password) {
        throw new Error('Username and password required');
    }
    return checkCredentials(username, password);
}

function checkCredentials(username, password) {
    // Simulate credential checking
    const users = getStoredUsers();
    return users.some(user => 
        user.username === username && 
        user.password === hashPassword(password)
    );
}

function hashPassword(password) {
    // Simple password hashing for demo
    return btoa(password);
}

function getStoredUsers() {
    // Mock user storage
    return [
        { username: 'admin', password: 'aGFzaGVk' },
        { username: 'user', password: 'cGFzc3dvcmQ=' }
    ];
}
EOF
            
            # Test 8a: ck availability and version check
            echo "Test 8a: ck availability and version validation"
            if command -v ck >/dev/null 2>&1; then
              ck_version=$(ck --version 2>/dev/null || echo "unknown")
              echo "âœ“ ck is available: $ck_version"
              CK_TESTS_ENABLED=true
            else
              echo "â„¹ï¸ ck not available - skipping ck-specific tests"
              CK_TESTS_ENABLED=false
            fi
            
            if [[ "$CK_TESTS_ENABLED" == "true" ]]; then
              # Test 8b: ck JSONL smoke test
              echo "Test 8b: ck JSONL functionality smoke test"
              ck_smoke_result=$(ck --jsonl "function" --topk 1 test-code/ 2>/dev/null || echo "")
              
              if [[ -n "$ck_smoke_result" ]]; then
                echo "âœ“ ck JSONL smoke test successful"
                
                # Validate JSONL structure
                if echo "$ck_smoke_result" | jq -e '.path' > /dev/null 2>&1; then
                  echo "âœ“ ck JSONL output structure valid"
                else
                  echo "âŒ ck JSONL output structure invalid"
                  exit 1
                fi
              else
                echo "âš ï¸ ck JSONL smoke test returned no results"
              fi
              
              # Test 8c: ck semantic search mode
              echo "Test 8c: ck semantic search mode"
              ck_sem_results=$(search-readme -m ck-sem -f json -d test-code "authenticate user" 2>/dev/null || echo '[]')
              ck_sem_count=$(echo "$ck_sem_results" | jq 'length')
              
              echo "  - ck semantic search results: $ck_sem_count"
              if [[ "$ck_sem_count" -gt 0 ]]; then
                echo "âœ“ ck semantic search working"
                
                # Validate output structure
                sample_ck_result=$(echo "$ck_sem_results" | jq '.[0]? // {}')
                required_ck_fields=("dir" "kind" "file" "score" "ck_metadata")
                for field in "''${required_ck_fields[@]}"; do
                  if echo "$sample_ck_result" | jq -e "has(\"$field\")" > /dev/null; then
                    echo "âœ“ ck result field '$field' present"
                  else
                    echo "âŒ ck result field '$field' missing"
                    echo "Sample ck result: $sample_ck_result"
                    exit 1
                  fi
                done
              else
                echo "âš ï¸ ck semantic search returned no results"
              fi
              
              # Test 8d: ck regex search mode
              echo "Test 8d: ck regex search mode"
              ck_regex_results=$(search-readme -m ck-regex -f json -d test-code "def.*auth" 2>/dev/null || echo '[]')
              ck_regex_count=$(echo "$ck_regex_results" | jq 'length')
              
              echo "  - ck regex search results: $ck_regex_count"
              if [[ "$ck_regex_count" -gt 0 ]]; then
                echo "âœ“ ck regex search working"
              else
                echo "â„¹ï¸ ck regex search returned no results (may be expected)"
              fi
              
              # Test 8e: ck hybrid search mode
              echo "Test 8e: ck hybrid search mode"
              ck_hybrid_results=$(search-readme -m ck-hybrid -f json -d test-code "password function" 2>/dev/null || echo '[]')
              ck_hybrid_count=$(echo "$ck_hybrid_results" | jq 'length')
              
              echo "  - ck hybrid search results: $ck_hybrid_count"
              if [[ "$ck_hybrid_count" -gt 0 ]]; then
                echo "âœ“ ck hybrid search working"
              else
                echo "â„¹ï¸ ck hybrid search returned no results"
              fi
              
              # Test 8f: Multiple directory search with --dirs-json
              echo "Test 8f: Multiple directory search with ck"
              mkdir -p test-code2/lib
              cat > test-code2/lib/helper.py << 'EOF'
def utility_function():
    """A utility function for testing"""
    return "helper"

def process_data(data):
    """Process input data"""
    return data.upper()
EOF
              
              dirs_json='["test-code", "test-code2"]'
              multi_dir_results=$(search-readme -m ck-sem --dirs-json "$dirs_json" -f json "function" 2>/dev/null || echo '[]')
              multi_dir_count=$(echo "$multi_dir_results" | jq 'length')
              
              echo "  - Multi-directory ck search results: $multi_dir_count"
              if [[ "$multi_dir_count" -gt 0 ]]; then
                echo "âœ“ Multi-directory ck search working"
              else
                echo "â„¹ï¸ Multi-directory ck search returned no results"
              fi
              
              # Test 8g: Error handling for ck unavailable scenario
              echo "Test 8g: ck error handling validation"
              # Temporarily rename ck to simulate unavailability
              if command -v ck >/dev/null 2>&1; then
                ck_path=$(command -v ck)
                mv "$ck_path" "$ck_path.backup" 2>/dev/null || true
                
                # Test that search-readme gracefully handles missing ck
                error_test_result=$(search-readme -m ck-sem -d test-code "test" 2>&1 || echo "Expected error occurred")
                
                if echo "$error_test_result" | grep -q "ck is required.*but not available"; then
                  echo "âœ“ ck unavailable error handling working"
                else
                  echo "âŒ ck unavailable error handling failed"
                  echo "Error output: $error_test_result"
                fi
                
                # Restore ck
                mv "$ck_path.backup" "$ck_path" 2>/dev/null || true
              else
                echo "â„¹ï¸ Skipping ck unavailable test (ck not available)"
              fi
              
              echo "âœ“ All ck integration tests completed"
            else
              echo "â„¹ï¸ ck integration tests skipped (ck not available)"
            fi
            
            # Test 9: Pipeline Mode Tests (comprehensive two-stage search testing)
            echo "Test 9: Pipeline Mode Testing"
            
            # Test 9a: Basic pipeline functionality
            echo "Test 9a: Basic pipeline functionality"
            pipeline_basic_result=$(search-readme -m pipeline -f json -d test-readmes "framework" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[]}')
            
            # Validate pipeline output structure
            readme_results_count=$(echo "$pipeline_basic_result" | jq '.readmeResults | length' 2>/dev/null || echo "0")
            has_readmeResults=$(echo "$pipeline_basic_result" | jq 'has("readmeResults")' 2>/dev/null || echo "false")
            has_codeResults=$(echo "$pipeline_basic_result" | jq 'has("codeResults")' 2>/dev/null || echo "false")
            
            if [[ "$has_readmeResults" == "true" ]] && [[ "$has_codeResults" == "true" ]]; then
              echo "âœ“ Pipeline output structure valid (readmeResults: $readme_results_count)"
            else
              echo "âŒ Pipeline output structure invalid"
              echo "Basic pipeline result: $pipeline_basic_result"
              exit 1
            fi
            
            # Test 9b: Pipeline with explain mode
            echo "Test 9b: Pipeline with explain mode"
            pipeline_explain_result=$(search-readme -m pipeline --explain -f json -d test-readmes "database" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[],"explain":{}}')
            
            has_explain=$(echo "$pipeline_explain_result" | jq 'has("explain")' 2>/dev/null || echo "false")
            explain_has_stage1=$(echo "$pipeline_explain_result" | jq '.explain | has("readmeCandidates")' 2>/dev/null || echo "false")
            explain_has_selectedDirs=$(echo "$pipeline_explain_result" | jq '.explain | has("selectedDirs")' 2>/dev/null || echo "false")
            
            if [[ "$has_explain" == "true" ]] && [[ "$explain_has_stage1" == "true" ]] && [[ "$explain_has_selectedDirs" == "true" ]]; then
              echo "âœ“ Pipeline explain mode working"
            else
              echo "âŒ Pipeline explain mode failed"
              echo "Explain result: $pipeline_explain_result"
              exit 1
            fi
            
            # Test 9c: Pipeline stage configuration
            echo "Test 9c: Pipeline stage configuration"
            pipeline_config_result=$(search-readme -m pipeline --stage1-mode semantic --stage2-mode ck-hybrid --max-dirs 3 -f json -d test-readmes "application" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[]}')
            
            # This test mainly ensures the configuration is accepted without errors
            config_readme_count=$(echo "$pipeline_config_result" | jq '.readmeResults | length' 2>/dev/null || echo "0")
            echo "âœ“ Pipeline stage configuration accepted (readmeResults: $config_readme_count)"
            
            # Test 9d: Pipeline with ck integration (if available)
            echo "Test 9d: Pipeline with ck integration"
            if [[ "$CK_TESTS_ENABLED" == "true" ]]; then
              # Create a README that should match and point to our test code directory
              mkdir -p test-readmes/code-project
              cat > test-readmes/code-project/readme.nix << 'EOF'
{
  description = "Code project with authentication functions and database management for testing pipeline integration";
  
  goal = "Demonstrate two-stage pipeline search where README search finds this project and then ck searches the related code directory for actual function implementations.";
  
  nonGoal = "Not a real project, just for testing the pipeline search functionality.";
  
  features = [
    "Authentication functions"
    "Database management" 
    "Code search integration"
    "Pipeline testing"
  ];
  
  status = "test";
}
EOF
              
              # Test pipeline that should find the README and then search code
              pipeline_with_ck_result=$(search-readme -m pipeline -f json -d test-readmes "authentication functions" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[]}')
              
              pipeline_readme_count=$(echo "$pipeline_with_ck_result" | jq '.readmeResults | length' 2>/dev/null || echo "0")
              pipeline_code_count=$(echo "$pipeline_with_ck_result" | jq '.codeResults | length' 2>/dev/null || echo "0")
              
              echo "  - Pipeline README results: $pipeline_readme_count"
              echo "  - Pipeline code results: $pipeline_code_count"
              
              if [[ "$pipeline_readme_count" -gt 0 ]]; then
                echo "âœ“ Pipeline README stage working with ck"
                
                # Test that directories are properly passed to stage 2
                selected_dirs=$(echo "$pipeline_with_ck_result" | jq '.readmeResults[].dir' 2>/dev/null || echo '[]')
                echo "  - Selected directories for Stage 2: $selected_dirs"
              else
                echo "âš ï¸ Pipeline README stage returned no results"
              fi
            else
              echo "â„¹ï¸ Pipeline ck integration skipped (ck not available)"
            fi
            
            # Test 9e: Pipeline fallback behavior (when ck unavailable)
            echo "Test 9e: Pipeline fallback behavior testing"
            if [[ "$CK_TESTS_ENABLED" == "true" ]]; then
              # Temporarily disable ck to test fallback
              ck_path=$(command -v ck)
              mv "$ck_path" "$ck_path.backup" 2>/dev/null || true
              
              pipeline_fallback_result=$(search-readme -m pipeline -f json -d test-readmes "framework" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[]}')
              
              fallback_readme_count=$(echo "$pipeline_fallback_result" | jq '.readmeResults | length' 2>/dev/null || echo "0")
              fallback_code_count=$(echo "$pipeline_fallback_result" | jq '.codeResults | length' 2>/dev/null || echo "0")
              
              if [[ "$fallback_readme_count" -gt 0 ]] && [[ "$fallback_code_count" -eq 0 ]]; then
                echo "âœ“ Pipeline fallback working (README only when ck unavailable)"
              else
                echo "âŒ Pipeline fallback failed"
                echo "Fallback result: $pipeline_fallback_result"
              fi
              
              # Restore ck
              mv "$ck_path.backup" "$ck_path" 2>/dev/null || true
            else
              echo "â„¹ï¸ Pipeline fallback test skipped (ck not available for backup/restore)"
            fi
            
            # Test 9f: Pipeline JSON structure validation
            echo "Test 9f: Pipeline JSON structure validation"
            pipeline_structure_test=$(search-readme -m pipeline -f json -d test-readmes "data" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[]}')
            
            # Validate that readmeResults have correct structure
            readme_sample=$(echo "$pipeline_structure_test" | jq '.readmeResults[0]? // {}')
            required_readme_fields=("dir" "kind" "field" "snippet" "score")
            for field in "''${required_readme_fields[@]}"; do
              if echo "$readme_sample" | jq -e "has(\"$field\")" > /dev/null 2>&1; then
                echo "âœ“ Pipeline README result field '$field' present"
              else
                echo "âš ï¸ Pipeline README result field '$field' missing (may be no results)"
              fi
            done
            
            # Validate that codeResults have correct structure (if any)
            code_sample=$(echo "$pipeline_structure_test" | jq '.codeResults[0]? // {}')
            code_sample_keys=$(echo "$code_sample" | jq 'keys | length' 2>/dev/null || echo "0")
            if [[ "$code_sample_keys" -gt 0 ]]; then
              required_code_fields=("dir" "kind" "file" "score")
              for field in "''${required_code_fields[@]}"; do
                if echo "$code_sample" | jq -e "has(\"$field\")" > /dev/null 2>&1; then
                  echo "âœ“ Pipeline code result field '$field' present"
                else
                  echo "âŒ Pipeline code result field '$field' missing"
                fi
              done
            else
              echo "â„¹ï¸ No code results to validate structure"
            fi
            
            echo "âœ“ All pipeline mode tests completed"
            
            # Test 10: Structured Failsafe Mode Tests (comprehensive zero-result recovery testing)
            echo "Test 10: Structured Failsafe Mode Testing"
            
            # Test 10a: README Failsafe with nonexistent concept
            echo "Test 10a: README failsafe with nonexistent concept"
            nonexistent_failsafe_test=$(search-readme --failsafe -f json -d test-readmes "nonexistent-quantum-blockchain-ai-concept-xyz" 2>/dev/null || echo '{"results":[],"failsafe":{}}')
            
            # Check failsafe structure
            has_failsafe=$(echo "$nonexistent_failsafe_test" | jq 'has("failsafe")' 2>/dev/null || echo "false")
            failsafe_triggered=$(echo "$nonexistent_failsafe_test" | jq '.failsafe.fallbackTriggered // false' 2>/dev/null)
            stage_used=$(echo "$nonexistent_failsafe_test" | jq '.failsafe.stageUsed // -1' 2>/dev/null)
            
            if [[ "$has_failsafe" == "true" ]]; then
              echo "âœ“ Failsafe structure present"
              echo "  - Failsafe triggered: $failsafe_triggered"
              echo "  - Stage used: $stage_used"
            else
              echo "âŒ Failsafe structure missing"
            fi
            
            # Test 10b: Pipeline Failsafe with zero-result scenario
            echo "Test 10b: Pipeline failsafe with zero-result scenario"
            pipeline_failsafe_test=$(search-readme -m pipeline --failsafe -f json -d test-readmes "impossible-nonexistent-term-12345" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[],"failsafe":{}}')
            
            pipeline_has_failsafe=$(echo "$pipeline_failsafe_test" | jq 'has("failsafe")' 2>/dev/null || echo "false")
            pipeline_readme_failsafe=$(echo "$pipeline_failsafe_test" | jq '.failsafe.readmeFailsafe.fallbackTriggered // false' 2>/dev/null)
            
            if [[ "$pipeline_has_failsafe" == "true" ]]; then
              echo "âœ“ Pipeline failsafe structure present"
              echo "  - README failsafe triggered: $pipeline_readme_failsafe"
            else
              echo "âŒ Pipeline failsafe structure missing"
            fi
            
            # Test 10c: Code Failsafe (if ck available)
            echo "Test 10c: Code failsafe testing"
            if [[ "$CK_TESTS_ENABLED" == "true" ]]; then
              code_failsafe_test=$(search-readme -m ck-sem --failsafe -f json -d test-code "nonexistent-impossible-function-name-xyz" 2>/dev/null || echo '{"results":[],"failsafe":{}}')
              
              code_has_failsafe=$(echo "$code_failsafe_test" | jq 'has("failsafe")' 2>/dev/null || echo "false")
              code_failsafe_triggered=$(echo "$code_failsafe_test" | jq '.failsafe.fallbackTriggered // false' 2>/dev/null)
              
              if [[ "$code_has_failsafe" == "true" ]]; then
                echo "âœ“ Code failsafe structure present"
                echo "  - Code failsafe triggered: $code_failsafe_triggered"
              else
                echo "âŒ Code failsafe structure missing"
              fi
            else
              echo "â„¹ï¸ Code failsafe test skipped (ck not available)"
            fi
            
            # Test 10d: Relaxation stage progression test
            echo "Test 10d: Relaxation stage progression test"
            
            # Test with a term that should trigger relaxation stages
            relaxation_test=$(search-readme --failsafe --explain -f json -d test-readmes "partial-match-term" 2>/dev/null || echo '{"results":[],"failsafe":{"log":[]}}')
            
            relaxation_log_count=$(echo "$relaxation_test" | jq '.failsafe.log | length' 2>/dev/null || echo "0")
            if [[ "$relaxation_log_count" -gt 0 ]]; then
              echo "âœ“ Relaxation progression logged"
              echo "  - Log entries: $relaxation_log_count"
              
              # Show first few log entries
              echo "$relaxation_test" | jq -r '.failsafe.log[0:3][] | "    - \(.)"' 2>/dev/null || echo "    - Log display failed"
            else
              echo "âš ï¸ No relaxation progression logged"
            fi
            
            # Test 10e: Failsafe explain mode
            echo "Test 10e: Failsafe explain mode testing"
            explain_failsafe_test=$(search-readme --failsafe --explain -f json -d test-readmes "framework" 2>/dev/null || echo '{"results":[],"failsafe":{}}')
            
            explain_has_log=$(echo "$explain_failsafe_test" | jq 'has("failsafe") and (.failsafe | has("log"))' 2>/dev/null || echo "false")
            if [[ "$explain_has_log" == "true" ]]; then
              echo "âœ“ Failsafe explain mode working"
            else
              echo "âš ï¸ Failsafe explain mode not functioning properly"
            fi
            
            # Test 10f: Failsafe text output format
            echo "Test 10f: Failsafe text output format"
            text_failsafe_output=$(search-readme --failsafe "framework" -d test-readmes 2>/dev/null | head -10)
            
            if echo "$text_failsafe_output" | grep -q "Failsafe: Enabled"; then
              echo "âœ“ Failsafe text output format working"
            else
              echo "âš ï¸ Failsafe text output format not showing status"
            fi
            
            # Test 10g: Performance impact measurement (basic timing)
            echo "Test 10g: Performance impact measurement"
            
            # Normal search timing
            normal_start=$(date +%s%N)
            normal_test=$(search-readme -f json -d test-readmes "framework" 2>/dev/null || echo '[]')
            normal_end=$(date +%s%N)
            normal_duration=$(( (normal_end - normal_start) / 1000000 )) # milliseconds
            
            # Failsafe search timing
            failsafe_start=$(date +%s%N)
            failsafe_test=$(search-readme --failsafe -f json -d test-readmes "framework" 2>/dev/null || echo '{"results":[]}')
            failsafe_end=$(date +%s%N)
            failsafe_duration=$(( (failsafe_end - failsafe_start) / 1000000 )) # milliseconds
            
            echo "  - Normal search: ''${normal_duration}ms"
            echo "  - Failsafe search: ''${failsafe_duration}ms"
            
            if [[ "$failsafe_duration" -lt $((normal_duration * 5)) ]]; then
              echo "âœ“ Failsafe performance impact acceptable (< 5x normal)"
            else
              echo "âš ï¸ Failsafe performance impact high (â‰¥ 5x normal)"
            fi
            
            echo "âœ“ All failsafe mode tests completed"
            
            cd ..
            
            echo "âœ… All E2E tests passed (including ck integration, pipeline mode, and failsafe functionality)"
            
            # Create comprehensive test report with ck integration and pipeline results
            cd test-env
            final_search_test=$(search-readme -f json -d test-readmes "framework application" | jq '[.[] | {dir, kind, field, score}]')
            
            # Test ck integration in final report
            ck_integration_test=""
            if [[ "$CK_TESTS_ENABLED" == "true" ]]; then
              ck_integration_test=$(search-readme -m ck-sem -f json -d test-code "function" 2>/dev/null | jq '[.[] | {dir, kind, file, score}]' || echo '[]')
            else
              ck_integration_test='[]'
            fi
            
            # Test pipeline integration in final report
            pipeline_integration_test=$(search-readme -m pipeline -f json -d test-readmes "framework" 2>/dev/null || echo '{"readmeResults":[],"codeResults":[]}')
            pipeline_readme_final_count=$(echo "$pipeline_integration_test" | jq '.readmeResults | length' 2>/dev/null || echo "0")
            pipeline_code_final_count=$(echo "$pipeline_integration_test" | jq '.codeResults | length' 2>/dev/null || echo "0")
            
            cd ..
            jq -n \
              --argjson integration "$(cat integration_test.json)" \
              --argjson searchTest "$final_search_test" \
              --argjson ckTest "$ck_integration_test" \
              --argjson pipelineTest "$pipeline_integration_test" \
              --arg readmeFilesFound "$readme_files_found" \
              --arg bm25Count "$bm25_count" \
              --arg semanticCount "$semantic_count" \
              --arg scoredCount "$scored_count" \
              --arg ckTestsEnabled "$CK_TESTS_ENABLED" \
              --arg ckSemCount "$(echo "$ck_integration_test" | jq 'length')" \
              --arg pipelineReadmeCount "$pipeline_readme_final_count" \
              --arg pipelineCodeCount "$pipeline_code_final_count" \
              '{
                status: "success",
                tests: [
                  {name: "basic-search", result: "pass"},
                  {name: "field-specific-search", result: "pass"},
                  {name: "json-structure", result: "pass"},
                  {name: "scoring-system", result: "pass"},
                  {name: "multiple-modes", result: "pass"},
                  {name: "file-enumeration", result: "pass"},
                  {name: "flake-readme-integration", result: "pass"},
                  {name: "ck-integration", result: (if ($ckTestsEnabled == "true") then "pass" else "skipped" end)},
                  {name: "pipeline-mode", result: "pass"},
                  {name: "failsafe-mode", result: "pass"}
                ],
                metrics: {
                  readmeFilesFound: ($readmeFilesFound | tonumber),
                  bm25ResultCount: ($bm25Count | tonumber),
                  semanticResultCount: ($semanticCount | tonumber),
                  scoredResultCount: ($scoredCount | tonumber),
                  ckEnabled: ($ckTestsEnabled == "true"),
                  ckSemanticResultCount: ($ckSemCount | tonumber),
                  pipelineReadmeResultCount: ($pipelineReadmeCount | tonumber),
                  pipelineCodeResultCount: ($pipelineCodeCount | tonumber)
                },
                searchSample: $searchTest,
                ckSample: $ckTest,
                pipelineSample: $pipelineTest,
                integration: $integration,
                timestamp: now | strftime("%Y-%m-%d %H:%M:%S")
              }' > $out
          '';
        };

        # Development shell
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            nix
            jq
            coreutils
            ripgrep
            findutils
          ] ++ pkgs.lib.optionals (ckPackage != null) [ ckPackage ];
          
          NIX_CONFIG = "experimental-features = nix-command flakes";
          
          shellHook = ''
            echo "ðŸ” Search README development environment with ck integration"
            echo "Available tools:"
            echo "  - nix: $(nix --version)"
            echo "  - jq: $(jq --version)"
            echo "  - ck: $(if command -v ck >/dev/null 2>&1; then ck --version; else echo "not available in PATH"; fi)"
            echo ""
            echo "ck Integration Status: ${if ckPackage != null then "âœ“ Available" else "âœ— Package not resolved"}"
            echo ""
            echo "Search modes available:"
            echo "  - bm25/semantic: README.nix file search"
            echo "  - ck-sem/ck-regex/ck-hybrid: Code search with ck"
          '';
        };

        # Applications
        apps = {
          default = {
            type = "app";
            program = "${self'.packages.default}/bin/search-readme";
          };
          
          test = {
            type = "app";
            program = "${pkgs.writeShellScript "run-tests" ''
              set -euo pipefail
              echo "Running search-readme tests..."
              nix build ${self}#packages.${system}.test-harness
              echo "ðŸ“Š Test Results:"
              cat ./result
              echo ""
              echo "Test report available at: ./result"
            ''}";
          };
        };

        # Robust checks for CI/CD
        checks = {
          # Test harness validation
          test-validation = self'.packages.test-harness;

          # Package build test
          package-build = self'.packages.default;

          # README collection and structure verification
          readme-collect = pkgs.runCommand "readme-collect-check"
            {
              buildInputs = with pkgs; [ jq ];
              NIX_CONFIG = "experimental-features = nix-command flakes";
            } ''
            set -euo pipefail
            
            echo "ðŸ” Running README collection verification..."
            
            # Generate documentation index
            echo '${builtins.toJSON (docs.index { root = self.outPath; })}' > readme_index.json
            
            # Validate basic structure
            if ! jq -e '.schemaVersion' readme_index.json > /dev/null; then
              echo "âŒ Missing schemaVersion in index"
              exit 1
            fi
            
            if ! jq -e '.docs' readme_index.json > /dev/null; then
              echo "âŒ Missing docs in index"
              exit 1
            fi
            
            # Check for required fields in collected docs
            ERROR_COUNT=$(jq '.errorCount' readme_index.json)
            if [ "$ERROR_COUNT" -gt 0 ]; then
              echo "âš ï¸ Found $ERROR_COUNT validation errors in documentation"
              jq '.reports' readme_index.json
            fi
            
            # Validate JSON structure integrity
            if ! jq '.' readme_index.json > /dev/null; then
              echo "âŒ Invalid JSON structure in readme index"
              exit 1
            fi
            
            echo "âœ… README collection verification passed"
            echo "collected" > $out
          '';

          # README report generation test  
          readme-report = self'.packages.readme-report;
        };
      };

      # Global flake outputs
      flake = {
        # Library functions for external use
        lib = {
          # Unified documentation library integrating flake-readme
          docs = import "${flake-readme}/lib/core-docs.nix" { 
            lib = nixpkgs.lib; 
            self = self; 
          };
          
          searchReadme = {
            # Utility functions for README searching
            findReadmeFiles = root: 
              let
                lib = nixpkgs.lib;
                allFiles = lib.filesystem.listFilesRecursive root;
              in
              builtins.filter (path: lib.hasSuffix "README.md" (toString path) || lib.hasSuffix "readme.md" (toString path)) allFiles;
            
            # Enhanced search with structured documentation
            findStructuredDocs = root:
              let
                docs = import "${flake-readme}/lib/core-docs.nix" { 
                  lib = nixpkgs.lib; 
                  self = self; 
                };
              in
              docs.index { inherit root; };
          };
        };

        # Templates for project initialization (future feature)
        # templates = {
        #   default = {
        #     path = ./template;
        #     description = "Basic search-readme project template";
        #   };
        # };
      };
    };
}