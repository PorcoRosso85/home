#!/bin/bash
# Organization Coordination Template
# ============================================================
# 責務: 環境準備、タスク配分、状態管理
# 規約: エラー時はフォールバック禁止、失敗を明示的に報告
# ============================================================

set -e

# Configuration
# 環境変数はCLAUDE_プレフィックスを使用（規約）
CLAUDE_KUZU_DB_PATH="${CLAUDE_KUZU_DB_PATH:-~/.kuzu/knowledge.db}"
CLAUDE_MAX_CONCURRENT="${CLAUDE_MAX_CONCURRENT:-3}"

# ============================================================
# CORE FUNCTIONS
# ============================================================

# Create worktree with sparse-checkout
create_worktree() {
    local task_name="$1"
    local target_dir="$2"
    local timestamp=$(date +%s)
    local worktree_path=".worktrees/claude-org/${task_name}-${timestamp}"
    
    # Create worktree
    git worktree add "$worktree_path" -b "claude-${task_name}-${timestamp}" || {
        echo "Error: Failed to create worktree for $task_name"
        return 1
    }
    
    cd "$worktree_path" || return 1
    git sparse-checkout set "$target_dir" || {
        echo "Error: Failed to set sparse-checkout for $target_dir"
        cd - > /dev/null
        return 1
    }
    cd - > /dev/null
    
    # Create session.json
    cat > "$worktree_path/session.json" <<EOF
{
  "task_id": "${task_name}-${timestamp}",
  "target_dir": "$target_dir",
  "created_at": "$(date -Iseconds)",
  "status": "started",
  "completion": 0,
  "worktree_path": "$worktree_path"
}
EOF
    
    echo "$worktree_path"
}

# Get directory context from GraphDB
get_directory_context() {
    local dir_path="$1"
    
    # Query embedded KuzuDB
    local query="MATCH (d:Directory {path: '$dir_path'}) RETURN d.version, d.expected_state, d.required_files"
    local result=$(kuzu --db "$CLAUDE_KUZU_DB_PATH" --query "$query" 2>/dev/null)
    
    if [ $? -ne 0 ] || [ -z "$result" ]; then
        echo "Error: Cannot query KuzuDB at $CLAUDE_KUZU_DB_PATH"
        echo "Ensure database exists and contains directory information"
        return 1
    fi
    
    echo "$result"
}

# Launch member
launch_member() {
    local task_name="$1"
    local worktree_path="$2"
    local description="$3"
    local target_dir="$4"
    
    # Find member SDK
    local sdk_path="$(find . -path "*/member/sdk/claude.ts" | head -1)"
    if [ -z "$sdk_path" ]; then
        echo "Error: Cannot find member SDK"
        return 1
    fi
    
    # Get GraphDB context
    local context=$(get_directory_context "$target_dir")
    if [ $? -ne 0 ]; then
        echo "Error: Cannot get GraphDB context for $target_dir"
        echo "Task $task_name cannot start without context"
        return 1
    fi
    
    # Create PID file
    local pid_file="$worktree_path/claude.pid"
    
    # Prompt with context
    local prompt="$description

作業情報:
- 場所: $worktree_path
- 対象: $target_dir
- KUZU_DB: ${CLAUDE_KUZU_DB_PATH}
- Context: $context

重要な規則:
1. pwd と flake.nix から文脈を把握
2. エラー時は背景を説明してGraphDBに照会
3. エラー解決できない場合は明示的に失敗を報告
4. 進捗は session.json に記録
5. 完了時は 'Task completed: [$task_name]' と報告"

    # Launch member
    CLAUDE_KUZU_DB_PATH="$CLAUDE_KUZU_DB_PATH" nix run nixpkgs#deno -- run --allow-all "$sdk_path" \
        --uri "$worktree_path" \
        --print "$prompt" &
    
    local pid=$!
    echo $pid > "$pid_file"
    
    # Verify launch
    sleep 2
    if ps -p $pid > /dev/null; then
        echo "✓ Member launched: $task_name (PID: $pid)"
        return 0
    else
        echo "✗ Failed to launch member: $task_name"
        rm -f "$pid_file"
        return 1
    fi
}

# ============================================================
# MANAGEMENT FUNCTIONS
# ============================================================

# List all tasks with status
list_status() {
    echo "=== Task Status Overview ==="
    find .worktrees/claude-org -name "session.json" 2>/dev/null | while read session; do
        if [ -f "$session" ]; then
            local task_id=$(jq -r '.task_id' "$session")
            local status=$(jq -r '.status' "$session")
            local completion=$(jq -r '.completion' "$session")
            local pid_file="$(dirname "$session")/claude.pid"
            
            if [ -f "$pid_file" ] && ps -p $(cat "$pid_file") > /dev/null 2>&1; then
                echo "✓ $task_id: $status ($completion%) [ACTIVE]"
            else
                echo "✗ $task_id: $status ($completion%) [INACTIVE]"
            fi
        fi
    done
}

# Cleanup zombie worktrees
cleanup() {
    echo "=== Cleaning up zombies ==="
    find .worktrees/claude-org -name "claude.pid" 2>/dev/null | while read pidfile; do
        if [ -f "$pidfile" ]; then
            local pid=$(cat "$pidfile")
            if ! ps -p "$pid" > /dev/null 2>&1; then
                local worktree=$(dirname "$pidfile")
                echo "Removing zombie: $worktree"
                rm -rf "$worktree"
                git worktree prune 2>/dev/null || true
            fi
        fi
    done
}

# Resume a task
resume_task() {
    local task_pattern="$1"
    local worktree=$(find .worktrees/claude-org -name "*${task_pattern}*" -type d | head -1)
    
    if [ -z "$worktree" ] || [ ! -f "$worktree/session.json" ]; then
        echo "Error: Task not found: $task_pattern"
        return 1
    fi
    
    local task_id=$(jq -r '.task_id' "$worktree/session.json")
    local target_dir=$(jq -r '.target_dir' "$worktree/session.json")
    
    echo "Resuming task: $task_id"
    launch_member "$task_id" "$worktree" "Resume previous work. Check session.json." "$target_dir"
}

# ============================================================
# MAIN INTERFACE
# ============================================================

main() {
    case "${1:-}" in
        --list|--status)
            list_status
            ;;
        --cleanup)
            cleanup
            ;;
        --resume)
            resume_task "$2"
            ;;
        *)
            if [ $# -lt 3 ]; then
                echo "Usage: main <task_name> <target_dir> <description>"
                return 1
            fi
            
            local task_name="$1"
            local target_dir="$2"
            local description="$3"
            
            echo "Creating task: $task_name"
            local worktree=$(create_worktree "$task_name" "$target_dir")
            if [ $? -ne 0 ]; then
                echo "Error: Failed to create worktree"
                return 1
            fi
            
            launch_member "$task_name" "$worktree" "$description" "$target_dir"
            ;;
    esac
}

# ============================================================
# TEMPLATE GUARD
# ============================================================

if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    echo "This is a template. Copy and adapt for your needs."
    exit 1
fi