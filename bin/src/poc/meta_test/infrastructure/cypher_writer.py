"""Cypher query writer for persisting learning results."""

from datetime import datetime
from pathlib import Path
from typing import Any


class CypherWriter:
    """Writes learning results as Cypher queries."""

    def __init__(self, output_dir: str):
        """Initialize writer with output directory."""
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def write_metric_update(self,
                          requirement_id: str,
                          metric_name: str,
                          old_value: float,
                          new_value: float,
                          confidence_interval: tuple[float, float]) -> str:
        """Write metric update as Cypher query."""
        timestamp = datetime.now()

        query = f"""
// Metric update for {requirement_id} - {metric_name}
// Generated at: {timestamp.isoformat()}
MATCH (r:RequirementEntity {{id: '{requirement_id}'}})
MERGE (m:MetricValue {{requirement_id: '{requirement_id}', metric_name: '{metric_name}'}})
SET m.previous_value = {old_value},
    m.current_value = {new_value},
    m.confidence_lower = {confidence_interval[0]},
    m.confidence_upper = {confidence_interval[1]},
    m.updated_at = datetime('{timestamp.isoformat()}')
CREATE (m)-[:METRIC_UPDATE {{timestamp: datetime('{timestamp.isoformat()}'), 
                            old_value: {old_value}, 
                            new_value: {new_value}}}]->(r);
"""
        return query.strip()

    def write_learning_batch(self, updates: list[dict[str, Any]]) -> None:
        """Write batch of learning updates to daily file."""
        date_str = datetime.now().strftime("%Y-%m-%d")
        output_file = self.output_dir / f"{date_str}.cypher"

        queries = []
        queries.append(f"// Learning updates for {date_str}")
        queries.append("// Auto-generated by meta-test learning system")
        queries.append("")

        for update in updates:
            query = self.write_metric_update(
                update["requirement_id"],
                update["metric_name"],
                update["old_value"],
                update["new_value"],
                update["confidence_interval"]
            )
            queries.append(query)
            queries.append("")

        # Append to file if exists, otherwise create
        mode = "a" if output_file.exists() else "w"
        with output_file.open(mode) as f:
            f.write("\n".join(queries))
            f.write("\n")

    def write_test_metadata(self,
                          requirement_id: str,
                          test_id: str,
                          metadata: dict[str, Any]) -> str:
        """Write test metadata as Cypher query."""
        timestamp = datetime.now()

        # Build SET clause for metadata
        set_clauses = []
        for key, value in metadata.items():
            if isinstance(value, str):
                set_clauses.append(f"t.{key} = '{value}'")
            elif isinstance(value, (int, float)):
                set_clauses.append(f"t.{key} = {value}")
            elif isinstance(value, bool):
                set_clauses.append(f"t.{key} = {str(value).lower()}")

        query = f"""
// Test metadata update for {test_id}
// Generated at: {timestamp.isoformat()}
MATCH (r:RequirementEntity {{id: '{requirement_id}'}})
MATCH (t:TestSpecification {{id: '{test_id}'}})
SET {', '.join(set_clauses)},
    t.metadata_updated_at = datetime('{timestamp.isoformat()}');
"""
        return query.strip()

    def write_correlation_discovery(self,
                                  requirement_id: str,
                                  metric_name: str,
                                  correlated_with: str,
                                  correlation_strength: float) -> str:
        """Write discovered correlation as Cypher query."""
        timestamp = datetime.now()

        query = f"""
// Correlation discovery for {requirement_id}
// Generated at: {timestamp.isoformat()}
MATCH (r:RequirementEntity {{id: '{requirement_id}'}})
MERGE (c:Correlation {{
    requirement_id: '{requirement_id}',
    metric_name: '{metric_name}',
    correlated_with: '{correlated_with}'
}})
SET c.strength = {correlation_strength},
    c.discovered_at = datetime('{timestamp.isoformat()}')
CREATE (r)-[:HAS_CORRELATION {{strength: {correlation_strength}}}]->(c);
"""
        return query.strip()
