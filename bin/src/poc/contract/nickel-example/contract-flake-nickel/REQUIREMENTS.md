# Nickel-based Contract System - 要件仕様書

## 1. 背景・動機

### 1.1 TypeScript版の限界
現在のTypeScript版契約システム（`/home/nixos/bin/src/example/contract-flake-bun/`）は以下の制約により、大規模なflake環境での運用に適さない：

#### **実行時検証の問題**
- 契約の不整合は実行時にしか検出されない
- TypeScript型システムは契約間の互換性を保証しない
- Producer/Consumer間の型不整合が本番環境で発覚する

#### **言語依存性による制約**
- Node.js/Bunランタイム必須
- 重い依存関係チェーン（Node.js → TypeScript → Zod → Bun）
- Go、Rust、Pythonなど他言語からの利用困難

#### **スケーラビリティの限界**
- O(n²)の複雑さで大規模環境に対応困難
- 1000flake環境での運用は非現実的
- メモリ使用量とCPU負荷の増大

### 1.2 Nickelが解決する根本問題
Nickelは設定管理に特化した言語として、以下の根本的解決を提供：

- **静的契約検証**: コンパイル時の型チェックで事前エラー検出
- **言語中立性**: JSON出力による普遍的な互換性
- **Nix親和性**: Nixエコシステムとの自然な統合
- **ゼロランタイムコスト**: 実行時オーバーヘッドなし

## 2. 解決すべき課題

### 2.1 **実行時契約検証からの脱却**

**現状の問題**：
```typescript
// TypeScript: 実行時まで不整合が検出されない
const producer: DataProviderContract = { format: "json", schema: "users" };
const consumer: DataConsumerContract = { format: "xml", schema: "products" };
// ↑ 互換性のない契約だが、TypeScriptコンパイラは通してしまう
```

**Nickelでの解決**：
```nickel
# 静的型チェックで即座に不整合を検出
ProducerContract = { format | "json", schema | "users" }
ConsumerContract = { format | "xml", schema | "products" }
# ↑ nickel typecheck時に型不整合エラー
```

### 2.2 **1000flakeスケーラビリティ対応**

**現状の制約**：
- TypeScript版：O(n²)の契約クロスバリデーション
- 1000flakeで100万回の互換性チェック
- メモリ使用量：約1GB、実行時間：数分

**目標**：
- Nickel版：O(n)の静的型チェック
- コンパイル時の一括検証
- メモリ使用量：100MB以内、実行時間：10秒以内

### 2.3 **言語依存性の排除**

**現状の制約**：
```bash
# TypeScript版：重い依存関係
nix develop         # Node.js環境構築
bun install         # パッケージ依存関係解決
bun run validate.ts # 実行時バリデーション
```

**目標**：
```bash
# Nickel版：軽量で言語中立
nickel typecheck contracts.ncl  # 静的検証のみ
nickel export --format=json > contracts.json  # 任意言語で利用可能
```

## 3. 機能要件

### 3.1 **静的契約検証システム**

#### FR-001: コンパイル時型チェック
- **要件**: 契約定義の型不整合をnickel typecheckで検出
- **入力**: Nickel契約定義ファイル(.ncl)
- **出力**: 型エラー詳細またはtype check成功
- **例外処理**: 型エラー時の詳細な原因特定

#### FR-002: 契約互換性検証
- **要件**: Producer/Consumer間の契約互換性を静的に検証
- **実装**: 型レベルでの契約マッチング
- **検証項目**:
  - フィールド型の互換性（Number, String, Array等）
  - 必須フィールドの存在確認
  - 制約条件の整合性（非負数、文字列長等）

#### FR-003: 制約システム統合
- **要件**: 値制約を型システムに統合
- **実装例**:
```nickel
ProcessedCount = Number & fun x => if x >= 0 then x else std.contract.blame "非負数必須"
OutputItems = Array String & fun arr => if std.array.length arr <= 1000 then arr else std.contract.blame "1000項目以内"
```

### 3.2 **大規模環境対応（O(n)スケーラビリティ）**

#### FR-004: 線形時間複雑度
- **要件**: 1000flake環境でO(n)時間複雑度を維持
- **実装**: 静的型チェックによる一括検証
- **パフォーマンス目標**: N個のflakeに対してO(N)時間

#### FR-005: メモリ効率性
- **要件**: 大規模環境でのメモリ使用量を100MB以内に制限
- **実装**: ストリーミング処理とメモリ効率的なデータ構造

### 3.3 **実行前エラー検出**

#### FR-006: 静的エラー検出
- **要件**: flake実行前に全契約エラーを検出
- **検出対象**:
  - 型不整合（String vs Number等）
  - 必須フィールド欠損
  - 制約違反（負数、配列長等）

#### FR-007: 詳細エラー診断
- **要件**: エラー原因の特定と修正指針の提供
- **実装**: error_diagnostics.nclによるエラー分析
- **出力**: ファイル名、行番号、具体的な修正方法

### 3.4 **言語中立インターフェース**

#### FR-008: JSON出力システム
- **要件**: 任意の言語から利用可能なJSON契約出力
- **実装**: `nickel export --format=json`によるJSONエクスポート
- **対応言語**: Go, Rust, Python, JavaScript等すべての主要言語

## 4. 非機能要件

### 4.1 **パフォーマンス要件**

#### NFR-001: 実行時間制約
- **1000flake検証**: 10秒以内（TypeScript版は数分）
- **単一flake検証**: 100ms以内
- **契約変更後の再検証**: 1秒以内

#### NFR-002: メモリ使用量制約
- **最大メモリ使用量**: 100MB以内
- **1000flake同時処理**: 平均0.1MB/flake
- **メモリリーク**: 長時間実行時のメモリ増加なし

#### NFR-003: CPU使用率
- **最大CPU使用率**: 単一コアの80%以内
- **並列処理対応**: マルチコア環境での効率的な並列化

### 4.2 **可用性要件**

#### NFR-004: 可靠性
- **契約検証精度**: 100%（偽陽性・偽陰性なし）
- **エラー検出率**: 契約違反の100%検出
- **稼働時間**: 24/7運用での99.9%可用性

#### NFR-005: 保守性
- **契約定義の可読性**: ドメインエキスパートが理解可能
- **エラーメッセージ**: 5分以内で問題原因を特定可能
- **デバッグ効率**: TypeScript版比50%短縮

### 4.3 **移植性要件**

#### NFR-006: プラットフォーム独立性
- **対応OS**: Linux, macOS, Windows
- **CPU アーキテクチャ**: x86_64, ARM64
- **Nixバージョン**: 2.18以降

#### NFR-007: 言語独立性
- **ランタイム非依存**: 言語固有のランタイム不要
- **標準フォーマット**: JSON/YAMLでの契約表現
- **APIの安定性**: セマンティックバージョニング準拠

## 5. 成功基準

### 5.1 **主要成功指標**

#### KPI-001: Producer→Consumerパイプライン動作
```bash
# 統合テスト成功
cd examples/chain/
nix run .#producer | nix run .#consumer
# 終了コード: 0、エラー出力なし
```

#### KPI-002: 契約違反の事前検出
```bash
# 静的検証での違反検出
echo 'invalid_contract = { processed | String }' > test.ncl
nickel typecheck test.ncl
# 期待結果: 型エラーで終了、詳細な原因説明
```

#### KPI-003: 型安全性の保証
- **静的型チェック**: 100%の型不整合検出
- **実行時エラー**: 契約関連のランタイムエラーゼロ
- **相互運用性**: 他言語からのJSON利用100%成功

### 5.2 **パフォーマンス達成基準**

#### Benchmark-001: 大規模環境性能
- **1000flake検証時間**: 10秒以内（現在のTypeScript版は数分）
- **メモリピーク**: 100MB以内（TypeScript版は約1GB）
- **スループット**: 100flake/秒以上

#### Benchmark-002: 開発者体験向上
- **エラー検出時間**: 保存と同時（TypeScript版は実行時）
- **修正サイクル**: エラー→修正→検証が1分以内
- **学習コスト**: 基本概念習得が1時間以内

### 5.3 **品質保証基準**

#### QA-001: 契約システム完全性
- **型システム健全性**: 型安全性を破る契約定義が存在しない
- **制約システム完全性**: すべての制約が適切に動作
- **エラー報告精度**: エラー原因特定100%、修正提案90%以上

#### QA-002: 運用安定性
- **長期運用**: 1ヶ月間の連続稼働での問題なし
- **負荷耐性**: 同時1000契約処理での安定動作
- **メモリリーク**: 長時間運用でのメモリ増加なし

## 6. 実装制約・前提条件

### 6.1 **技術制約**
- **Nickel言語**: バージョン1.0以降
- **Nix**: バージョン2.18以降  
- **アーキテクチャ**: x86_64, ARM64
- **メモリ要件**: 最低128MB

### 6.2 **運用制約**
- **習得コスト**: Nickel言語の基本習得が必要
- **移行期間**: TypeScript版からの段階的移行
- **互換性**: 既存flakeとの後方互換性維持

### 6.3 **品質制約**
- **テストカバレッジ**: 90%以上
- **ドキュメント**: 全機能のドキュメント化
- **エラーハンドリング**: すべての異常系の適切な処理

---

この要件仕様書は、Nickel-based契約システムがTypeScript版の根本的な問題を解決し、大規模なNix flake環境での実用的な運用を可能にするための技術要件を定義している。静的検証、言語中立性、O(n)スケーラビリティという3つの核心価値を通じて、次世代のflake契約管理システムを実現する。