# レビュー: 要件重複検出におけるハイブリッドアプローチの提案

**レビュアー:** Gemini
**作成日:** 2024年07月15日

## 1. 現状の課題分析

現在の要件重複検出機能は、全`RequirementEntity`ノードを対象に類似度計算を行っている。このアプローチは網羅的である一方、以下の課題を抱えている。

- **パフォーマンス問題:** 要件数が増加するにつれて、計算コストが線形的に増大し、リアルタイムでのフィードバックが困難になる。
- **文脈の欠如:** `locationUri`（要件の出自や文脈）を考慮していないため、偶然テキストが似ているだけの無関係な要件をノイズとして検出してしまう可能性がある。

## 2. 提案: `locationUri`を活用したハイブリッドアプローチ

これらの課題を解決するため、**即時性**と**網羅性**を両立させるハイブリッドアプローチを提案する。このアプローチは、Cypherによる高速な「ローカル探索」と、ベクトルインデックスを利用した「グローバル探索」の2段階で構成される。

### ステップ1: ローカル探索（同期処理）

ユーザーが要件を新規作成する際に、即座に実行されるべき処理。

- **目的:** 最も可能性の高い重複（同一・近傍コンテキスト内の要件）を高速に検出し、即時フィードバックを提供する。
- **手法:**
    1. 新規要件が属する`locationUri`および、`CONTAINS_LOCATION`関係で接続された親子・兄弟関係の`locationUri`に探索空間を限定する。
    2. Cypherクエリを用いて、この限定された空間内の`RequirementEntity`のみを対象に類似度計算を実行する。
- **期待される効果:**
    - **高速応答:** 探索対象が大幅に削減されるため、ユーザーを待たせることなく結果を返せる。
    - **高精度:** 文脈が近いため、検出される重複候補の妥当性が高い。

#### Cypherクエリ（概念）
```cypher
// $new_location_uri, $new_embedding をパラメータとして受け取る
// 1. 探索範囲となるURI（自身、親、子）を特定
MATCH (target_uri:LocationURI {id: $new_location_uri})
CALL {
    WITH target_uri RETURN target_uri AS search_uri
    UNION
    WITH target_uri MATCH (p:LocationURI)-[:CONTAINS_LOCATION]->(target_uri) RETURN p AS search_uri
    UNION
    WITH target_uri MATCH (target_uri)-[:CONTAINS_LOCATION]->(c:LocationURI) RETURN c AS search_uri
}
// 2. 範囲内の要件と類似度を計算
MATCH (search_uri)-[:LOCATES]->(existing_req:RequirementEntity)
WITH existing_req, algo.similarity.cosine(existing_req.embedding, $new_embedding) AS score
WHERE score > 0.9 // 高めの閾値
RETURN existing_req.id, score
ORDER BY score DESC
```

### ステップ2: グローバル探索（非同期処理）

ローカル探索で重複が見つからなかった場合や、定期的なバッチ処理としてバックグラウンドで実行されるべき処理。

- **目的:** `locationUri`のコンテキストを越えて、システム全体に存在する未知の重複（サイロ化した重複）を網羅的に発見する。
- **手法:**
    1. `RequirementEntity`の`embedding`フィールドに構築されたベクトルインデックスを利用する。
    2. 全ての`RequirementEntity`を対象に、高速なベクトル類似検索（ANN）を実行する。
- **期待される効果:**
    - **網羅性:** 異なるファイルやディレクトリに存在する重複も見逃さない。
    - **システム整合性の維持:** 定期的に実行することで、システムの健全性を保つ。

#### 処理フロー
- この処理は時間がかかる可能性があるため、バックグラウンドジョブとしてキューイングする。
- 重複候補が発見された場合、ダッシュボードへの通知やアラートなど、非同期的な方法でユーザーに知らせる。

## 3. 補論: `locationUri`の設計思想上の本質的意義

ハイブリッドアプローチの議論において、`locationUri`の役割を単なる「パフォーマンス向上のためのフィルタ」と見なすべきではない。パフォーマンス向上は副次的なメリットに過ぎない。

`locationUri`の真の意義は、以下の3つの設計原則に集約される。

1.  **トレーサビリティの確立:** `locationUri`は、抽象的な要件ノードと、その根拠となる物理的なソース（ファイル、ドキュメント）を結びつける命綱である。これにより、要件の出自と正当性が保証される。

2.  **「文脈」の構造化:** `locationUri`は、ファイルパスのような人間が意図した意味的グルーピング（=文脈）をグラフ構造に持ち込む。これにより、システムは「何が書かれているか(What)」だけでなく、「どこに書かれているか(Where)」を理解し、より人間的な判断が可能になる。

3.  **データガバナンスの基盤:** `locationUri`は、要件のライフサイクル管理、影響範囲分析、一意性制約といったデータ品質を維持するためのルールを定義する上での基盤となる。

結論として、`locationUri`は、要件グラフを信頼性と追跡性の高い「デジタルツイン」へと昇華させるための根源的な設計要素である。

## 4. 結論

`locationUri`のグラフ構造を活用して探索空間を絞る「ローカル探索」と、ベクトルインデックスで全件を対象とする「グローバル探索」を組み合わせることで、パフォーマンスと網羅性のトレードオフを解消できる。

このハイブリッドアプローチにより、ユーザー体験を損なうことなく、より高度で信頼性の高い重複検出機能を実現できると結論付ける。