# 要件定義における摩擦スコアリング仕様

## 概要

チーム開発において、要件定義プロセスで生じる「摩擦」を定量化し、プロジェクトの健全性を評価するためのスコアリングシステム。

## 摩擦の種類と計算ロジック

### 1. 曖昧性摩擦（Ambiguity Friction）

**定義**: 曖昧な表現により、ステークホルダー間で異なる解釈が生じる摩擦

**スコア計算**:
```
解釈数 ≥ 2: -0.6（重大な曖昧性）
解釈数 = 1: -0.3（軽度の曖昧性）
解釈数 = 0: 0.0（明確）
```

**実例**:
- 要件: 「ユーザーフレンドリーな検索機能」
- 開発者解釈: 「Elasticsearch導入で高速検索」
- デザイナー解釈: 「シンプルな単一検索ボックス」
- 結果: 解釈数 = 2、スコア = -0.6

### 2. 優先度摩擦（Priority Friction）

**定義**: 複数のステークホルダーが異なる要件を最優先（critical）と主張することで生じる摩擦

**スコア計算**:
```
critical要件数 > 2 かつ 競合あり: -0.7
critical要件数 > 1: -0.4
それ以外: 0.0
```

**実例**:
- 営業: 「顧客向けダッシュボード」をcritical
- 開発: 「技術的負債の解消」をcritical
- セキュリティ: 「認証システム強化」をcritical
- 結果: critical数 = 3、競合あり、スコア = -0.7

### 3. 時間経過摩擦（Temporal Friction）

**定義**: 時間経過により要件が当初の意図から変質していく摩擦

**スコア計算**:
```
進化段階 ≥ 2 かつ AI機能追加: -0.8（完全な変質）
進化段階 ≥ 2: -0.5（大幅な変化）
進化段階 = 1: -0.3（軽度の変化）
変化なし: 0.0
```

**実例**:
- 1月: 「リアルタイム通知システム」（2週間見積）
- 2月: 「マルチチャネル通知システム」（6週間見積）
- 3月: 「AIドリブン通知最適化システム」（3ヶ月見積）
- 結果: 進化段階 = 2、AI機能あり、スコア = -0.8

### 4. 矛盾摩擦（Contradiction Friction）

**定義**: 相反する要求が同時に存在することで生じる摩擦

**スコア計算**:
```
矛盾要件数 ≥ 3: -0.9（解決困難）
矛盾要件数 = 2: -0.6（深刻な対立）
矛盾要件数 = 1: -0.4（通常の対立）
矛盾なし: 0.0
```

**実例**:
- 要求1: 「インフラコスト50%削減」
- 要求2: 「レスポンスタイム50%改善」
- 要求3: 「大口顧客向けカスタマイズ機能」
- 結果: 3つの要求が相互に矛盾、スコア = -0.9

## 総合スコアの計算

### 重み付け

```
総合スコア = 曖昧性スコア × 0.2
           + 優先度スコア × 0.3
           + 時間経過スコア × 0.2
           + 矛盾スコア × 0.3
```

### 重み付けの根拠

| 摩擦の種類 | 重み | 理由 |
|-----------|------|------|
| 優先度摩擦 | 30% | プロジェクト進行に直接影響する最重要因子 |
| 矛盾摩擦 | 30% | 解決が困難で、プロジェクトを停滞させる |
| 曖昧性摩擦 | 20% | 早期発見・解決が可能 |
| 時間経過摩擦 | 20% | 予防可能だが、放置すると深刻化 |

## プロジェクト健全性の判定

```
総合スコア > -0.2: healthy（健全）
総合スコア > -0.5: needs_attention（要注意）
総合スコア > -0.7: at_risk（リスクあり）
総合スコア ≤ -0.7: critical（危機的）
```

### 各レベルの対応方針

#### healthy（健全）
- 軽微な摩擦のみ
- 通常の運用プロセスで対処可能
- 定期的なモニタリングを継続

#### needs_attention（要注意）
- 中程度の摩擦が存在
- 週次レビューでの確認推奨
- 早期の対処で悪化を防止

#### at_risk（リスクあり）
- 深刻な摩擦が複数存在
- 即座の介入が必要
- ステークホルダー会議の開催

#### critical（危機的）
- プロジェクトの根本的見直しが必要
- 要件の再定義
- 優先順位の全面的な再調整

## 実装への反映

### 検出方法

1. **曖昧性**: `DEPENDS_ON {dependency_type: 'interpretation'}` の数をカウント
2. **優先度**: `priority = 'critical'` の要件数と競合をチェック
3. **時間経過**: `DEPENDS_ON {dependency_type: 'evolution'}` のチェーン長
4. **矛盾**: `DEPENDS_ON {dependency_type: 'contradiction'}` を持つ要件数

### データ構造

```cypher
// 解釈の相違
CREATE (dev_interp)-[:DEPENDS_ON {
    dependency_type: 'interpretation',
    reason: 'developer interpretation: focus on technical performance'
}]->(original_req)

// 優先度競合
CREATE (req1)-[:DEPENDS_ON {
    dependency_type: 'priority_conflict',
    reason: 'dev_team suggests medium priority'
}]->(req2)

// 要件の進化
CREATE (v2)-[:DEPENDS_ON {
    dependency_type: 'evolution',
    reason: 'scope_expansion: 30 days, effort +200%'
}]->(v1)

// 矛盾
CREATE (cost_reduction)-[:DEPENDS_ON {
    dependency_type: 'contradiction',
    reason: 'contradicts with performance improvement'
}]->(performance_improvement)
```

## 活用方法

### 1. 定期的なスコア評価
- スプリント開始時に総合スコアを計算
- スコアの推移をトラッキング
- 悪化傾向の早期発見

### 2. 意思決定への活用
- 要件追加時の影響予測
- リファクタリングの優先順位付け
- ステークホルダー会議の必要性判断

### 3. 改善アクション
- 曖昧性摩擦 → 要件の具体化ワークショップ
- 優先度摩擦 → ステークホルダー調整会議
- 時間経過摩擦 → 要件の定期レビュー
- 矛盾摩擦 → トレードオフ分析と合意形成

## 参考資料

- E2Eテスト: `test_e2e_team_friction_scenarios.py`（実行可能な仕様）
- スコアリング実装: `application/scoring_service.py`
- スキーマ定義: `ddl/schema.cypher`