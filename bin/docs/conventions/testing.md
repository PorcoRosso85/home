# テストの哲学：正規化された実行可能な仕様書

> 📚 関連ファイル
> - 実践手順 → [tdd_process.md](./tdd_process.md)
> - このファイルは「なぜ・何を」テストするかを定義
> - tdd_process.mdは「どのように・いつ」テストするかを定義

我々のテストコードは、単なる実装の検証ツールであってはならない。それは、システムの**主要な振る舞いを理解するための、最も信頼できるドキュメント**であり、リファクタリングを容易にし、仕様変更の指針となる**「実行可能な仕様書」**であるべきだ。

テストは、要件や仕様を**「正規化」**したものでなければならない。データベースの正規化がデータの重複を排除するように、我々のテストはロジックの重複を排除し、仕様をクリーンで構造化された形（ルール、テーブル、スナップショット）で表現する。

## 黄金律：「リファクタリングの壁」の原則

すべてのテスト設計は、この一つの問いに集約される。

> **「もし、実装コードが壁の向こう側にあって全く見えないとしたら、このテストは書けるか？」**

この問いに「Yes」と答えられるテストだけが、我々が書くべき価値のあるテストである。テストコードは、公開されたインターフェース（Public API）とその仕様書だけを頼りに、その**「振る舞い (What)」**を検証しなければならない。

---

## 実践ガイドライン

上記の黄金律から、以下の具体的なガイドラインが導かれる。

### 1. テスト対象のレイヤー：DDDの地図を使う

テスト戦略は、ドメイン駆動設計（DDD）のレイヤー構造に従う。これにより、テストのROI（投資対効果）を最大化する。

- **ドメイン層 (Domain Layer)**: **単体テストを集中させるべき唯一の場所。**
  - **理由**: ビジネスロジックの核心であり、外部依存が少ないため、高速で価値の高いテストが可能。
  - **対象**: Aggregateの不変条件、Value Objectの妥当性検証、Domain Serviceの振る舞い。

- **アプリケーション層 (Application Layer)**: **単体テストは原則禁止。**
  - **理由**: この層の単体テストは、モックを多用した「実装のコピー」になりがちで、ROIが著しく低い。
  - **テスト方法**: ユースケース単位の**統合テスト**で、外部から観測可能な結果（DBの状態変化、発行されたイベント等）を検証する。

- **インフラストラクチャ層 (Infrastructure Layer)**: **単体テストは禁止。**
  - **理由**: この層の単体テストは、外部システム（DB, API）との最も重要な対話を検証できず、「嘘をつくテスト」になる。
  - **テスト方法**: 実際のDBや外部サービス（またはテストコンテナ）と接続する、ごく少数の**統合テスト**で「契約」が守られていることを確認する。

> **結論：単体テストは、ドメイン層のためにある。**

### 2. テスト対象のスコープ

- **何をテストするか**: 公開されたインターフェース（Public API）の振る舞いのみ。
- **何をテストしないか**: 非公開な実装の詳細（Privateメソッド、移譲の事実、自明なコード、外部ライブラリの機能）。
  > **経験則**: 非公開メソッドをテストしたくなったら、責務が大きすぎるサイン。責務を新しいクラスに抽出し、その公開APIをテストせよ。

### 3. テスト手法の選択基準

テストは、検証したい「仕様」の性質に応じて、以下の手法を使い分ける。

| 仕様の性質 | 推奨手法 | 指導原則 |
| :--- | :--- | :--- |
| **普遍的なルール** | **プロパティベーステスト (PBT)** | 「どんな入力でも、このルールを守れるか？」 |
| **具体的な代表例** | **テーブル駆動テスト (TDT)** | 「この機能に、明確なシナリオは存在するか？」 |
| **複雑な成果物** | **スナップショットテスト (SST)** | 「成果物は、目で見てレビューするのが効率的か？」 |

### 4. レガシーコードへの対応戦略

既存コードに対しては、黄金律を守りつつ現実的なアプローチを取る。

- **特性テスト（Characterization Test）**: 既存の振る舞いを「正しいか」ではなく「現状どうか」を記録する
- **段階的改善**: 変更が必要な箇所から順次テストを追加し、全体を一度にテスト化しない
- **Seam（継ぎ目）の特定**: テスト可能な境界を見つけ、そこから保護を始める

> **注意**: レガシーコードのテスト戦略の詳細は [tdd_process.md](./tdd_process.md) の「既存コード改修TDD」を参照

---

## テストとアプリケーションの整合性確認

テストの価値は、アプリケーションの目的・要件との整合性によって決まる。以下の観点で確認する：

### 1. テスト＝仕様の確認
- テストが何を担保しているか明確か
- 各テストケースが具体的な要件に対応しているか
- テストスイート全体で要件カバレッジは十分か

### 2. アプリケーション要件への貢献度
- そのテストがなければ要件を満たせないか
- テストが過剰または不足していないか
- 変更時の安全網として機能するか

### 3. テスト哲学の遵守
- 黄金律「リファクタリングの壁」を守っているか
- 適切なレイヤーでテストされているか
- 実装詳細ではなく振る舞いを検証しているか

### 4. テスト実行環境
- `nix run .#test` コマンドで実行可能か
- CIでの自動実行が設定されているか
- テスト実行時間は妥当か（フィードバックループ）

---

## 補遺：技術的詳細

テストの技術的な実装詳細（ファイル命名、ランナー設定、CI統合など）については、[test_infrastructure.md](./test_infrastructure.md) を参照。
