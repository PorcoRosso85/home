# テストの哲学：正規化された実行可能な仕様書

我々のテストコードは、単なる実装の検証ツールであってはならない。それは、システムの**主要な振る舞いを理解するための、最も信頼できるドキュメント**であり、リファクタリングを容易にし、仕様変更の指針となる**「実行可能な仕様書」**であるべきだ。

テストは、要件や仕様を**「正規化」**したものでなければならない。データベースの正規化がデータの重複を排除するように、我々のテストはロジックの重複を排除し、仕様をクリーンで構造化された形（ルール、テーブル、スナップショット）で表現する。

## 黄金律：「リファクタリングの壁」の原則

すべてのテスト設計は、この一つの問いに集約される。

> **「もし、実装コードが壁の向こう側にあって全く見えないとしたら、このテストは書けるか？」**

この問いに「Yes」と答えられるテストだけが、我々が書くべき価値のあるテストである。テストコードは、公開されたインターフェース（Public API）とその仕様書だけを頼りに、その**「振る舞い (What)」**を検証しなければならない。

---

## 実践ガイドライン

上記の黄金律から、以下の具体的なガイドラインが導かれる。

### 1. テスト対象

- **何をテストするか**: 公開されたインターフェース（Public API）の振る舞いのみ。
- **何をテストしないか**: 非公開な実装の詳細（Privateメソッド、移譲の事実、自明なコード、外部ライブラリの機能）。
  > **経験則**: 非公開メソッドをテストしたくなったら、責務が大きすぎるサイン。責務を新しいクラスに抽出し、その公開APIをテストせよ。

### 2. テスト手法の選択基準

テストは、検証したい「仕様」の性質に応じて、以下の手法を使い分ける。

| 仕様の性質 | 推奨手法 | 指導原則 |
| :--- | :--- | :--- |
| **普遍的なルール** | **プロパティベーステスト (PBT)** | 「どんな入力でも、このルールを守れるか？」 |
| **具体的な代表例** | **テーブル駆動テスト (TDT)** | 「この機能に、明確なシナリオは存在するか？」 |
| **複雑な成果物** | **スナップショットテスト (SST)** | 「成果物は、目で見てレビューするのが効率的か？」 |

---

## 補遺：具体的な規約

- **テストファイルの配置**: テスト対象と同じディレクトリに配置する。
- **ファイル命名規則**:
  - Python: `test_<target>.py`
  - TypeScript: `<target>.test.ts`
  - Go: `<target>_test.go`
- **テストランナー**:
  - Python: `pytest`
  - TypeScript: `node:test` / `deno test`
  - Go: `go test`
