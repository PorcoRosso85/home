# エラー処理

## 原則

**エラーを戻り値として扱う。**

例外の投げ上げ（`throw`, `raise`, `panic`）による制御フローのジャンプは、予期せぬ動作やエラーの見逃しに繋がるため、原則として禁止します。関数の成功・失敗は、すべて戻り値で表現します。

## ルール

- `try/catch` は使用可能ですが、捕捉したエラーは必ず値として返し、再度 `throw` してはいけません。
- エラーオブジェクトやメッセージは、スタックトレースを含め、情報を欠落させずにそのまま上位の関数に伝播させます。
- ジェネリックな `Result` 型は禁止します。各関数は、その処理内容に応じた具体的な成功型と失敗型を定義します。
- **フォールバック処理の禁止**: エラー時に別の型や代替実装に自動的に切り替える「フォールバック」は禁止します。例えば、JSON型が使えない場合にSTRING型で代替するような実装は、エラーを隠蔽し、期待される動作を変更するため許可されません。エラーは明示的に返し、呼び出し元に判断を委ねます。

## 実装パターン

| 言語 | パターン |
| :--- | :--- |
| **TypeScript** | `type Result = { ok: true; data: Data } \| { ok: false; error: Error };` |
| **Python** | `Union[SuccessType, ErrorDict]` （`TypedDict`を使用） |
| **Go** | `(result, error)` の多値返し |
| **Rust** | `Result<T, E>` （標準ライブラリのResult型） |
| **Zig** | `!T` （エラーユニオン） |

**Note**: Rustの `Result` は言語仕様の根幹であり、ジェネリックではありますがこの規約の例外として許容します。Zigのエラーユニオンも同様です。
