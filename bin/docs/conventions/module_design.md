# モジュール設計

## アーキテクチャ

軽量DDD（Domain-Driven Design）およびヘキサゴナルアーキテクチャの本質を取り入れた、関数主体のアーキテクチャを採用します。

## 基本ルール

- **1ファイル1公開機能**: 1つのファイルは、主となる公開機能を1つだけ持つことを原則とします。
- **純粋関数を優先**: 可能な限り、副作用のない純粋な関数として機能を実装します。
- **高階関数で柔軟性を実現**: 依存性の注入や機能の拡張には、高階関数（関数を返す関数）を活用します。
- **`mod.{ext}`から一元エクスポート**: モジュール内の公開APIは、`mod.{ext}`（例: `mod.ts`, `__init__.py`）ファイルからまとめてエクスポートし、外部からの利用者はこのファイルのみを参照するようにします。
- **ESモジュールのみ使用**: JavaScript/TypeScriptではESモジュール（ESM）のみを使用し、CommonJS（require/module.exports）は禁止します。

## 開始方法

### 最小構成（3ファイルから開始）

```
module/
├── application.{ext}    # ユースケース
├── domain.{ext}         # ビジネスロジック
├── infrastructure.{ext} # 外部接続
├── variables.{ext}      # 環境変数・設定値（必須）
└── mod.{ext}           # エクスポート（型情報を含む公開API）
```

### 成長時の分割

ファイルが大きくなったら同名ディレクトリに分割：

```
module/
├── application/
│   └── *.{ext}
├── domain/
│   └── *.{ext}
├── infrastructure/
│   ├── *.{ext}
│   └── variables/        # 大規模時は専用ディレクトリ
│       └── *.{ext}
├── variables.{ext}       # 小規模時は単一ファイル
└── mod.{ext}
```

## エントリーポイント

- **ライブラリのみ**: `mod.{ext}`が唯一のエントリーポイント
- **CLI付き**: `main.{ext}`を追加（`mod.{ext}`をインポートして使用）

## 依存関係とインポート規約

### 依存方向の統一（全言語共通）
- infrastructure → domain ✅
- application → domain ✅
- domain → infrastructure ❌（禁止）
- 同一レイヤー内の依存は自由

### インポート方式
各言語の慣習に従いつつ、以下の原則を守る：

| 対象 | 方式 | 理由 |
|:--|:--|:--|
| モジュール内 | 各言語の相対的記法 | 内部結合の明示 |
| モジュール間 | 各言語の絶対的記法 | 公開APIの利用 |
| 判定基準 | `mod.{ext}`の存在 | モジュール境界の明確化 |

### ファイル構造による制御
```
module/
├── mod.{ext}          # 外部公開API（このファイル経由のみ）
├── internal/          # 内部実装（外部からインポート禁止）
│   ├── domain/
│   └── infrastructure/
└── public/            # 公開型定義
    └── types.{ext}
```

## 環境変数・設定値管理

### 必須ファイル
- **小規模**: `variables.{ext}` - 単一ファイルですべての環境変数を管理
- **大規模**: `infrastructure/variables/*.{ext}` - 機能別に分割

### 実装原則
- グローバル状態の禁止（関数として提供）
- デフォルト値の禁止（必須変数は明示的にエラー）
- 型安全性の確保（TypedDict/type/structで定義）

## 設計に迷ったら

「どの層に配置すべきか」「いつ分割すべきか」で迷った場合は、まず小さく実装し、必要に応じてリファクタリングしてください。
