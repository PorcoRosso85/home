# モジュール設計

## アーキテクチャ

軽量DDD（Domain-Driven Design）およびヘキサゴナルアーキテクチャの本質を取り入れた、関数主体のアーキテクチャを採用します。

## 基本ルール

- **1ファイル1公開機能**: 1つのファイルは、主となる公開機能を1つだけ持つことを原則とします。
- **純粋関数を優先**: 可能な限り、副作用のない純粋な関数として機能を実装します。
- **高階関数で柔軟性を実現**: 依存性の注入や機能の拡張には、高階関数（関数を返す関数）を活用します。
- **`mod.{ext}`から一元エクスポート**: モジュール内の公開APIは、`mod.{ext}`（例: `mod.ts`, `__init__.py`）ファイルからまとめてエクスポートし、外部からの利用者はこのファイルのみを参照するようにします。
- **ESモジュールのみ使用**: JavaScript/TypeScriptではESモジュール（ESM）のみを使用し、CommonJS（require/module.exports）は禁止します。

## 開始方法

### 最小構成（3ファイルから開始）

```
module/
├── application.{ext}    # ユースケース
├── domain.{ext}         # ビジネスロジック
├── infrastructure.{ext} # 外部接続
├── variables.{ext}      # 環境変数・設定値（必須）
└── mod.{ext}           # エクスポート（ライブラリとして提供する場合）
                        # または
└── main.{ext}          # CLIエントリーポイント（実行ツールの場合）
```

### 成長時の分割

ファイルが大きくなったら同名ディレクトリに分割：

```
module/
├── application/
│   └── *.{ext}
├── domain/
│   └── *.{ext}
├── infrastructure/
│   ├── *.{ext}
│   └── variables/        # 大規模時は専用ディレクトリ
│       └── *.{ext}
├── variables.{ext}       # 小規模時は単一ファイル
└── mod.{ext}
```

## エントリーポイント

### エントリーポイントの選択基準

プロジェクトの性質に応じて適切なエントリーポイントを選択：

| プロジェクトタイプ | 必要なファイル | 判断基準 |
|------------------|--------------|----------|
| **実行専用ツール** | `main.{ext}`のみ | 他プロジェクトからの再利用予定なし |
| **ライブラリ専用** | `mod.{ext}`のみ | CLI不要、他から使われる前提 |
| **両方提供** | `main.{ext}` + `mod.{ext}` | CLIとライブラリ両方のニーズあり |

### mod.{ext}作成の判断プロセス

1. **初期判断**: プロジェクト開始時に以下を確認
   - 他プロジェクトから再利用される可能性があるか？
   - 公開APIとして整理する価値があるか？
   - 将来的にnpmパッケージ等として配布する予定があるか？

2. **作成タイミング**:
   - **即座に作成**: ライブラリとしての性質が明確な場合
   - **後から追加**: CLIツールとして開始し、必要になった時点で追加
   - **作成しない**: 実行専用ツールで再利用の予定がない場合

3. **実装時の確認事項**:
   ```
   Q: このモジュールは他のプロジェクトから使われますか？
   → Yes: mod.{ext}を作成し、公開APIを設計
   → No/不明: main.{ext}のみで開始（YAGNI原則）
   ```

> ⚠️ **過度な抽象化を避ける**: 
> mod.{ext}の作成は、明確なライブラリ化のニーズがある場合のみ。
> 「将来使うかもしれない」という理由だけでは作成しない（YAGNI原則）。

### 従来の記述（参考）

- **ライブラリとして提供**: `mod.{ext}`が唯一のエントリーポイント
- **実行ツールとして提供**: `main.{ext}`のみ（ライブラリ化不要な場合）
- **両方提供**: `main.{ext}`（CLI）+ `mod.{ext}`（ライブラリAPI）

## 依存関係とインポート規約

### 依存方向の統一（全言語共通）
- infrastructure → domain ✅
- application → domain ✅
- domain → infrastructure ❌（禁止）
- 同一レイヤー内の依存は自由

### インポート方式
各言語の慣習に従いつつ、以下の原則を守る：

| 対象 | 方式 | 理由 |
|:--|:--|:--|
| モジュール内 | 各言語の相対的記法 | 内部結合の明示 |
| モジュール間 | 各言語の絶対的記法 | 公開APIの利用 |
| 判定基準 | `mod.{ext}`の存在 | モジュール境界の明確化 |

### ファイル構造による制御
```
module/
├── mod.{ext}          # 外部公開API（このファイル経由のみ）
├── internal/          # 内部実装（外部からインポート禁止）
│   ├── domain/
│   └── infrastructure/
└── public/            # 公開型定義
    └── types.{ext}
```

## 環境変数・設定値管理

### 必須ファイル
- **小規模**: `variables.{ext}` - 単一ファイルですべての環境変数を管理
- **大規模**: `infrastructure/variables/*.{ext}` - 機能別に分割

### 実装原則
- グローバル状態の禁止（関数として提供）
- デフォルト値の禁止（必須変数は明示的にエラー）
- 型安全性の確保（TypedDict/type/structで定義）

## 設計に迷ったら

「どの層に配置すべきか」「いつ分割すべきか」で迷った場合は、まず小さく実装し、必要に応じてリファクタリングしてください。
