# README必須規則

## 基本原則

すべてのディレクトリにはREADME.mdが必須。READMEはそのディレクトリの「契約書」として機能する。

## 設計原則

### KISS (Keep It Simple, Stupid)
- 必要最小限の情報のみ記載
- 複雑な説明より明確な例を優先

### YAGNI (You Aren't Gonna Need It)
- 将来の可能性ではなく現在の実態を記載
- 使われていない機能の説明は削除

### DRY (Don't Repeat Yourself)
- 他のREADMEと重複する内容は参照で解決
- 共通概念は上位ディレクトリのREADMEに集約

### SOLID原則
- **単一責務**: 1つのREADMEは1つのディレクトリの説明に専念
- **開放閉鎖**: 拡張には開かれているが、既存の契約は保護
- **依存性逆転**: 具体的な実装詳細ではなく抽象的な目的に依存

### 動的情報の禁止
**記載してはいけない情報**：
- 具体的なファイルパス（例: `src/utils/helper.ts`）
- 関数名・クラス名（例: `getUserById()`）
- 変数名・定数名
- 行番号
- バージョン番号（頻繁に変わるもの）

**理由**：
- リファクタリング時の更新コストが膨大
- 実装と文書の乖離を防ぐ
- メンテナンス性の向上

**代替方法**：
```markdown
❌ 悪い例：
「getUserById()関数でユーザー情報を取得」

✅ 良い例：
「ユーザー情報の取得機能を提供」
```

### 動的な依存関係
**他のREADMEへの参照**：
```markdown
## 関連モジュール
- 認証機能: ../auth/README.md
- データ層: ../database/README.md
```

**継承的な説明**：
- 詳細は個別READMEに委譲
- 親READMEは概要のみ提供
- 子READMEは親の文脈を前提に記述

## READMEの役割

### 1. 目的の明示
- なぜこのディレクトリが存在するのか
- どのような問題を解決するのか
- 誰が使用するのか

### 2. 操作の前提条件
- READMEがないディレクトリは操作禁止
- READMEを読まずに変更を加えることは禁止
- READMEの内容と矛盾する変更は禁止

### 3. 知識の永続化
- 実装の意図を記録
- 設計判断の根拠を保存
- 将来の保守者への引き継ぎ

## 必須記載項目

### 最小構成
```markdown
# [ディレクトリ名]

## 目的
このディレクトリの存在理由と提供する価値

## 構成
主要なファイル・サブディレクトリの説明

## 依存関係
- 前提条件
- 必要なツール
- 関連モジュール
```

### 推奨構成
```markdown
# [ディレクトリ名]

## 目的
このディレクトリが解決する問題と提供する価値

## アーキテクチャ
システム全体における位置づけと責務

## 構成
```
.
├── src/          # ソースコード
├── tests/        # テストコード
└── docs/         # ドキュメント
```

## 使用方法
基本的な使用例とAPI

## 開発
- セットアップ手順
- テスト実行方法
- ビルド方法

## 依存関係
- 外部ライブラリ
- 内部モジュール
- システム要件

## 設計判断
重要な設計判断とその理由

## 今後の課題
- TODO項目
- 既知の問題
- 改善案
```

## ディレクトリ種別ごとのテンプレート

### プロジェクトルート
```markdown
# [プロジェクト名]

## 概要
1-2文でプロジェクトを説明

## 価値提案
このプロジェクトが提供する価値

## クイックスタート
最短で動かす手順

## アーキテクチャ
システム構成図やデータフロー

## 開発
詳細な開発手順
```

### 機能モジュール
```markdown
# [機能名]

## 責務
このモジュールの単一責務

## インターフェース
公開API・関数の説明

## 実装詳細
内部設計や重要なアルゴリズム

## テスト
テスト方針とカバレッジ
```

### 設定ディレクトリ
```markdown
# 設定ファイル

## 環境
- 開発環境
- ステージング環境
- 本番環境

## 設定項目
各設定の説明と影響範囲

## 更新手順
設定変更時の注意事項
```

## 運用規則

### 新規ディレクトリ作成時
1. ディレクトリ作成
2. **即座に**README.md作成（最小構成でも可）
3. 実装を進めながらREADME充実化

### 既存ディレクトリ操作時
1. README.mdの存在確認
2. READMEがない場合：
   - ユーザーに目的確認
   - README作成
   - その後作業開始
3. READMEがある場合：
   - 内容を理解
   - 矛盾しない変更のみ実施

### README更新タイミング
- 新機能追加時
- 設計変更時
- バグ修正で仕様が変わった時
- 依存関係の変更時

## 例外

以下のディレクトリはREADME必須から除外：
- `.git/` - Gitの内部ディレクトリ
- `node_modules/` - 依存パッケージ
- `dist/`, `build/` - ビルド成果物
- `.cache/` - キャッシュディレクトリ

ただし、カスタマイズした設定がある場合は、その旨をプロジェクトルートのREADMEに記載。

## チェックリスト

### ディレクトリ作成時
- [ ] README.mdを作成したか
- [ ] 目的を明記したか
- [ ] 最低限の構成を記載したか

### ディレクトリ操作前
- [ ] README.mdが存在するか
- [ ] READMEの内容を理解したか
- [ ] 変更がREADMEと矛盾しないか

### 作業完了時
- [ ] READMEの更新が必要か確認したか
- [ ] 新しい依存関係を追記したか
- [ ] 設計変更を反映したか

## アンチパターン

### 避けるべきREADME
- 内容が古く実態と乖離
- 「TODO: あとで書く」のまま放置
- 自動生成されたテンプレートのまま
- 実装詳細ばかりで目的が不明
- **動的情報の hardcoding**：
  - `main.ts の 42行目を参照`
  - `processData()関数で処理`
  - `config.json の API_KEY を設定`

### 良いREADME
- 常に最新の状態を反映
- 目的と価値が明確
- 新規参加者が理解できる
- 必要十分な情報量
- **抽象的で安定した記述**：
  - 「エントリーポイントから処理を開始」
  - 「データ処理機能を提供」
  - 「環境変数で認証情報を設定」

## 正規化されたREADMEの例

### 親ディレクトリ
```markdown
# アプリケーション

## 目的
ユーザーのタスク管理を支援

## アーキテクチャ
- フロントエンド: ./frontend/README.md
- バックエンド: ./backend/README.md
- 共通機能: ./shared/README.md
```

### 子ディレクトリ
```markdown
# フロントエンド

## 責務
ユーザーインターフェースの提供
（アプリケーション全体の目的は親READMEを参照）

## 技術スタック
- UIフレームワーク
- 状態管理

## 開発
ビルドとテストの実行方法
```

### 責務の分離
- 各READMEは自身のスコープのみ説明
- 他の部分は参照で解決
- 全体像は親READMEが提供
- 詳細は子READMEに委譲